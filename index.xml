<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Senie</title><link>https://xuxihe.vercel.app/</link><atom:link href="https://xuxihe.vercel.app/index.xml" rel="self" type="application/rss+xml"/><description>Senie</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><copyright>© 曦曦呵呵</copyright><lastBuildDate>Thu, 07 Jul 2022 22:33:05 +0800</lastBuildDate><image><url>https://xuxihe.vercel.app/media/icon_huf638f59a6dd2257b0add8e0186347459_300061_512x512_fill_lanczos_center_3.png</url><title>Senie</title><link>https://xuxihe.vercel.app/</link></image><item><title>C++ STL</title><link>https://xuxihe.vercel.app/notes/oiknowledge/others%E6%9D%82%E9%A1%B9/c++-stl/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/others%E6%9D%82%E9%A1%B9/c++-stl/</guid><description>&lt;p>当你啥也不会的时候，充分利用C++ STL模板可以让你的暴力多得几分。&lt;/p></description></item><item><title>快速幂</title><link>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/</guid><description>&lt;h1 id="快速幂">快速幂&lt;/h1>
&lt;h2 id="幂还有快速">幂还有快速？&lt;/h2>
&lt;p>我们首先来思考一个问题，对于 $7^6$ 如何求。&lt;/p>
&lt;p>作为一个人类，你的求法一定是先算出 $7\times7=49$，然后接着算出 $49\times7=343$，…… ，$16807\times7=117649$。因为人类并不适合算两位数以上的乘法(一位数还勉强可以瞪眼)，所以有些时候我们的思维便会限制在这个里面。&lt;/p>
&lt;p>但是，我们了解，对于计算机CPU来说 $7\times7$ 和 $1561564\times1561564$ 几乎没啥差别(毕竟慢的是存储)，因此我们可以加快幂运算。&lt;/p>
&lt;h2 id="又是二进制">又是二进制&lt;/h2>
&lt;p>没错，你没看错，又是二进制！&lt;/p>
&lt;p>我们早就知道了，对于任意一个二进制数，我们可以拆分成多个 $2^n$ 相加的形式。如：$6_{10}=(110)_2=(100)_2+(10)_2=2^2+2^1$。&lt;/p>
&lt;p>相应的，任意一个数 $x$ 的 $k$ 次方 $x^k$ 都可以拆分成多个 $x^{2^n}$ 相乘的形式。这时候，我们发现，原本的 $O(k)$ 次操作被优化到了 $O(\log{k})$。而我们只需要将 $x^{2^n}$ 不断的自己乘自己，就可以得到所有我们需要的数。&lt;/p>
&lt;p>例子：计算 $7^{14}=7^2\times7^4\times7^8$&lt;/p>
&lt;h2 id="代码">代码&lt;/h2>
&lt;p>[P1226 【模板】快速幂&amp;amp;取余运算][https://www.luogu.com.cn/problem/P1226]&lt;/p>
&lt;pre>&lt;code class="language-c++">//只需要注意mi函数即可
#include &amp;lt;cstdio&amp;gt;
int a, b, p;
inline int mi(int n, int m, int mod, long long sum = 1, long long ans = 1)
//n表示底数,m表示指数,mod为模数,sum为累加器,ans为结果
{
sum = n; //初始化累加器至n^1
while (m) //保证指数不为0
{
if (m &amp;amp; 1) //如果最后一位是1,则应该乘上
{
ans *= sum;
ans %= mod;
}
sum *= sum; //累加器自乘
sum %= mod;
m &amp;gt;&amp;gt;= 1; //这一位已经处理完毕,开始处理下一位
}
return ans % mod;
}
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;p);
printf(&amp;quot;%d^%d mod %d=%d\n&amp;quot;, a, b, p, mi(a, b, p)); //奇奇怪怪的输出方式
}
&lt;/code>&lt;/pre>
&lt;h2 id="链接">链接&lt;/h2>
&lt;p>其他更快的方法，参见[]、[]。&lt;/p></description></item><item><title>搜索</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%90%9C%E7%B4%A2/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%90%9C%E7%B4%A2/</guid><description>&lt;h1 id="dfs">DFS&lt;/h1>
&lt;h2 id="深度优先搜索">深度优先搜索。&lt;/h2>
&lt;p>深度优先，即每一次均搜索一条完整的从起点到达终点的路径，然后继续搜索第二条。&lt;/p>
&lt;p>原始支持有权图搜索。&lt;/p>
&lt;p>一般情况下，通常使用递归的方式实现。&lt;/p>
&lt;p>具体流程为，对于当前节点，循环遍历下一个目标节点，对于可能的目标节点调用递归函数，直到终止条件。&lt;/p>
&lt;p>状态一般包括step，记录决策的数组等，可以放在全局变量中（注意回溯时需要回退全局变量）。&lt;/p>
&lt;h2 id="剪枝">剪枝&lt;/h2>
&lt;p>剪枝就是切掉一部分无用的搜索树，起到优化复杂度的作用&lt;/p>
&lt;ol>
&lt;li>
&lt;p>**记忆化：**dfs函数中传入相同的状态往往会得到一样的解，所以用数组记录下对应每个状态的答案，若之前已求得直接返回即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**求代价和最小：**若转移时代价非负，则若目前的代价和已经大于等于之前的最小答案，直接返回。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>更改转移的枚举顺序&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="启发式搜索">启发式搜索&lt;/h2>
&lt;p>当搜索到一个状态u时，计算估价函数 $f(u)$ 的值：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于转移需要代价的题目，$f(u)$ 代表转移到末状态的最小代价，如果走到u状态的代价 $g(u)+f(u)&amp;gt;ans$ 则剪枝&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于转移得到收益的题目，$f(u)$ 表示可能的最大收益，如果 $g(u)+f(u)≤ans$ 则剪枝&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="a">A*&lt;/h2>
&lt;p>估价函数同启发式搜索，但是我们用优先队列进行类广搜,每次取出 $f(x)+g(x)$ 最小的 $x$，然后更新相邻的状态。&lt;/p>
&lt;h2 id="ida">IDA*&lt;/h2>
&lt;p>迭代加深A*，仅仅是添加了限制层数。&lt;/p>
&lt;h2 id="dfs生成树">DFS生成树&lt;/h2>
&lt;p>在一个有向图中，以DFS的方式选取某一节点进行搜索而形成的树+边的结构。&lt;/p>
&lt;p>举个栗子：&lt;/p>
&lt;p>我们先看一个有向图：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="graph%20%282%29.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>用DFS跑图，就可以得到一下这个：&lt;/p>
&lt;img src="dfs-tree.svg" style="zoom:120%;" />
&lt;p>我们可以以树形结构将图中的边分为四种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>树边：每个节点第一次被访问时经过的边，整体称为搜索树。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;font color="red">返祖边：从子树中的节点到其父亲节点的边。&lt;/font>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;font color="green">前向边：从父亲节点直接指向儿子(也可以是孙子等)节点的边。&lt;/font>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;font color="blue">横叉边：搜索的时候遇到了一个已经访问过的结点，但是这个结点&lt;strong>并不是&lt;/strong>当前结点的祖先时形成的。(看不懂？流氓定义：如果这条边不是上面三种，那就是横叉边)&lt;/font>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="dfs序">DFS序&lt;/h2>
&lt;p>字面意思，很好理解，就是用DFS&lt;strong>前序遍历&lt;/strong>一棵树上所有节点和边时访问的顺序。&lt;/p>
&lt;p>我们知道，树是一种非线性的数据结构，它的一些数据调用肯定是没有线性结构来得方便的。所以这个时候，dfs站了出来。&lt;/p>
&lt;p>如图，这是一棵树：&lt;/p>
&lt;img src="graph%20(2)-16321427081993.png" alt="afd" style="zoom:90%;" />
&lt;p>所以，整了一大顿，这DFS序到底有啥子用？这得从DFS的优势来探讨了。&lt;/p>
&lt;p>DFS是深度优先的，所以对于一个点，它会先遍历完它的所有子节点，再去遍历他的兄弟节点以及其他子树的节点。&lt;/p>
&lt;p>因此DFS序保证了一棵树(子树)的根节点和其子树中所有的节点会被存储在连续的区间之中。&lt;/p>
&lt;p>比如，以 $5$ 为根的子树中节点编号为 $5\sim8$。&lt;/p>
&lt;p>这样，我们把一个非线性的数据结构——树，成功转化为了一个线性的数据结构，然后……&lt;a href="../data%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">请自行选择&lt;/a>。&lt;/p>
&lt;p>&lt;strong>But!&lt;/strong> 我们现在还有一个问题：&lt;/p>
&lt;p>如何直到我的子树区间到哪？别搞出去就不好了。&lt;/p>
&lt;p>欲知详情，请接着看 -_-&lt;/p>
&lt;h3 id="时间戳">时间戳&lt;/h3>
&lt;p>这玩意好比一个标签，贴在每一个点上，记录dfs第一次开始访问这个点的时间以及最后结束访问的时间。&lt;/p>
&lt;p>我们发现，节点 $i$ 的DFS序其实是DFS第一次访问节点 $i$ 的时间，因此我们只需要记录最后结束访问的时间即可。&lt;/p>
&lt;p>实现很简单，循环完儿子之后(回溯之前)记录一下当前最大DFS序值即可。&lt;/p>
&lt;p>这样，我们成功的把一棵树变成了一段段的&lt;strong>区间&lt;/strong>：&lt;/p>
&lt;img src="graph%20(3).png" alt="fad" style="zoom:90%;" />
&lt;h1 id="bfs">BFS&lt;/h1>
&lt;h2 id="广度优先搜索">广度优先搜索。&lt;/h2>
&lt;p>广度优先，即每一次都搜索距离起点相同长度的点，然后继续搜索长度 $+1$ 的点，直到搜索到终点。&lt;/p>
&lt;p>原始不支持有权图，但可以使用算法优化。&lt;/p>
&lt;p>一般情况下，通常使用队列的方式实现。&lt;/p>
&lt;p>具体流程为，先将起始节点推入队列，每次循环弹出队首元素，将其加入以搜索的点集，并将与之连接的未加入以搜索的点集的点推入队列尾部，直到找到终点或者队列为空。&lt;/p>
&lt;h2 id="双向bfs">双向BFS&lt;/h2>
&lt;p>要求 $S$ 状态到 $T$ 状态的最小转移次数，从 $S$，$T$ 分别同时出发进行BFS，直到BFS到的点相遇为止。&lt;/p>
&lt;p>理论上将深度为 $n$ 的搜索树拆分成了两棵深度为 $\frac{n}{2}$ 的搜索树 。若决策个数为 $k$，搜索树大小由 $k^n$ 优化为 $2\times k^\frac{n}{2}$。&lt;/p>
&lt;p>如何判断一个局面（状态）是否被访问过？可以将全局状态变成一个整数，用&lt;code>map&lt;/code>或&lt;code>unordered_map&lt;/code>记录该整数是否出现过。&lt;/p>
&lt;h1 id="三个要素">三个要素&lt;/h1>
&lt;ul>
&lt;li>状态：怎么表示？要求包括全部信息、能够标记是否已访问。&lt;/li>
&lt;li>转移：转移后的状态计算，转移代价计算。&lt;/li>
&lt;li>优化：剪枝（剪掉无用的搜索子树），修改搜索顺序，估价函数。&lt;/li>
&lt;/ul></description></item><item><title>并查集</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid><description>&lt;h1 id="普通并查集">普通并查集&lt;/h1>
&lt;h2 id="引子">引子&lt;/h2>
&lt;p>&lt;del>脑洞蛮大的一个东西，自己还改了改&lt;/del>&lt;/p>
&lt;p>​ 江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。
​ 但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。
​ 这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。
​ 但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？&lt;/p>
&lt;p>​ 我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“周翡队”“谢允队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。&lt;/p>
&lt;p>​ 但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长(抓狂!)。要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”
​ 这样，想打一架得先问个几十年，饿都饿死了，受不了。这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限死循环中。
​ 于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，队长就是根节点，下面分别是二级军官、三级小兵……每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。
​ 由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。&lt;/p>
&lt;p>​ 现在，我们用fa[i]数组记录编号为i的大侠上级的编号。如果fa[i]==i，则i号大侠是队长。而find函数这是用来寻找队长的。
​ 我非常喜欢周翡与谢允，他们分别属于四十八寨和皇亲国戚，那明显就是两个阵营了。我不希望他们互相打架 &lt;del>(磕糖没够)&lt;/del> ，就对他俩说：“你们两位拉拉勾，做好(x)朋(q)友(l)吧。”
​ 他们看在我的面子上，同意了(我脸真大)。这一同意可非同小可，整个四十八寨和皇帝的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？
​ 其实非常简单，我对谢允说：“大师，麻烦你把你的上级改为周翡吧。这样一来，两派原先的所有人员的终极boss都是周翡，那还打个球啊！”谢允一听肯定火大了：“我艹，凭什么是我变成她手下呀，怎么不反过来？我抗议！”&lt;del>(大笑)(反正我们关心的只是连通性，门派内部的结构不要紧的，人家家事也不好管的。)&lt;/del>&lt;/p>
&lt;p>​ 于是，两人相约一战，杀的是天昏地暗，风云为之变色啊。但是啊，这场战争终究会有胜负，胜者为王，弱者就被吞并了。反正谁加入谁效果是一样的，门派就由两个变成一个了。而together函数就是用来合并门派的。&lt;/p>
&lt;p>​ 两个互不相识的大侠碰面了，想知道能不能干一场。于是赶紧打电话问自己的上级：“你是不是掌门？”上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。”
​ 一路问下去，原来两人的队长都是周翡。“哎呀呀，原来是自己人，有礼有礼，在下岐兰山盘龙洞白面葫芦娃!”“幸会幸会，在下万仙山暖香阁狗尾(yi)巴花！”两人高高兴兴地手拉手喝酒去了。“等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。“哦，对了，还要做路径压缩。”两人醒悟。(find)
​ 白面葫芦娃打电话给他的上级六掌门：“组长啊，我查过了，其实偶们的掌门是周翡。不如偶们一起结拜在周翡手下吧，省得级别太低，以后查找掌门麻烦。”
​ “唔，有道理。”白面葫芦娃接着打电话给刚才拜访过的三执事……仙子狗尾巴花也做了同样的事情。
​ 这样一来，整个门派树的层数都会维持在比较低的水平上，便于查找。&lt;/p>
&lt;h2 id="开始了">开始了&lt;/h2>
&lt;p>乐呵够了，开始了…………&lt;/p>
&lt;p>上述玄幻故事生动形象地讲述了一个&lt;del>中华武林的真实故事&lt;/del> 啊不，是&lt;strong>并查集&lt;/strong>。&lt;/p>
&lt;p>提到了几个要点：fa数组，find函数，together函数，路径压缩 &lt;em>&lt;del>等等&lt;/del>&lt;/em>&lt;/p>
&lt;h3 id="fa数组">fa数组&lt;/h3>
&lt;p>fa[i]​&lt;del>生动形象地&lt;/del>记录了你的爹地是谁qwq&lt;/p>
&lt;p>是不是很直观、生动？&lt;/p>
&lt;p>咳咳，fa[i]表示第$i$个节点的父亲(也就是掌门人)的节点编号&lt;/p>
&lt;h3 id="find函数">find函数&lt;/h3>
&lt;p>你开始打电话，逐层查找你的上级、你上级的上级…………&lt;/p>
&lt;p>实现十分简单，只要不断访问fa[i]即可，直到 $fa[i]=i$​；&lt;/p>
&lt;h3 id="together函数">together函数&lt;/h3>
&lt;p>两个门派经过昏天黑地的战斗后，决定合并…………&lt;del>因为人都打没了&lt;/del>&lt;/p>
&lt;p>只要把find函数返回的值选择一个合并到另一个里即可&lt;/p>
&lt;pre>&lt;code class="language-c++">fa[find(x)]=find(y);
&lt;/code>&lt;/pre>
&lt;h3 id="路径压缩">路径压缩&lt;/h3>
&lt;p>故事最后一段&lt;/p>
&lt;p>为了防止储存集合所生成的树过高而采用的方法&lt;/p>
&lt;p>具体来说，就是每一次find时，将所访问到的所有节点都挂在根节点下。&lt;/p>
&lt;h3 id="按秩合并">按秩合并&lt;/h3>
&lt;p>&lt;em>（达到和路径压缩几乎&lt;strong>相同&lt;/strong>的结果，但是并不更优，还难以理解，&lt;del>放弃吧&lt;/del>…………）&lt;/em>&lt;/p>
&lt;p>记录每棵树的树高(根到叶子的最大边数)depi,两棵树合并的时候将dep较小的根挂在dep较大的根下面。&lt;/p>
&lt;p>当且仅当两棵树的dep相同时新树的树高为dep+1,否则为dep。&lt;/p>
&lt;p>那么dep=1的树有一个结点,dep=2的树至少有两个结点,dep=3的树只能至少由两个dep=2的树合并而来,所以至少有4个结点&amp;hellip;&lt;/p>
&lt;p>所以按秩合并保证了树高不超过$\log{n}$​,时间复杂度$O(n\log{n})$​​&lt;/p>
&lt;p>贴份代码：&lt;/p>
&lt;pre>&lt;code class="language-c++">int f[N], s[N]; // 取秩为集合大小
inline void init(int n)
{
for (int i = 1; i &amp;lt;= n; ++i)
f[i] = i, s[i] = 1;
}
int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); } // 路径压缩
inline void merge(int x, int y)
{ // 按秩合并
x = find(x), y = find(y);
if (x == y)
return;
if (s[x] &amp;gt; s[y])
swap(x, y);
f[x] = y, s[y] += s[x];
}
&lt;/code>&lt;/pre>
&lt;h3 id="最后代码-surprise">最后……………代码! surprise!!!&lt;/h3>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3367" target="_blank" rel="noopener">洛谷P3367&lt;/a> &lt;del>就是板子&lt;/del>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
const int maxe = 10009;
int n, m, fa[maxe];
inline int find(int x) //find函数和路径压缩的完美结合,递归思想
{
return fa[x] == x ? x : fa[x] = find(fa[x]);
}
inline void together(int a, int b) //应该是最短的写法
{
fa[find(a)] = find(b);
}
int main()
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
for (int i = 1; i &amp;lt;= n; i++) //初始化,最开始每个人都是一个门派
{
fa[i] = i;
}
while (m--)
{
int a, b, c;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
if (a == 1)
together(b, c);
else
printf(&amp;quot;%c\n&amp;quot;, find(b) == find(c) ? 'Y' : 'N');
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h1 id="带权并查集">带权并查集&lt;/h1></description></item><item><title>栈</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</guid><description/></item><item><title>背包问题</title><link>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="背包问题">背包问题&lt;/h1>
&lt;h2 id="01背包">01背包&lt;/h2>
&lt;h3 id="引题">引题：&lt;/h3>
&lt;p>&lt;strong>原版：&lt;/strong>
有一个背包，可容纳重量为 $k$ 的物品。有 $n$ 个物品（每个物品只有一个），第 $i$ 个物品的重量为 $w[i]$，价值为 $val[i]$。求背包可容纳物品的最大价值。&lt;/p>
&lt;p>&lt;strong>魔改版：&lt;/strong>&lt;/p>
&lt;p>你有 $n$ 项作业，但是你只有 $k$ 的时间，第 $i$ 项作业需 $val_i$ 个小时完成。但是，因为作业的内容、难度不同，对于每一项作业老师取得的快乐值也不同。&lt;/p>
&lt;p>比如：如果你完成了一道全班只有你才完成的数学难题，老师会很高兴，即使你没有把定义练习抄写1000000000遍，老师也不会批评你；然而，如果你只把 $1+1=2$ 这类的题做完了，而稍微难一点儿的题就不做，老师就会很生气，认为你很懒，而让你把定义再抄100000000000遍。&lt;/p>
&lt;p>问，在有限的时间内，如何使老师获得的快乐值最大？&lt;del>从而免去抄写&lt;/del>&lt;/p>
&lt;h3 id="心灵的震撼">心灵的震撼&lt;/h3>
&lt;p>我相信，每一个第一次接触dp的人都会为之而着迷，毕竟一种优美的暴力手段是每一个有着 $ak\space IOI$ 的人所梦寐以求的。&lt;/p>
&lt;p>dp之所以比暴搜快，可以看做是因为记录了中间过程的权值，进而优化掉了DFS中很多重复的子树，也可以看做一种牺牲空间换取时间的做法。&lt;/p>
&lt;p>dp的核心思想就是从之前的状态推导当前状，进而在 $O(1\sim n)$ 的时间内找到当前状态的解。&lt;/p>
&lt;p>也就是说，dp时无需考虑问题整体，而是化为一个个的状态，只需要关注某个状态如何从之前已经得到的状态中转移过来。&lt;/p>
&lt;p>使用dp时很多时候论证其正确性是一个费时费力还费脑子的工作，因此dp题目需要你有一定的经验、大胆的尝试和欧气(毕竟dp的样例一般都很水，可能一道题样例全过就得个 $30+$ 的分数也不是没有可能)，因为考试的时候没那么多时间，大多数dp代码都不长，建议有想法就直接写，搞出来后跑样例，然后再做调整。正常情况下，只要能过 $1+$ 个样例，基本上不会暴零。可以先写出一个局部解，然后再完善dp的状态转移方程。&lt;/p>
&lt;p>&lt;del>上面唠唠叨叨&lt;/del>&lt;/p>
&lt;p>dp最重要的就是&lt;strong>状态&lt;/strong>和&lt;strong>转移&lt;/strong>。&lt;/p>
&lt;p>在01背包中，我们用 $dp[i][j]$ 表示在前 $i$ 件物品中选择，背包容量为 $j$ 时能装的最大价值。&lt;/p>
&lt;p>然后，思考这个式子：
$$
dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+val[i])
$$
$max$ 表示求取的最大值。因为我们已经知道了前 $i-1$ 个物品在背包容量为 $a\in[1,k]$ 时能装下的最大价值，因此对于第 $i$ 件物品，只有两种选择：&lt;/p>
&lt;ol>
&lt;li>装(前提是 $w[i]\le j$，毕竟得能装下才有讨论的必要)&lt;/li>
&lt;li>不装 &lt;del>(你能把我怎样？)&lt;/del>&lt;/li>
&lt;/ol>
&lt;p>若不选择第 $i$ 件物品，很简单，其在容量为 $j$ 的背包下最大价值 $=$ 从前 $i-1$ 件中选择的最大价值(反正不选第 $i$ 件，所以没有影响) $=\space dp[i-1][j]$。&lt;/p>
&lt;p>若选择第 $i$ 件物品，则应在前 $i-1$ 个中选择后至少剩余 $w[i]$ 的背包空间，然后选择第 $i$ 个物品，我们就会获得它的价值 $val[i]$，因此总共获得价值为 $dp[i-1][j-w[i]]+val[i]$。&lt;/p>
&lt;p>易证，当物品相同时，大容量的背包装的总价值一定不小于小背包装的，因此只考虑最大的可能背包即可，不必遍历小背包。&lt;/p>
&lt;p>当我们把这张表填完的时候，$dp[n][k]$ (表示选择前 $n$ 个物品背包容量为 $k$ 时能装下的最大值)就是我们要求的最终答案。&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;h3 id="线性优化">线性优化&lt;/h3>
&lt;p>我们发现了一个问题，上述01背包问题求解时，时间复杂度为 $O(nk)$，而空间复杂度也为 $O(nk)$。&lt;/p>
&lt;p>因为这玩意常数比较小，在 $nk\le10^8$ 内都能跑过，但是，内存肯定不够用啊……&lt;del>人间疑惑&lt;/del>&lt;/p>
&lt;p>可不可以优化一下啊，毕竟好不容易不TLE了要是再MLE可就要&lt;del>砸电脑了&lt;/del>螺旋升天了，进而怀疑人生……&lt;/p>
&lt;p>好消息！好消息！好消息！空间可以优化！&lt;/p>
&lt;p>观察转移方程，我们实际上只用到了 $2\times k$ 个值，其余的我们都不需要，所以，我们搞一个 &lt;code>int dp[2][k]&lt;/code>好吗？&lt;/p>
&lt;p>&lt;strong>当然可以！&lt;/strong>&lt;del>只要你调的出来，理论上确实可行，只要你不是每搞完一行整一个 O(k) 的复制就行&lt;/del>&lt;/p>
&lt;p>下面，让我们再动脑子想一想，在缩小一下转移方程使用到的值，其实只有 $dp[i-1][a\in[1,j]]$，大于 $j$ 的我们用不到！&lt;/p>
&lt;p>所以，我们能不能在一维数组上解决这个问题呢？&lt;/p>
&lt;p>&lt;strong>当然可以！&lt;/strong>&lt;del>没得怕的&lt;/del>&lt;/p>
&lt;p>只要我们从后往前遍历即可！即&lt;code>for(int i = k;i &amp;gt; 0;i--)&lt;/code>即可。&lt;/p>
&lt;p>因为，当我们遍历原二维数组第 $i$ 行时，现在数组中存储的就是原二维数组第 $i-1$ 行的值，并且即使大于 $j$ 的部分被更改，我们需要使用的小于等于$j$ 的部分仍旧是原第 $i-1$ 行的dp值，因此，状态转移方程魔改一下：
$$
dp[j]=max(dp[j],dp[j-w[i]]+val[i])
$$
&lt;del>体会到了人类脑洞之大&lt;/del>&lt;/p>
&lt;p>我们的最终答案，就在跑完之后，存在 $dp[k]$ 的地方。&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;p>注：&lt;/p>
&lt;ul>
&lt;li>如果要 $dp[j] =$ 重量恰好为 $j$ 的最大价值，在DP前将 $dp$ 数组初始化为 $\infty$ 即可。&lt;/li>
&lt;li>如果有重量为负值（显然此时要求的是重量恰好为 $j$ 的最大价值），循环顺序要改为正序，且 $dp$ 的下标统一加一个足够大的数以保证全为正数！&lt;/li>
&lt;li>一维优化不能重构路径，但是二维数组可以通过一些办法(回溯，又称为逆推)求出咋装的。&lt;/li>
&lt;/ul>
&lt;h2 id="完全背包">完全背包&lt;/h2>
&lt;p>背包问题大多是从01背包的基础上演化而来，简言之就是01背包的增强版。&lt;/p>
&lt;p>01背包的问题魔改一下就是完全背包：&lt;/p>
&lt;p>我们还有一个背包，可容纳重量为 $k$ 的物品。有 $n$ &lt;strong>种&lt;/strong>物品（每种物品有&lt;strong>无限多个&lt;/strong>），第 $i$ 种物品的重量为 $w[i]$，价值为 $val[i]$。求背包可容纳物品的最大价值。&lt;/p>
&lt;p>我们依然使用 $dp[i][j]$ 表示从前 $i$ 种物品中选择，背包容量为 $j$ 时能装的最大价值。&lt;/p>
&lt;p>然后，状态转移方程就变化了：
$$
dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+val[i])
$$
不难发现，对于第 $i$ 种物品，我们可以选择 $a\in[0,\frac{j}{w[i]}]$ 个。分为两类：&lt;/p>
&lt;ol>
&lt;li>不选第 $i$ 种物品。&lt;/li>
&lt;li>选第 $i$ 种物品 $a$ 个。&lt;/li>
&lt;/ol>
&lt;p>然后，这个问题又可以分为两步：&lt;/p>
&lt;ol>
&lt;li>确定选还是不选&lt;/li>
&lt;li>如果选，选几个&lt;/li>
&lt;/ol>
&lt;p>这时候，想一想dp的奥妙，即从已知推导出未知。&lt;/p>
&lt;p>不选很好解决，$dp[i-1][j]$ 就是不选第 $i$ 种的最大价值。&lt;/p>
&lt;p>那如果选呢？再回想dp数组的意义和01背包对于选物品的空间预留，可以得到 $dp[i][j-w[i]]+val[i]$ 这样的一个式子。我们只需要在可以选择第 $i$ 种的情况下留出 $w[i]$ 的空间来再装下一个第 $i$ 种物品即可。这样，我们无需知道第 $i$ 种物品应该选择几个，因为我们只需要在之前的最优解上进行状态转移即可，换言之我们只需要考虑多装一个是否更优，而不是遍历装几个更优，因为背包容量从小到大，能装下的个数也是从小到大。&lt;/p>
&lt;h3 id="线性优化-1">线性优化&lt;/h3>
&lt;p>和01背包一样，完全背包依旧时间复杂度 $O(nk)$，空间复杂度 $O(nk)$。&lt;/p>
&lt;p>那么，就会出现同样的问题。&lt;/p>
&lt;p>既然差不多，完全背包也能线性优化吗？&lt;/p>
&lt;p>**当然可以！**只不过需要进行一些调整，来适应新的状态转移方程。&lt;/p>
&lt;p>我们发现，新的状态转移方程依赖于 $dp[i][a\in[0,j]]$ 而并不依赖于 $dp[i-1][a\in[0,k]]$ 和 $dp[i][a\in(j,k]]$，因此，我们需要改变遍历的顺序。&lt;/p>
&lt;p>上面我们已经理解了线性优化后 $dp[j]$ 在修改前表示 $dp[i-1][j]$，所以&lt;code>for(int i = 0;i &amp;lt; k;i++)&lt;/code>改为正序遍历即可先求出第 $i$ 行较小的 $j$ 进而推导出较大的 $j$，完成dp。这样，空间复杂度降为 $O(k)$。&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;p>同01背包，一维优化不能重构路径，但二维可以。&lt;/p>
&lt;h2 id="多重背包">多重背包&lt;/h2>
&lt;p>同样，上来还是老问题：&lt;/p>
&lt;p>我们又有一个背包，可容纳重量为 $k$ 的物品。有 $n$ 中物品，第 $i$ 种物品有 $c[i]$个，每个重量为 $w[i]$，价值为 $val[i]$。求背包可容纳物品的最大价值。&lt;/p>
&lt;p>看，看，看，是不是和01背包又是差不多？&lt;/p>
&lt;p>所以，最简单的想法就是将每个物品拆成独立的个体，跑01背包，时间复杂度为 $O(k\times\sum_{i=1}^nc[i])$。&lt;/p>
&lt;p>但是，显然，&lt;strong>太慢了！&lt;/strong>&lt;/p>
&lt;p>观察，多重背包与01背包最大的不同，就是有多个物品属性相同， 这也成为优化的入手点。&lt;/p>
&lt;p>先说一个题外话：人民币大家都知道吧，有$1$元的、$10$元的还有红色毛爷爷……那么，为什么不全用$1$元的？这样也可以表示任意的金额啊？&lt;/p>
&lt;p>但是，前几天刚出现了一个新闻，某男子用一麻袋硬币交房租被告上法庭……所以，体会到了红色毛爷爷的重要性。&lt;/p>
&lt;p>因此，我们的多重背包也可以借助这个思想，将 $c[i]$ 个物品划分成几组，从而能且仅能表示出所有 $a\in[0,c[i]]$ 。&lt;/p>
&lt;p>问题来了，知道了为什么要分组，接下来就是怎么分组了。&lt;/p>
&lt;h3 id="二进制拆分">二进制拆分&lt;/h3>
&lt;p>我们先来看 $0\sim19$ 的二进制表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>十进制&lt;/th>
&lt;th>二进制&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>00000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>00001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>00010&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>00011&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>00100&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>00101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>00110&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>00111&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>01000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9&lt;/td>
&lt;td>01001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10&lt;/td>
&lt;td>01010&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>11&lt;/td>
&lt;td>01011&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12&lt;/td>
&lt;td>01100&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>13&lt;/td>
&lt;td>01101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>14&lt;/td>
&lt;td>01110&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>15&lt;/td>
&lt;td>01111&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16&lt;/td>
&lt;td>10000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>17&lt;/td>
&lt;td>10001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>18&lt;/td>
&lt;td>10010&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>19&lt;/td>
&lt;td>10011&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>然后，我们发现，对于任意一个二进制数，均可以用不同的只有一位是 $1$ 的二进制数相加得到，如：&lt;/p>
&lt;p>$13$ = $(01101)_2$ = $(01000)_2+(00100)_2+(00001)_2$&lt;/p>
&lt;p>而这个规律翻译成十进制就是，对于数 $2^{k-1}&amp;lt;a\le2^k$ 一定可以用 $2^0,2^1,2^2,2^3,\dots,2^{k-1}$ 和 $a-2^{k-1}$ 中的某几个数相加得到。这就构成了我们分组的依据。&lt;/p>
&lt;p>我们将 $c[i]$ 拆分成 $2^0,2^1,2^2,\dots,2^{k-1},c[i]-a$，当成一共 $k$ 个物品，第 $x$ 组(个)物品的重量为 $第x组的个数\times w[x]$，价值为 $第x组的个数\times val[x]$。&lt;/p>
&lt;p>这样拆分之后，在跑01背包，即可将时间复杂度降至 $O(k\times\sum_{i=1}^n\log{c[i]})$。&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;h2 id="混合背包">混合背包&lt;/h2>
&lt;p>01、完全、多重背包三合一。&lt;del>大锅炖&lt;/del>&lt;/p>
&lt;p>01背包当 $c[i]=1$，完全背包当 $c[i]=\lfloor\frac{k}{w[i]}\rfloor$ 即可。&lt;/p>
&lt;h2 id="多限制背包">多限制背包&lt;/h2>
&lt;p>物品有更多属性，对每种属性都有限制。&lt;/p>
&lt;p>把所有限制都加到状态里即可。&lt;/p>
&lt;h2 id="分组背包">分组背包&lt;/h2>
&lt;p>描述：有n件物品，分为若干组，现约束，在每组物品里最多取一件物品放入背包，每件物品的重量确定，价值确定，背包容量确定，求在不超过背包容量的情况下，可以存放的最大价值。&lt;/p>
&lt;p>$w[i][j]$ 表示第 $i$ 组第 $j$ 件物品的重量，$val[i][j]$ 表示第 $i$ 组第 $j$ 件物品的价值，$dp[a][b]$ 表示在前 $a$ 组中选择重量不大于 $b$ 的最大价值。&lt;/p>
&lt;p>对于任意一组物品，共计两类状态：&lt;/p>
&lt;ol>
&lt;li>一个都不选&lt;/li>
&lt;li>选择第 $i\in[1,len]$ 个&lt;/li>
&lt;/ol>
&lt;p>因此，在01背包的基础上进行嵌套循环，每次遍历整组，求出最优解即可。&lt;/p>
&lt;p>线性空间优化见上文。&lt;/p>
&lt;h2 id="背包方案计数">背包方案计数&lt;/h2>
&lt;p>把所有的取 $max$ 都改成求和即可。&lt;/p>
&lt;p>&lt;strong>注意：&lt;strong>多重背包不能用二进制拆分优化了，因为&lt;/strong>同样的&lt;/strong>数量拆分方式&lt;strong>不唯一&lt;/strong>。&lt;/p>
&lt;h2 id="依赖性背包">依赖性背包&lt;/h2>
&lt;p>依赖关系只有一层：把每个“主件”当做一个背包，然后将各背包合并（也是树形背包的基本思路）。&lt;/p>
&lt;p>无循环依赖（树形背包）：&lt;a href="./%e6%a0%91%e5%bd%a2dp.md">树形DP&lt;/a>。&lt;/p>
&lt;p>有循环依赖：&lt;a href="../graph%e5%9b%be%e8%ae%ba/%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f.md">Tarjan+缩点&lt;/a> + &lt;a href="./%e6%a0%91%e5%bd%a2dp.md">树形DP&lt;/a>。&lt;/p>
&lt;p>请在相应章节查看。&lt;/p></description></item><item><title>递推和递归</title><link>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E9%80%92%E5%BD%92/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E9%80%92%E5%BD%92/</guid><description>&lt;h1 id="递推">递推&lt;/h1></description></item><item><title>拓扑排序</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid><description>&lt;h1 id="拓扑排序">拓扑排序&lt;/h1>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_39970166/article/details/110870115" target="_blank" rel="noopener">一篇博文&lt;/a>&lt;/p>
&lt;h2 id="引子">引子&lt;/h2>
&lt;p>下面让我来看一看拓扑序是什么，又有啥子用。&lt;/p>
&lt;p>众所周知，万事都要讲究先来后到。比如，你对一个婴儿进行早教，你很自信、很闪耀，觉得此孩儿定是天降奇才，跳过了万水千山，连话都不会说，直接交他拓扑排序，为以后发扬光大OI事业而打下坚实的基础。然后，一段时间以后，你忽然发现，你教授完一万字的长篇大论然而并没有一点用处，甚至人家一眼都没看你。所以，你十分灰心，感受到了生活的无情，决定放下倔强，从头教起。你潜心研究，发现有一些知识需要在某些知识已经掌握的情况之下才可以学习；所以，你编写了一个程序，给出学习各种知识的先后顺序。&lt;/p>
&lt;h2 id="为啥是图论">为啥是图论&lt;/h2>
&lt;p>看上面的段子，脑海中浮现出各种问号……&lt;/p>
&lt;p>这东西为啥子是图论嘞？&lt;/p>
&lt;p>我们先搞一下啥是DAG(有向无环图)：&lt;/p>
&lt;p>&lt;strong>一个有向图,且不存在环。&lt;/strong> &lt;del>多么简洁明了&lt;/del>&lt;/p>
&lt;img src="104909e17df721889a8ef5386d33263d.png" alt="DAG" style="zoom: 55%;" />
&lt;p>这时候，考虑将边 $u\rightarrow{v}$​ 具体为”做 $v$ 之前要先做 $u$​​ ”，那么拓扑排序能求出每件事应该在什么时候做，也就是说满足每件事的前置事件都做完后它才能开始做的一种安排。&lt;/p>
&lt;p>&lt;strong>拓扑序不是唯一的,因为有些点之间不存在拓扑关系。&lt;/strong>&lt;/p>
&lt;p>比如，上图中A和E、B和D等就没有拓扑关系。&lt;/p>
&lt;p>建图到此结束。&lt;/p>
&lt;h2 id="bfs款">BFS款&lt;/h2>
&lt;p>入度：指向某个点的有向边条数。&lt;/p>
&lt;p>我们发现，对于任意一个DAG，总有入度为$0$的节点。完成这个节点无需依赖其他任何节点的完成情况。&lt;/p>
&lt;p>因此，我们维护一个队列(其实栈也不是不行)，队列中包含所有入度为$0$的节点。&lt;/p>
&lt;p>对于每一个队列中节点，删去其所有初度，并将删边后入度为$0$​的节点加入队列。&lt;/p>
&lt;p>如需按照字典序大小求拓扑序，改为使用优先队列即可(即优先访问字典序大/小的节点)。&lt;/p>
&lt;p>记录已经遍历的节点数，若队列为空并且已经遍历的节点数小于总节点数，则说明存在环。&lt;/p>
&lt;img src="6e6578e58c374ddeca7d1ff41d0e8aab.png" alt="huan" style="zoom:65%;" />
&lt;p>如上图，当出现环时，删除一定数量的节点和边后，出现所有节点入度均大于$0$​的情况，即队列为空。&lt;/p>
&lt;p>两种算法复杂度均为$O(n+m)$。&lt;/p>
&lt;p>&lt;a href="http://poj.org/problem?id=2367" target="_blank" rel="noopener">POJ2367&lt;/a> 外加一点补充&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;
using std::vector;
const int maxe = 109; //最大节点个数
int len, in[maxe], cnt; //len总节点数,in[i]第i号节点的入度,cnt已经遍历的节点个数
vector&amp;lt;int&amp;gt; next[maxe]; //邻接链表存图
std::priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, std::greater&amp;lt;int&amp;gt; &amp;gt; running; //如无需按字典序输出,请改用queue;注意两个'&amp;gt;'中间有一个空格,看好是小顶堆还是大顶堆
int main()
{
scanf(&amp;quot;%d&amp;quot;, &amp;amp;len);
for (int i = 1; i &amp;lt;= len; i++)
{
int a;
while (1)
{
scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
if (!a)
break;
next[i].push_back(a);
in[a]++; //每有一条指向节点的边,入度+1
}
}
for (int i = 1; i &amp;lt;= len; i++)
{
if (in[i] == 0) //查找所有入度为0的节点
running.push(i);
}
while (!running.empty())
{
int top = running.top();
running.pop();
printf(&amp;quot;%d &amp;quot;, top);
cnt++; //已经遍历的节点数+1
int n = next[top].size();
for (int i = 0; i &amp;lt; n; i++) //遍历所有出度,进行删边操作
{
int now = next[top][i];
in[now]--;
if (!in[now]) //如果删边后入度为0,则加入队列
running.push(now);
}
}
if (cnt != len) //如果以遍历节点数小于总节点数,说明有环
printf(&amp;quot;error\n&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="dfs款">DFS款&lt;/h2>
&lt;p>选定一个节点，递归完成他的入度。&lt;/p>
&lt;p>对于每个节点循环。&lt;/p>
&lt;p>&lt;del>还是学上面那个吧&lt;/del>&lt;/p></description></item><item><title>离散化</title><link>https://xuxihe.vercel.app/notes/oiknowledge/others%E6%9D%82%E9%A1%B9/%E7%A6%BB%E6%95%A3%E5%8C%96/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/others%E6%9D%82%E9%A1%B9/%E7%A6%BB%E6%95%A3%E5%8C%96/</guid><description>&lt;h1 id="离散化">离散化&lt;/h1>
&lt;p>&lt;del>好高深的鸭子&lt;/del>&lt;/p>
&lt;p>&lt;del>其实，用STL水就可以了&lt;/del>&lt;/p>
&lt;h2 id="离散化-1">离……散化？&lt;/h2>
&lt;p>离散化，就是把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。即在不改变数据相对大小的条件下，对数据进行相应的缩小。通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。&lt;/p>
&lt;p>&lt;del>好了，上面的多无聊&lt;/del>&lt;/p>
&lt;p>很简单，就是如果你只需要 $k$ 个数，但是可能存在 $n$ 种情况，你开不下下标为 $n$ 的数组，因此你丢出了离散化来解决这个问题。&lt;/p>
&lt;h2 id="所以实现">所以……实现？&lt;/h2>
&lt;p>如果你不嫌累的话，你大可以学习各种各样奇奇怪怪的离散化的方法(包括但不限于Hash、排序)。&lt;/p>
&lt;p>但是，这种非常常见的东西C++ STL里面肯定有啊。&lt;/p>
&lt;p>所以，介绍几个：&lt;/p>
&lt;h3 id="map">map&lt;/h3>
&lt;h3 id="heading">&lt;/h3></description></item><item><title>质数、合数、约数</title><link>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0%E5%90%88%E6%95%B0%E7%BA%A6%E6%95%B0%E5%80%8D%E6%95%B0/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0%E5%90%88%E6%95%B0%E7%BA%A6%E6%95%B0%E5%80%8D%E6%95%B0/</guid><description>&lt;h1 id="质数">质数&lt;/h1>
&lt;p>本标题下所有数 $x\in N^*$ 。&lt;/p>
&lt;h2 id="单个质数的判定">单个质数的判定&lt;/h2>
&lt;h3 id="思想">思想&lt;/h3>
&lt;p>枚举 $i\in{{1\sim\sqrt{P}}}$​​ ，判断$P\mod{i}$​​​​是否为$0$​即可。&lt;/p>
&lt;p>若数 $P=p_1*p_2$​ 并且 $p_2&amp;gt;\sqrt{P}$​ ​​，则 $p_1&amp;lt;\sqrt{P}$​ ,所以只需要枚举 $i$​ 到 $i&amp;lt;=\sqrt{P}$​ 。&lt;/p>
&lt;h3 id="代码">代码&lt;/h3>
&lt;pre>&lt;code class="language-c++">bool prime(int n)
{
int len = sqrt(n);//求i的遍历范围
for (int i = 2; i &amp;lt;= len; i++)
if (!(n % i))//如果i是n的约数，说明n不是质数，返回false
return false;
return true;//n除了1和n以外没有别的约数，证明n是质数，返回true
}
&lt;/code>&lt;/pre>
&lt;p>时间复杂度 $O(\sqrt{n})$。&lt;/p>
&lt;h2 id="单个数分解质因数">单个数分解质因数&lt;/h2>
&lt;p>想法和上面的一样，只不过找到一个因数就循环除他罢辽。&lt;/p>
&lt;pre>&lt;code class="language-c++">list&amp;lt;int&amp;gt; prime(int n)
{
list&amp;lt;int&amp;gt; result;
int len = sqrt(n); //求i的遍历范围
for (int i = 2; i &amp;lt;= len; i++)
{
if (N % i == 0)
{ // 如果 i 能够整除 N，说明 i 为 N 的一个质因子。
while (N % i == 0)
N /= i;
result.push_back(i);
}
}
if (N != 1)
{ // 说明再经过操作之后 N 留下了一个素数
result.push_back(N)
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="范围内所有质数的判定">范围内所有质数的判定&lt;/h2>
&lt;h3 id="纯暴力">纯暴力&lt;/h3>
&lt;p>就把上面那个套个循环，复杂度 $O(n\sqrt n)$。&lt;/p>
&lt;h3 id="埃氏筛">埃氏筛&lt;/h3>
&lt;p>从 $2$ 开始，不断寻找没有被标记的，并把它的倍数全部标记，复杂度 $O(n\log\log n)$。&lt;/p>
&lt;p>但是，我们注意到，某一些合数被标记了不止一次，因此仍有优化空间。&lt;/p>
&lt;h3 id="欧拉筛">欧拉筛&lt;/h3></description></item><item><title>分治（二分）</title><link>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%88%86%E6%B2%BB/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%88%86%E6%B2%BB/</guid><description>&lt;h2 id="二分查找">二分查找&lt;/h2>
&lt;h2 id="二分答案">二分答案&lt;/h2></description></item><item><title>线性dp</title><link>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7dp/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7dp/</guid><description>&lt;h1 id="线性dp">线性dp&lt;/h1>
&lt;h2 id="最基本的dp和dp简介">最基本的dp和dp简介&lt;/h2>
&lt;h3 id="一种优美的暴力">一种优美的暴力&lt;/h3>
&lt;p>动态规划可以看做在&lt;strong>最优化问题&lt;/strong>和&lt;strong>计数问题&lt;/strong>中对暴力搜索的优化。&lt;/p>
&lt;p>在暴力搜索中，我们要枚举&lt;strong>每一步&lt;/strong>决策，枚举所有的方案。&lt;/p>
&lt;p>但在多数问题中，暴力搜索其实会做大量重复工作，重复计算大量中间结果。&lt;/p>
&lt;p>动态规划就是把这些中间结果用dp数组记录下来，以便后续利用。&lt;/p>
&lt;p>最基本的状态和转移方程的设计比较容易，在NOIP题目中一般占分 $30\sim60$。&lt;/p>
&lt;p>最基本的方程的设计并没有特别的技巧。一般来说，&lt;/p>
&lt;ul>
&lt;li>动态规划问题的“三大要素”：&lt;strong>状态、转移、边界&lt;/strong>。&lt;/li>
&lt;li>题目中给的条件都可以加入状态中，题目要求最优化的值就是DP值。&lt;/li>
&lt;li>转移方程往往根据最后一步决策来设计。&lt;/li>
&lt;/ul>
&lt;h3 id="线性dp-1">线性dp&lt;/h3>
&lt;p>状态均沿&lt;strong>一个方向&lt;/strong>转移的dp。&lt;/p>
&lt;p>例如最基本的模型——&lt;a href="https://www.luogu.com.cn/problem/P1216" target="_blank" rel="noopener">数字三角形&lt;/a>和&lt;a href="http://noi.openjudge.cn/ch0206/1759/" target="_blank" rel="noopener">最长上升子序列(LIS)&lt;/a>都属于线性dp。&lt;/p>
&lt;p>[洛谷P1216 [USACO1.5][IOI1994] 数字三角形 Number Triangles](&lt;a href="https://www.luogu.com.cn/problem/P1216" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1216&lt;/a>)&lt;/p>
&lt;p>$dp[i][j]$表示以第 $i$ 行第 $j$ 列为终点的最大数字和，转移方程为 $dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+val[i][j]$。&lt;/p>
&lt;p>&lt;a href="http://noi.openjudge.cn/ch0206/1759/" target="_blank" rel="noopener">Openjudge 2.6 1759 最长上升子序列&lt;/a>&lt;/p>
&lt;p>一会儿详细的说。&lt;/p>
&lt;h2 id="几种优化的方式">几种优化的方式&lt;/h2>
&lt;p>因为dp要对于题目而设计转移方程，因此有一些优化方式仅能用例题去表示。&lt;/p>
&lt;p>但是，强烈建议能想到dp的题先搞出来最基本的，然后再优化，便于对拍和防止暴零。&lt;/p>
&lt;h3 id="无优化">无优化&lt;/h3>
&lt;p>以LIS为例子。&lt;/p>
&lt;p>求最长上升子序列和最长不降子序列(注意，是子序列以及不降表示可以相等;对于固定的数组，虽然LIS序列不一定唯一，但LIS的长度是唯一的)。&lt;/p>
&lt;p>我们用 $dp[i]$ 表示以第 $i$ 位结尾的LIS长度。&lt;/p>
&lt;p>转移时每次都向前找比它小的数和比它大的数的位置，将第一个比它大的替换掉。这样操作虽然LIS序列的具体数字可能会变，但是很明显LIS长度还是不变的，因为只是把数替换掉了，并没有改变增加或者减少长度。&lt;/p>
&lt;p>因此，转移方程为：&lt;/p>
&lt;pre>&lt;code class="language-c++">if (num[i - 1] &amp;lt; num[i])
dp[i] = dp[i - 1] + 1;
else
{
int big = 2e9, ji = -1;
for (int j = 1; j &amp;lt; i; j++)
{
if (num[j] &amp;lt; big &amp;amp;&amp;amp; num[j] &amp;gt;= num[i])
{
big = num[j];
ji = j;
}
}
dp[i] = ji == -1 ? 1 : dp[ji];
}
&lt;/code>&lt;/pre>
&lt;p>&lt;del>比较复杂&lt;/del>&lt;/p>
&lt;h3 id="减少多余状态">减少多余状态&lt;/h3>
&lt;p>打一个恰当的比方，当你的 $dp$ 状态有$4$个，但是其中一个可以由剩下的$3$个推算得来，则这个状态就可以省略(优化掉)。&lt;/p>
&lt;h3 id="改变状态设计">改变状态设计&lt;/h3>
&lt;p>通俗一点，就是换一个dp的思路。&lt;/p>
&lt;h3 id="前后缀和优化dp">前（后）缀和优化DP&lt;/h3>
&lt;h2 id="背包问题">背包问题&lt;/h2>
&lt;p>&lt;a href="./%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98.md">背包问题&lt;/a>是一类特殊的线性DP问题。其模型应用极为广泛，故单独叙述。&lt;/p></description></item><item><title>队列</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</guid><description/></item><item><title>差分数组</title><link>https://xuxihe.vercel.app/notes/oiknowledge/others%E6%9D%82%E9%A1%B9/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/others%E6%9D%82%E9%A1%B9/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</guid><description>&lt;h1 id="差分数组">差分数组&lt;/h1>
&lt;h2 id="定义">定义&lt;/h2>
&lt;p>对于第$i$位，记录第$i$位减第$i-1$位的差值。&lt;/p>
&lt;p>例子：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">下标&lt;/th>
&lt;th style="text-align:center">0&lt;/th>
&lt;th style="text-align:center">1&lt;/th>
&lt;th style="text-align:center">2&lt;/th>
&lt;th style="text-align:center">3&lt;/th>
&lt;th style="text-align:center">4&lt;/th>
&lt;th style="text-align:center">5&lt;/th>
&lt;th style="text-align:center">6&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;strong>原数组&lt;/strong>&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">6&lt;/td>
&lt;td style="text-align:center">9&lt;/td>
&lt;td style="text-align:center">5&lt;/td>
&lt;td style="text-align:center">4&lt;/td>
&lt;td style="text-align:center">7&lt;/td>
&lt;td style="text-align:center">3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;strong>差分数组&lt;/strong>&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">+6&lt;/td>
&lt;td style="text-align:center">+3&lt;/td>
&lt;td style="text-align:center">-4&lt;/td>
&lt;td style="text-align:center">-1&lt;/td>
&lt;td style="text-align:center">+3&lt;/td>
&lt;td style="text-align:center">-4&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="用途">用途&lt;/h2>
&lt;p>快速进行区间修改操作。&lt;/p>
&lt;p>&lt;strong>注意!&lt;/strong> 只适用于可被抵消贡献的运算中，如$+/-/\and$​(加、减、异或)等。&lt;/p>
&lt;p>若将原数组$[l,r]$区间内加$val$，则相当于将差分数组第$l$位加$val$，第$r+1$位减去$val$(将贡献抵消)。&lt;/p>
&lt;h6 id="注意-是第r1位而不是第r位">&lt;strong>注意! 是第$r+1$位，而不是第$r$​位!!!&lt;/strong>&lt;/h6>
&lt;p>经常和维和区间和的数据结构一起使用。(&lt;a href="../data%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84.md">树状数组&lt;/a>等)&lt;/p></description></item><item><title>最小生成树</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid><description>&lt;h1 id="最小生成树">最小生成树&lt;/h1>
&lt;h2 id="问题描述">问题描述&lt;/h2>
&lt;p>给出一个有$n$个节点，$m$条边的无向图，从中选取边权之和最小(大)的$n-1$条边，使得图上任意两个顶点有且只有唯一的一条路径可以互相到达。&lt;/p>
&lt;h2 id="例子">例子&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.png" alt="最小生成树" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;img src="%E6%97%A0%E5%90%91%E5%9B%BE.svg" alt="无向图" style="zoom:80%;" />&lt;/p>
&lt;p>如上图，其最小生成树为： &lt;strong>红色部分&lt;/strong> 和 &lt;img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.dot.svg" alt="最小生成树" style="zoom:80%;" />&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong> 最小生成树可能不唯一(边权相等)&lt;/p>
&lt;h2 id="暴力">暴力&lt;/h2>
&lt;p>枚举每一种可能的情况，计算最小值(因复杂度过高，不再赘述)。&lt;/p>
&lt;h2 id="prim算法">Prim算法&lt;/h2>
&lt;p>时间复杂度：$O(nm)\sim O(m\log{n})$​ &lt;em>数据结构优化&lt;/em>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_42657313/article/details/103326019?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162729943216780366585099%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=162729943216780366585099&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-6-103326019.first_rank_v2_pc_rank_v29&amp;amp;utm_term=prim%E7%AE%97%E6%B3%95&amp;amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">一篇比较详细的博文&lt;/a>&lt;/p>
&lt;p>以&lt;strong>点&lt;/strong>为核心，每次选择当前&lt;strong>已选中&lt;/strong>的点连接&lt;strong>未选中&lt;/strong>的点的边中&lt;strong>权值最小&lt;/strong>的一个，将这个点加入&lt;strong>已选中&lt;/strong>的点集，并用和这个点连接的边更新&lt;strong>未选中&lt;/strong>的点的距离。&lt;/p>
&lt;h3 id="例子-1">例子&lt;/h3>
&lt;img src="20191130162837932.png" alt="Prim1" style="zoom: 150%;" />
&lt;img src="20191130162907364.png" alt="Prim2" style="zoom: 200%;" />
&lt;p>&lt;del>盗图很开心&lt;/del>&lt;/p>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3366" target="_blank" rel="noopener">洛谷P3366&lt;/a> &lt;del>其实就是板子&lt;/del>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
const int maxe = 6000; //n的最大值
int n, m, head[maxe], cnt;
//n个点,m条边,head[i]表示已i为端点最后读入的一条边的编号,已经读入cnt条边
bool vis[maxe]; //vis[i]标记i节点是否在最小生成树点集中
struct node
{
int value, last, sign; //value表示边权,last表示同一起点的上一条读入的边的编号,sign表示当前节点编号
} edge[400009];
//m最大值*2
inline void add_edge(int start, int end, int value) //链式前向星
{
edge[++cnt].value = value;
edge[cnt].sign = end;
edge[cnt].last = head[start];
head[start] = cnt;
return;
}
inline int prim()
{
int dis[maxe], ans = -1e9;
//dis[i]表示连接未加入点集的i号节点和点集中任意点最短路径长,ans = -1e9抵消选择第一个点溢出
for (int i = 1; i &amp;lt;= n; i++)
{
dis[i] = 2e9; //初始化dis数组
}
int k = 1, min; //k记录所选择的点的编号,min记录最小值,k初始值为第一个加入点集的点的编号
vis[1] = 1; //将第一个点加入点集
for (int i = 0; i &amp;lt; n; i++) //循环n次,将所有点加入点集
{
min = 1e9; //别忘了qwq,注意小于dis初始者,判断是否无法建树
for (int j = 1; j &amp;lt;= n; j++) //暴力搜索最小点,可用堆/平衡树(优先队列、set等)优化
{
if (!vis[j] &amp;amp;&amp;amp; dis[j] &amp;lt; min)
{
min = dis[j];
k = j;
}
}
if (min == 1e9 &amp;amp;&amp;amp; k != 1) //除第一个点外,如果没有未加入点集的点有连接且点集中小于n个点,证明有点无法连同
{
return 0;
}
ans += min;
vis[k] = 1;
for (int i = head[k]; i; i = edge[i].last) //用新加入的点更新dis数组
{
if (!vis[edge[i].sign] &amp;amp;&amp;amp; dis[edge[i].sign] &amp;gt; edge[i].value)
{
dis[edge[i].sign] = edge[i].value;
}
}
}
return ans;
}
int main()
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, value;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;value);
add_edge(a, b, value); //无向边,任意端点可作为起止点
add_edge(b, a, value);
}
int ans = prim();
if (ans)
printf(&amp;quot;%d&amp;quot;, ans);
else
printf(&amp;quot;orz&amp;quot;);//无法连同所有点
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="kruskal算法">Kruskal算法&lt;/h2>
&lt;p>时间复杂度： $O(m\log{m})$&lt;/p>
&lt;p>想法比较简单、易懂。&lt;/p>
&lt;p>将所有边&lt;strong>按权值&lt;/strong>从小到大排序，优先选取&lt;strong>权值较小&lt;/strong>的边，判断两个端点是否在&lt;strong>同一个集合&lt;/strong>中。如果在同一集合中，则&lt;strong>跳过&lt;/strong>这条边，遍历下一条；如果不再同一集合中，则将ans加上边权并将&lt;strong>两个点所在的集合合并&lt;/strong>。&lt;/p>
&lt;p>涉及到判断两个点是否在同一集合中，需要引入&lt;a href="https://xuxihe.vercel.app/oiblogs/data%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e5%b9%b6%e6%9f%a5%e9%9b%86/">并查集&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3366" target="_blank" rel="noopener">洛谷P3366&lt;/a> &lt;del>其实就是板子&lt;/del>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
int n, m, fa[6000], ans, cnt; //n个节点,m条边,已经选择cnt条边
struct edge
{
int a, b, value;
} edges[200009]; //有一条端点是a和b,权重为value的边
inline bool cmp(edge a, edge b) //比较函数
{
return a.value &amp;lt; b.value;
}
inline int find(int x) //并查集
{
return fa[x] == x ? x : fa[x] = find(fa[x]);
}
inline void together(int x, int y)
{
x = find(x);
y = find(y);
fa[x] = y;
}
int main()
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
for (int i = 1; i &amp;lt;= n; i++)
{
fa[i] = i;
}
for (int i = 0; i &amp;lt; m; i++)
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;edges[i].a, &amp;amp;edges[i].b, &amp;amp;edges[i].value);
}
std::sort(edges, edges + m, cmp); //按边权排序
for (int i = 0; i &amp;lt; m; i++)
{
if (find(edges[i].a) != find(edges[i].b)) //如果两个端点不再同一集合
{
ans += edges[i].value; //选中这条边
cnt++;
together(edges[i].a, edges[i].b); //合并两个集合
}
if (cnt == n) //最小生成树边数等于总节点数-1
break;
}
if (cnt == n - 1) //最小生成树边数等于总节点数-1
printf(&amp;quot;%d&amp;quot;, ans);
else
printf(&amp;quot;orz&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>两种算法均用到&lt;a href="https://xuxihe.vercel.app/oiblogs/basic%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3/%e8%b4%aa%e5%bf%83/">贪心&lt;/a>的思想。&lt;/p>
&lt;p>Prim侧重于点，适合稠密图；Kruskal侧重于边，适合稀疏图；但二者优化后差距并不大，推荐Kruskal，易理解不费手还不容易出奇奇怪怪的问题。&lt;del>(复杂度中可以看出)&lt;/del>&lt;/p></description></item><item><title>KMP</title><link>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/kmp/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/kmp/</guid><description>&lt;h1 id="kmp">KMP&lt;/h1>
&lt;h2 id="入门第一发">入门第一发&lt;/h2>
&lt;p>相信，很多人入门的第一个算法(除去贪心等基本思想)，所以，先来略略领会一下dp的奥妙和人类的脑洞叭。&lt;/p>
&lt;h3 id="字符串匹配问题">字符串匹配问题：&lt;/h3>
&lt;p>一类在一个字符串中查找其他字符串出现情况的问题。称被匹配的串为&lt;strong>主串&lt;/strong>；称在主串中寻找匹配位置的串为&lt;strong>模式串&lt;/strong>。&lt;/p>
&lt;p>其按模式串个数分为&lt;strong>单模&lt;/strong>匹配和&lt;strong>多模&lt;/strong>匹配问题。而KMP是一种利用 LBorder 来高效解决单模匹配的算法。&lt;/p>
&lt;p>&lt;strong>单模匹配问题&lt;/strong>：给定两个串 $n$ 和 $m$ ，求 $m$在 $n$ 中出现的所有位置。&lt;/p>
&lt;p>字符串 $s$ 的公共前后缀（即：$s[i]=s[len-i]$）称作Border。空串与原串也是 Border。&lt;/p>
&lt;p>&lt;strong>非原串&lt;/strong>的最长的 Border 称作 &lt;strong>LBorder&lt;/strong> (Longest Border)。&lt;/p>
&lt;p>LBorder 的性质使得 KMP 算法在匹配失败时能够直接按 LBorder 将主串与模式串重新对齐并继续尝试匹配，从而有效避免了暴力做法中盲目试错的过程。&lt;/p>
&lt;h2 id="预处理">预处理&lt;/h2>
&lt;p>为模式串建立 $next$ 数组，$next[i]$ 表示当模式串匹配到第 $i$ 位失配时应该从哪一位开始匹配。&lt;/p>
&lt;p>注意，$next[0]$ 和 $next[1]$ 不存在Border(一共长度没有 $2$，上哪来的两个子串？)，因此根据其意义规定为 $next[0]=next[1]=0$，在这两位失配时均从头开始匹配。&lt;/p>
&lt;p>而构建 $next$ 数组，运用了一点dp的思想，即尽可能的使用现有的去推导已知的。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="kmp" srcset="
/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/kmp/KMP_huee9227d8f766b824f535546b7eb39deb_6764_1d4e52a038b05963acd7ba2588ad6993.png 400w,
/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/kmp/KMP_huee9227d8f766b824f535546b7eb39deb_6764_095f616770fbd084713d6a9bf8122c8c.png 760w,
/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/kmp/KMP_huee9227d8f766b824f535546b7eb39deb_6764_1200x1200_fit_lanczos_3.png 1200w"
src="https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/kmp/KMP_huee9227d8f766b824f535546b7eb39deb_6764_1d4e52a038b05963acd7ba2588ad6993.png"
width="760"
height="77"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>上图演示：当我们求 $next[j+1]$ 时，已经知道 $next[0]\sim next[j]$ 的值。&lt;/p>
&lt;ol>
&lt;li>首先，我们判断 $j+1=k$，若成立则 $next[j+1]=next[j]+1$ 并退出，若不成立执行第 $2$ 步。&lt;/li>
&lt;li>再次判断 $j+1=h$，若成立则 $next[j+1]=next[k]+1$ 并退出，若不成立执行第 $3$ 步。&lt;/li>
&lt;li>接着判断……&lt;/li>
&lt;/ol>
&lt;p>那么，问题来了，问什么我们这样做是对的呢？&lt;del>(这题我A了，但是为什么？)&lt;/del>&lt;/p>
&lt;p>看上图，方块表示对应位置的字符，每条颜色对应的横线是相等的子串(其实就是之前求出的LBonder)。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>因为 $A_1=A_2$，因此 $next[j]=k$。如果 $j=k$，则 $next[j+1]$ 应该指向 $k+1$ 位(LBonder的长度为 $A_1+第k位$)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若上面的没匹配到，则因为 $A_1=A_2\space&amp;amp;\space b_1=b_2$，我们可以推导出 $b_1=b_3$，这样，我们又重复了上面的那个问题，所以一样的方法再做一遍即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们推导可知， $c_1=c_2=c_3=c_4$，所以继续……&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>下面，我们上代码！&lt;/p>
&lt;p>因为通常起始位置可能是下标 $0$ 或者是下标 $1$，构建的时候可以目标第 $j$ 位或者第 $j+1$ 位；因此，经过组合数的计算，我们一共有 $4$ 种代码。&lt;/p>
&lt;p>从 $0$ 开始目标 $j$ 位：&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void get_next(char *in, int *next)
{
int len = strlen(in);
next[0] = next[1] = 0;
for (int i = 2; i &amp;lt;= len; i++)
{
int now = next[i - 1];
while (now &amp;amp;&amp;amp; in[now] != in[i - 1])
now = next[now];
next[i] = in[i - 1] == in[now] ? now + 1 : 0;
}
}
&lt;/code>&lt;/pre>
&lt;p>从 $0$ 开始目标 $j+1$ 位 ：&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void get_next(char *in, int *next)
{
int len = strlen(in);
next[0] = next[1] = 0;
for (int i = 1; i &amp;lt; len; i++)
{
int now = next[i];
while (now &amp;amp;&amp;amp; in[now] != in[i])
now = next[now];
next[i + 1] = in[i] == in[now] ? now + 1 : 0;
}
}
&lt;/code>&lt;/pre>
&lt;p>从 $1$ 开始目标 $j$ 位：&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void get_next(char *in, int *next)
{
int len = strlen(in);
next[1] = next[2] = 1;
for (int i = 3; i &amp;lt;= len; i++)
{
int now = next[i - 1];
while (now &amp;gt; 1 &amp;amp;&amp;amp; in[now] != in[i - 1])
now = next[now];
next[i] = in[i - 1] == in[now] ? now + 1 : 1;
}
}
&lt;/code>&lt;/pre>
&lt;p>从 $1$ 开始目标 $j+1$ 位：&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void get_next(char *in, int *next)
{
int len = strlen(in);
next[1] = next[2] = 1;
for (int i = 2; i &amp;lt; len; i++)
{
int now = next[i];
while (now &amp;gt; 1 &amp;amp;&amp;amp; in[now] != in[i])
now = next[now];
next[i + 1] = in[i] == in[now] ? now + 1 : 1;
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="开始匹配">开始匹配&lt;/h2>
&lt;p>而接下来的匹配就很好搞了，只要一失配就跳next即可。这样，可以做到主串的 $i$ 不会退，提高了效率。&lt;/p>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3375" target="_blank" rel="noopener">洛谷 P3375 【模板】KMP字符串匹配&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
const int maxe = 1e6 + 9;
char a[maxe], b[maxe];
int nxt[maxe], na, nb;
inline void get_next(char *in, int *next)
{
int len = strlen(in);
next[0] = next[1] = 0;
for (int i = 2; i &amp;lt;= len; i++)
{
int now = next[i - 1];
while (now &amp;amp;&amp;amp; in[now] != in[i - 1])
now = next[now];
next[i] = in[i - 1] == in[now] ? now + 1 : 0;
}
}
int main()
{
scanf(&amp;quot;%s%s&amp;quot;, a, b);
na = strlen(a);
nb = strlen(b);
get_next(b, nxt);
for (int i = 0, j = 0; i &amp;lt; na; i++)
{
while (j &amp;amp;&amp;amp; b[j] != a[i]) //不断失配跳转
{
j = nxt[j];
}
if (b[j] == a[i])
j++;
if (j == nb)
{
printf(&amp;quot;%d\n&amp;quot;, i - j + 2);
}
}
for (int i = 1; i &amp;lt;= nb; i++)
{
printf(&amp;quot;%d &amp;quot;, nxt[i]);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="字符串最小循环节">字符串最小循环节&lt;/h2>
&lt;p>&lt;strong>证明：字符串最小循环节 = 字符串长度 - LBonder(尾部next数组)&lt;/strong>&lt;/p>
&lt;p>假设字符串 $a$ 是其子串 $b$ 循环 $k$ 次在加一个 $b$ 的前缀 $d$ 得到，$a$ 串的LBonder长 $x$，则我们思考一个问题：&lt;/p>
&lt;p>前 $k-1$ 个 $b$ 加一个 $d$ 等于后 $k-1$ 个 $b$ 加一个 $d$。举个栗子：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">&lt;strong>a&lt;/strong>&lt;/th>
&lt;th style="text-align:center">a&lt;/th>
&lt;th style="text-align:center">b&lt;/th>
&lt;th style="text-align:center">c&lt;/th>
&lt;th style="text-align:center">a&lt;/th>
&lt;th style="text-align:center">b&lt;/th>
&lt;th style="text-align:center">c&lt;/th>
&lt;th style="text-align:center">a&lt;/th>
&lt;th style="text-align:center">b&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;strong>b&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>a&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>b&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>c&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;strong>前&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>a&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>b&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>c&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>a&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>b&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;strong>后&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;strong>a&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>b&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>c&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>a&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>b&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>我们发现，前 $k-1$ 个 $b$ 加一个 $d$ 等于后 $k-1$ 个 $b$ 加一个 $d$ 等于 LBonder！&lt;/p>
&lt;p>所以，$b$ 的长度就是(看上表) $a$ 串的长度 - 后 $k-1$ 个 $b$ 加一个 $d$ 的长度 = $a$ 的最小循环节&lt;/p>
&lt;p>所以，字符串最小循环节 = 字符串长度 - LBonder(尾部next数组)。&lt;/p></description></item><item><title>分块</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%86%E5%9D%97/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%86%E5%9D%97/</guid><description/></item><item><title>贪心</title><link>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E8%B4%AA%E5%BF%83/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E8%B4%AA%E5%BF%83/</guid><description/></item><item><title>位运算</title><link>https://xuxihe.vercel.app/notes/oiknowledge/others%E6%9D%82%E9%A1%B9/%E4%BD%8D%E8%BF%90%E7%AE%97/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/others%E6%9D%82%E9%A1%B9/%E4%BD%8D%E8%BF%90%E7%AE%97/</guid><description>&lt;h1 id="位运算">位运算&lt;/h1>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>现代计算机中所有的数据均以二进制的形式存储在设备中，即 $0$、$1$ 两种状态计。计算机对二进制数据进行的运算( $+$、$-$、$*$、$/$ )都是位运算，即将符号位共同参与运算的运算。由于计算机内部就是以二进制来存储数据，位运算是相当快的。&lt;/p>
&lt;p>基本的位运算共 $6$ 种，分别为按位与、按位或、按位异或、按位取反、左移和右移。通俗叫法会去掉“按位”，即与、或、异或、取反、左移和右移。&lt;/p>
&lt;p>其中，按位与、按位或、按位异或是将&lt;strong>两个整数&lt;/strong>作为二进制数，对二进制表示中的每一位逐一运算；按位取反、左移和右移是对于某&lt;strong>一个整数&lt;/strong>作为二进制数，对二进制表示中的每一位逐一运算。&lt;/p>
&lt;p>在位运算时，若两个整数的二进制位数不同，则在位数较少的前面补 $0$ 即可。&lt;/p>
&lt;h2 id="整数二进制表">整数二进制表&lt;/h2>
&lt;p>这是一张 $0\sim31$ 的 $十进制\longleftrightarrow二进制$ 对照表。&lt;/p>
&lt;p>二进制这个东西可以手推，但是比较麻烦，这张表在位运算的学习和实际应用中很方便比较并找到规律。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>十进制&lt;/th>
&lt;th>二进制&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>00000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>00001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>00010&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>00011&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>00100&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>00101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>00110&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>00111&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>01000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9&lt;/td>
&lt;td>01001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10&lt;/td>
&lt;td>01010&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>11&lt;/td>
&lt;td>01011&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12&lt;/td>
&lt;td>01100&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>13&lt;/td>
&lt;td>01101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>14&lt;/td>
&lt;td>01110&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>15&lt;/td>
&lt;td>01111&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16&lt;/td>
&lt;td>10000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>17&lt;/td>
&lt;td>10001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>18&lt;/td>
&lt;td>10010&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>19&lt;/td>
&lt;td>10011&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>20&lt;/td>
&lt;td>10100&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>21&lt;/td>
&lt;td>10101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>22&lt;/td>
&lt;td>10110&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>23&lt;/td>
&lt;td>10111&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>24&lt;/td>
&lt;td>11000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>25&lt;/td>
&lt;td>11001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>26&lt;/td>
&lt;td>11010&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>27&lt;/td>
&lt;td>11011&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>28&lt;/td>
&lt;td>11100&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>29&lt;/td>
&lt;td>11101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>30&lt;/td>
&lt;td>11110&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>31&lt;/td>
&lt;td>11111&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="与">与&lt;/h2>
&lt;p>“与”，就是和的意思。定义如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">C++运算符&lt;/th>
&lt;th style="text-align:center">数学符号&lt;/th>
&lt;th style="text-align:center">意义(咋算的)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&amp;amp;&lt;/td>
&lt;td style="text-align:center">$&amp;amp;\space、\operatorname{and}$&lt;/td>
&lt;td style="text-align:center">均为 $1$，则结果为 $1$；任意一个是 $0$，结果为 $0$。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>其对应的结果如下表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数A第 $i$ 位&lt;/th>
&lt;th>数B第 $i$ 位&lt;/th>
&lt;th>结果&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$1$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$1$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="lowbit">lowbit&lt;/h3>
&lt;p>正确的使用&lt;strong>与&lt;/strong>运算(再加上一点技巧)，可以求出某一个数二进制下最低位的 $1$ 的位置。详情请参见&lt;a href="../data%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84.md">树状数组&lt;/a>。&lt;/p>
&lt;h2 id="或">或&lt;/h2>
&lt;p>“或”，即或者。定义：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">C++运算符&lt;/th>
&lt;th style="text-align:center">数学符号&lt;/th>
&lt;th style="text-align:center">意义(咋算的)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">|&lt;/td>
&lt;td style="text-align:center">$\mid\space、\operatorname{or}$&lt;/td>
&lt;td style="text-align:center">均为 $0$，则结果为 $0$；任意一个是 $1$，结果为 $1$。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>其对应的结果如下表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数A第 $i$ 位&lt;/th>
&lt;th>数B第 $i$ 位&lt;/th>
&lt;th>结果&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$1$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$1$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="异或">异或&lt;/h2>
&lt;p>&lt;del>“异或”，大概就是变异的“或”吧。&lt;/del>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">C++运算符&lt;/th>
&lt;th style="text-align:center">数学符号&lt;/th>
&lt;th style="text-align:center">意义(咋算的)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">^&lt;/td>
&lt;td style="text-align:center">$\oplus\space、\operatorname{xor}$&lt;/td>
&lt;td style="text-align:center">均为 $0$ 或均为 $1$，结果为 $0$；两个不同(任意一个是 $1$，另一个是 $0$)，结果为 $1$。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>其对应的结果如下表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数A第 $i$ 位&lt;/th>
&lt;th>数B第 $i$ 位&lt;/th>
&lt;th>结果&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$1$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$1$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;td>$1$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$0$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;td>$0$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="异或与加法">异或与加法&lt;/h3>
&lt;p>一个定理：$a\oplus{b}\le{a+b}$&lt;/p>
&lt;p>&lt;strong>证明：&lt;/strong>&lt;/p>
&lt;p>我们发现，位运算不进位；而加法运算当两个位都是 $1$ 时会进位。因此，观察上表，异或运算的得数是加法运算进位后剩余的数字。&lt;/p>
&lt;p>因此，在加法不进位时，$a\oplus{b}={a+b}$；加法进位时，$a\oplus{b}&amp;lt;{a+b}$。&lt;/p>
&lt;h2 id="取反">取反&lt;/h2>
&lt;p>“取反”，顾名思义，就是 $0$ 变 $1$；&lt;/p>
&lt;h2 id="左移">左移&lt;/h2>
&lt;h2 id="右移">右移&lt;/h2></description></item><item><title>最短路径</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid><description>&lt;h1 id="最短路径">最短路径&lt;/h1>
&lt;h2 id="是个啥">是个啥&lt;/h2>
&lt;p>这种问题恰如其名，问如何走才能用最小的代价达到目的。&lt;del>(人生哲学)&lt;/del>&lt;/p>
&lt;p>给你一张有边权的图(无权图可看做所有边边权均为1；无向图可将所有边拆分成两条有向边)，求$i$节点到$j$​节点的最短路径。&lt;/p>
&lt;p>直接上算法。&lt;/p>
&lt;h2 id="dfs">DFS&lt;/h2>
&lt;p>&lt;em>BFS就涉及到其他算法了。&lt;/em>&lt;/p>
&lt;p>只能求解单源单尽~~(自创)~~最短路(固定起点和终点)并且通常情况下过于暴力。&lt;/p>
&lt;p>想法很简单，遍历两点之间的所有路径，选择最短的那条。&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
const int maxe = 1e4 + 9;
struct node
{
int next, val;
};
std::vector&amp;lt;node&amp;gt; edge[maxe];
int len, m, ans = 2e9, sta, end;
bool ji[maxe];
inline void dfs(int now, int val)
{
if (val &amp;gt;= ans || now == end) //结束条件和一点点剪枝
{
ans = ans &amp;gt; val ? val : ans;
return;
}
int n = edge[now].size();
ji[now] = 1; //记录访问过的节点,防止环
for (int i = 0; i &amp;lt; n; i++)
{
if (ji[edge[now][i].next]) //如果出现环,终止
continue;
dfs(edge[now][i].next, edge[now][i].val + val); //继续递归
}
ji[now] = 0; //访问归零
}
int main()
{
scanf(&amp;quot;%d%d%d%d&amp;quot;, &amp;amp;len, &amp;amp;m, &amp;amp;sta, &amp;amp;end);
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, v;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;v);
edge[a].push_back(node{b, v});
}
dfs(sta, 0);
printf(&amp;quot;%d&amp;quot;, ans);
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="floyd弗洛伊德算法">Floyd(弗洛伊德)算法&lt;/h2>
&lt;p>多源最短路(任意起止点)算法，时间复杂度 $O(n^3)$​，空间复杂度 $O(n^2)$​​。&lt;/p>
&lt;p>适用于具有正或负边缘权重，但**没有负周期(负环)**的加权图中。在稠密图中效率较高。&lt;/p>
&lt;p>运用dp思想，最开始只允许经过1号顶点进行中转，接下来只允许经过1号和2号顶点进行中转&amp;hellip;&amp;hellip;允许经过$1\sim n$​号所有顶点进行中转，来不断动态更新任意两点之间的最短路程。&lt;/p>
&lt;p>dp[i][j]表示从 $i$ 号节点到 $j$ 号节点的最短路径长度。&lt;/p>
&lt;ol>
&lt;li>首先构建邻接矩阵(存图)，假如现在只允许经过1号结点，求任意两点间的最短路程，很显然&lt;/li>
&lt;/ol>
&lt;p>$$
dp[i][j]=\min{dp[i][j],dp[i][1]+dp[1][j]}
$$&lt;/p>
&lt;ol start="2">
&lt;li>接下来继续求在只允许经过1和2号两个顶点的情况下任意两点之间的最短距离，在已经实现了从 $i$ 号顶点到 $j$ 号顶点只经过$1$号节点的最短路程的前提下，现在再插入第$2$号结点，来更新更短路径，故只需在步骤1求得的基础上求
$$
dp[i][j]=\min{dp[i][j],dp[i][2]+dp[2][j]}
$$&lt;/li>
&lt;li>$n$次更新后，表示依次插入了1号，2号&amp;hellip;&amp;hellip;n号结点，最后求得的dp[i][j]是从 $i$ 号顶点到 $j$​ 号顶点只经过前 $n$ 号点的最短路程。&lt;/li>
&lt;/ol>
&lt;p>如需要记录详细路径，可使用另外一个二维数组存贮中转节点。&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using std::min;
const int maxe = 3000, INF = 1000000009;
int n, m, dp[maxe][maxe], pot[maxe][maxe]; //如不需记录详细路径，不用pot
inline void pr_dis(int dp[maxe][maxe]) //最短路径输出
{
for (int i = 1; i &amp;lt;= n; i++)
{
for (int j = 1; j &amp;lt;= n; j++)
{
if (dp[i][j] == INF)
printf(&amp;quot;INF &amp;quot;);
else
printf(&amp;quot;%d &amp;quot;, dp[i][j]);
}
printf(&amp;quot;\n&amp;quot;);
}
}
inline void pr_way(int sta, int end) //递归重建路径
{
if (pot[sta][end] == 0) //若有边连接,则终止递归
return;
pr_way(sta, pot[sta][end]); //递归输出左侧
printf(&amp;quot;%d &amp;quot;, pot[sta][end]); //输出本位
pr_way(pot[sta][end], end); //递归输出右侧
}
int main()
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
int sta;
scanf(&amp;quot;%d&amp;quot;, &amp;amp;sta);
for (int i = 1; i &amp;lt;= n; i++) //初始化
{
for (int j = 1; j &amp;lt;= n; j++)
{
dp[i][j] = i == j ? 0 : INF;
}
}
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, v;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;v);
dp[a][b] = min(dp[a][b], v); //判断重边
}
for (int k = 1; k &amp;lt;= n; k++)
{
for (int i = 1; i &amp;lt;= n; i++)
{
for (int j = 1; j &amp;lt;= n; j++)
{
if (dp[i][j] &amp;gt; dp[i][k] + dp[k][j])
{
dp[i][j] = dp[i][k] + dp[k][j];
pot[i][j] = k; //更新节点记录
}
}
}
}
for (int i = 0; i &amp;lt; n; i++) //输出
{
for (int j = 0; j &amp;lt; n; j++)
{
printf(&amp;quot;\n%d %d : &amp;quot;, i + 1, j + 1);
pr_way(i + 1, j + 1);
}
}
printf(&amp;quot;\n\n&amp;quot;);
pr_dis(dp); //输出
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="dijkstra算法">Dijkstra算法&lt;/h2>
&lt;p>用于求解非负权图的单源最短路径。&lt;/p>
&lt;p>运用&lt;a href="https://xuxihe.vercel.app/oiblogs/basic%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3/%e8%b4%aa%e5%bf%83/">贪心&lt;/a>思想，时间复杂度 $O(n^2)$ 或优化后 $O(n\log{n})$，空间复杂度 运行空间 $O(n)$ 和存图 $O(m)$。&lt;/p>
&lt;p>用 $dis[i]$ 存贮从起始节点到第 $i$ 号节点的相对最短路径长度，并标记已经确定最短路径的顶点。&lt;/p>
&lt;ol>
&lt;li>初始化：设起始节点编号为 $k$，则 $dis[k]=0$，$i$ 与 $k$ 相连则 $dis[i]=边权$，其余的 $dis[j]=\infty$。&lt;/li>
&lt;li>松弛：在 $dis$ 数组中寻找未确定最短路径中 $dis[i]$ 最小，将 $i$ 加入已确定的顶点集合，并用其连接的边尝试使周围节点的 $dis$ 更小。(若存在负权，则有可能存在走负权边将以确定节点的最短路径变更小的可能，因此算法失效)&lt;/li>
&lt;/ol>
&lt;p>例子：&lt;/p>
&lt;img src="Dijkstra.jpg" alt="dijkstra" style="zoom: 70%;" />
&lt;p>&lt;strong>最暴力的code:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
const int maxe = 1e5 + 9, INF = 2147483647;
struct node //邻接链表存图
{
int next, val;
};
std::vector&amp;lt;node&amp;gt; edges[maxe];
int n, m, sta, dis[maxe];
bool ji[maxe]; //记录是否已经确定答案
inline int lowest() //查找未加入点集中最小的dis
{
int ans, lowt = INF;
for (int i = 1; i &amp;lt;= n; i++)
{
if (!ji[i] &amp;amp;&amp;amp; dis[i] &amp;lt; lowt)
{
lowt = dis[i];
ans = i;
}
}
return ans;
}
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;sta);
for (int i = 1; i &amp;lt;= n; i++) //初始化
{
dis[i] = INF;
}
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, v;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;v);
edges[a].push_back(node{b, v});
}
dis[sta] = 0; //自己倒自己为0
int now = sta; //当前要被加入点集的节点编号
for (int i = 1; i &amp;lt; n; i++)
{
ji[now] = 1; //表示已加入
int len = edges[now].size();
for (int j = 0; j &amp;lt; len; j++) //尝试松弛相连节点
{
if (dis[now] + edges[now][j].val &amp;lt; dis[edges[now][j].next])
dis[edges[now][j].next] = dis[now] + edges[now][j].val;
}
now = lowest(); //找到下一个加入点集的节点
}
for (int i = 1; i &amp;lt;= n; i++)
{
printf(&amp;quot;%d &amp;quot;, dis[i]);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>优化后code：&lt;/strong>&lt;/p>
&lt;p>用堆(优先队列)来找到dis最小的结点的复杂度为 $O(\log{n})$。&lt;/p>
&lt;p>当一个节点的dis从 $\infty$ 被更新到一个值时会被加入优先队列，若没有更改，则所有可能到达的点的最小dis都被加入优先队列。&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
const int maxe = 1e5 + 9, INF = 2147483647;
struct node //邻接链表存图
{
int next, val;
bool friend operator&amp;lt;(node a, node b)
{
return a.val &amp;gt; b.val;
}
};
std::vector&amp;lt;node&amp;gt; edges[maxe];
std::priority_queue&amp;lt;node&amp;gt; run;
int n, m, sta, dis[maxe];
bool ji[maxe]; //记录是否已经确定答案
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;sta);
for (int i = 1; i &amp;lt;= n; i++) //初始化
{
dis[i] = INF;
}
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, v;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;v);
edges[a].push_back(node{b, v});
}
dis[sta] = 0; //自己到自己为0
int now = sta; //当前要被加入点集的节点编号
for (int i = 1; i &amp;lt; n; i++)
{
ji[now] = 1; //表示已加入
int len = edges[now].size();
for (int j = 0; j &amp;lt; len; j++) //尝试松弛相连节点
{
if (dis[now] + edges[now][j].val &amp;lt; dis[edges[now][j].next])
{
dis[edges[now][j].next] = dis[now] + edges[now][j].val;
run.push(node{edges[now][j].next, dis[edges[now][j].next]}); //更新优先队列中的dis
}
}
while (!run.empty() &amp;amp;&amp;amp; ji[run.top().next]) //清空已加入点集的点
run.pop();
if(run.empty()) //防止不能连通出现死循环
break;
now = run.top().next;
}
for (int i = 1; i &amp;lt;= n; i++)
{
printf(&amp;quot;%d &amp;quot;, dis[i]);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="spfa算法">SPFA算法&lt;/h2>
&lt;p>Bellman-Ford算法的队列优化算法的别称。&lt;/p>
&lt;p>空间复杂度为 $O(n)$ 级别(不算图的存储)。&lt;/p>
&lt;p>在正常情况下(数据随机构造或出题人很善良)，期望的时间复杂度为 $O(km)\space,\space k&amp;lt;2$，但是如果你碰上一个很厉(e)害(xin)的出题人，存在针对性数据，能把你卡成 $O(nm)$​，直接 &lt;strong>T&lt;/strong> 飞！&lt;/p>
&lt;p>因此如果边权不为负的话，还是老老实实用Dijkstra叭。&lt;/p>
&lt;p>SPFA算法的实现有两种方式：&lt;/p>
&lt;ul>
&lt;li>DFS：在判定负环上优势明显，但求最短路即使各种优化，仍不及BFS。&lt;/li>
&lt;li>BFS：整体速度高于DFS，但应在仅需判断负环的题中弃用。&lt;/li>
&lt;/ul>
&lt;p>因此，应按照题目要求，选择对应的算法和方式。&lt;/p>
&lt;h3 id="bfs方式">BFS方式&lt;/h3>
&lt;p>最常见也是综合最优。&lt;/p>
&lt;ol>
&lt;li>初始化：将dis数组除起点外赋值为 $\infty$ ，起点dis为$0$​，将起点加入run队列。&lt;/li>
&lt;li>松弛：将队头弹出，并使用与其相连的边更新其他相连节点的dis值，若 $i$ 号节点的dis值被更新并且 $i$ 号节点不再run队列中，则将 $i$ 加入run的队尾。&lt;/li>
&lt;li>重复执行松弛操作，直到队列为空。&lt;/li>
&lt;/ol>
&lt;p>优化原理：因为并不是dis一更新就继续迭代，而是很可能dis被更新多次之后才再次迭代，因此比DFS更优。&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;
const int maxe = 1e5 + 9, INF = 2147483647;
int n, m, sta, dis[maxe];
//1
struct node //邻接链表存图
{
int next, val;
};
std::vector&amp;lt;node&amp;gt; edges[maxe];
std::queue&amp;lt;int&amp;gt; run;
bool in[maxe];
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;sta);
for (int i = 1; i &amp;lt;= n; i++) //初始化
{
dis[i] = INF;
}
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, v;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;v);
edges[a].push_back(node{b, v});
}
run.push(sta); //将起点加入队列
dis[sta] = 0;
while (!run.empty())
{
int now = run.front();
run.pop();
in[now] = 0; //使队列中没有now
int len = edges[now].size();
for (int i = 0; i &amp;lt; len; i++)
{
if (dis[edges[now][i].next] &amp;gt; dis[now] + edges[now][i].val) //松弛操作
{
dis[edges[now][i].next] = dis[now] + edges[now][i].val;
//2
if (!in[edges[now][i].next]) //如果队列中没有
{
run.push(edges[now][i].next); //加入队列并标记
in[edges[now][i].next] = 1;
}
}
}
}
for (int i = 1; i &amp;lt;= n; i++)
{
printf(&amp;quot;%d &amp;quot;, dis[i]);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h4 id="对于负环的判断">对于负环的判断&lt;/h4>
&lt;p>记录当前路径的最短路经过的边的数量，若边数大于总节点数，则说明一定有一条边被走了两次，证明有负环的存在。&lt;/p>
&lt;p>代码实现也很简单：&lt;/p>
&lt;pre>&lt;code class="language-c++">//在上面标号1的地方加入
int pass[maxe];
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-c++">//在上面标号2的地方加入
pass[edges[now][i].next] = pass[now] + 1;
if (pass[edges[now][i].next] &amp;gt; n)
{
printf(&amp;quot;orz&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>还有一种比较玄学的判负环方式，就是如果扩展了MAXN次还没出结果，就判定有负环。（MAXN为根据题目规模自拟的常量）&lt;/p>
&lt;p>原理简单易懂：跑了这么久还没出结果，当然是有负环咯~~NB的是经实测正确率还相当高！当然相当高还是牺牲了算法的正确性的，因此不到万不得已之时不建议使用(玄学你懂的)。&lt;/p>
&lt;h4 id="一些优化的方法">一些优化的方法&lt;/h4>
&lt;p>总体思想就是在你被出题人构造数据的情况下，如何能另辟蹊径，做出一些让出题人意想不到、另人捧腹大笑的sao操作，从而达到骗分的效果。&lt;/p>
&lt;ol>
&lt;li>简单的优化(只能让你的spfa跑的快一点，适用于常数大的同学。至于卡了spfa的题，仍旧没有什么用处。)
&lt;ol>
&lt;li>&lt;strong>SLF(Small Label First)优化：&lt;/strong> 在使用queue作为spfa的辅助数据结构时，将队列替换为双端队列，每当插入元素 $now$ 时，与队首进行比较，若 $dis[q.front()] &amp;gt; dis[now]$，将 $now$ 从队首插入，否则从队尾插入，使得更可能更新出节点最优解的节点最先进行更新，减少无用迭代次数。&lt;/li>
&lt;li>&lt;strong>LLL(Large Label Last）优化：&lt;/strong> 使用双端队列，维护目前队列中元素到起点的距离的平均值（即 $\sum^{tail}_{i=head}dis[edges[i]/n]$），设该数为 $k$，若 $dis[now] &amp;gt; k$，则从队尾插入，否则从队首插入，用处不大。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>升级的优化 (能过数据不刁钻的卡spfa的题，至于某些丧心病狂的出题人，拜拜了您嘞)
&lt;ol>
&lt;li>&lt;strong>容错后的SLF：&lt;/strong> 定义容错值 $val$，当满足 $dis[now] &amp;gt; dis[q.front()] + val$ 时从队尾插入，否则从队首插入，可以让程序不陷入局部最优解。&lt;/li>
&lt;li>&lt;strong>mcfx优化：&lt;/strong> 定义区间 $[l,r]$，当入队节点的入队次数属于这个区间的时候，从队首插入，否则从队尾插入，如过某个节点出发的大多数边都只能更新一个次解，那么它在队列中的优先级就会降低，防止链式结构卡死你。&lt;/li>
&lt;li>&lt;strong>Swap-SLF：&lt;/strong> 若队列改变且 $dis[q.front()] &amp;gt; dis[q.back()]$​​，交换队首队尾，比较玄学。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>玄学的优化(都是sao操作，能过多少看人品)
&lt;ol>
&lt;li>&lt;strong>边序随机：&lt;/strong> 将读入给你的边随机打乱后进行spfa&lt;/li>
&lt;li>&lt;strong>队列随机：&lt;/strong> 每个节点入队时，以 $\frac{1}{2}$ 的概率从队首入队，$\frac{1}{2}$​ 的概率从队尾入队。&lt;/li>
&lt;li>&lt;strong>队列随机优化版：&lt;/strong> 累计 $m$ 次入队后，将队列元素随机打乱。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="dfs方式">DFS方式&lt;/h3>
&lt;p>经过极其强大的优化后速度可能和BFS同级，但是在仅判断负环的问题中十分快。&lt;/p>
&lt;ol>
&lt;li>初始化：将dis数组除起点外赋值为 $\infty$ ，起点dis为$0$，将起点加入run队列。&lt;/li>
&lt;li>递归松弛：使用与当期节点相连的边更新其他相连节点的dis值，若 $i$ 号节点的dis值被更新，则对 $i$​ 号节点递归操作。&lt;/li>
&lt;li>重复递归，直到无法更新。&lt;/li>
&lt;/ol>
&lt;p>由于这种东西的实用性过低，不给出标程(实际上是懒得)。&lt;/p>
&lt;h4 id="关于优化">关于优化&lt;/h4>
&lt;p>&lt;a href="http://www.doc88.com/p-49816668344446.html" target="_blank" rel="noopener">姜碧野的《spfa算法的优化及应用》&lt;/a>十分详细且难以理解。&lt;/p>
&lt;h4 id="对于负环的判断-1">对于负环的判断&lt;/h4>
&lt;p>十分新奇，其实只需要记住结论即可。证明：&lt;a href="./SPFA-DFS%e8%b4%9f%e7%8e%af%e8%af%81%e6%98%8e.md">文档&lt;/a>&lt;/p>
&lt;p>结论即为：若存在负环，则&lt;strong>一定&lt;/strong>存在特定的至少一对终止点之间的不重叠顶点最短路径的边权从起点&lt;strong>依次&lt;/strong>相加&lt;strong>始终&lt;/strong>为负。&lt;/p>
&lt;p>所以，我们可以将dis数组初始值设为 $0$​，然后以每个节点为起点DFS，如果路径dis为正数就结束递归，这样相比于BFS方式可以忽略掉众多无用的边。&lt;/p>
&lt;p>但是，这种方法不能求最短路。&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;h2 id="最短路图">最短路图&lt;/h2>
&lt;p>对于只能在最短路径上操作且可能同时存在多条最短路的问题时，可以采用建最短路图的方法。&lt;/p>
&lt;p>将在 $i$ 和 $j$ 的最短路径上的边放入一个新的图当中，使得问题可以在一个DAG（有向无环图）上操作，因为最短路保证不出现环。&lt;/p>
&lt;p>最短路图的建立(有一点点dp的感jio)：&lt;/p>
&lt;p>首先，分别以 $i$ 和 $j$​ 跑一遍单源最短路(会用到)。&lt;/p>
&lt;p>首先，思考一个事情，如何判断一条边是否在最短路图中？&lt;/p>
&lt;p>当且仅当其满足 $dis_i[start]+val+dis_j[end]=dis_i[j]$ 时。&lt;/p>
&lt;p>翻译一下，就是从 $i$ 到边起点的最短路径长度加上路径的权值再加 $j$ 到路径终点的最短路径长度等于 $i$ 到 $j$​ 的最短路径长度，因为只有这样，才能保证最短路径长度不变，即一种可能的情况。&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;h2 id="分层图最短路">分层图最短路&lt;/h2>
&lt;p>用于求解一些有复杂决策的问题。&lt;/p>
&lt;p>在一个正常的图上可以进行 k 次决策，对于每次决策，不影响图的结构，只影响目前的状态或代价。一般将决策前的状态和决策后的状态之间连接一条权值为决策代价的边，表示付出该代价后就可以转换状态了。&lt;/p>
&lt;p>就是将每个点根据状态的不同拆成若干个点，用拆出来的所有点建立新图并跑最短路。&lt;/p>
&lt;p>一般有两种方案：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>建图时直接建成k+1层。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多开一维记录其余(决策)信息，但是对于多种决策用处不大。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>然后，在新建立的图中跑最短路。&lt;/p></description></item><item><title>倍增</title><link>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%80%8D%E5%A2%9E/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%80%8D%E5%A2%9E/</guid><description>&lt;h1 id="倍增">倍增&lt;/h1></description></item><item><title>区间dp</title><link>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4dp/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4dp/</guid><description>&lt;h1 id="区间dp">区间dp&lt;/h1>
&lt;p>顾名思义，就是在区间上进行dp。&lt;/p>
&lt;p>区间DP用于解决决策涉及到&lt;strong>相邻区间合并&lt;/strong>的问题。&lt;/p>
&lt;p>它的转移方向是由小区间向大区间转移，所以在转移的时候，要注意转移顺序。&lt;/p>
&lt;h2 id="经典例题一发">经典例题一发&lt;/h2>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P1880" target="_blank" rel="noopener">P1880 [NOI1995] 石子合并&lt;/a>&lt;/p>
&lt;p>先来看状态转移方程：
$$
dp[i][j]=max(dp[i][k]+dp[k+1][j])+\sum^j_inum[i]
$$
$dp[i][j]$ 表示以 $i$ 为起点，$j$ 为终点的区间合并成一堆所取到的最大。因为无论如何合并，本次合并所付出的代价相同，均为 $\sum^j_inum[i]$。&lt;/p>
&lt;p>所以，我们只需要考虑如何搞才能让合并前的两堆的代价之和最大即可。&lt;/p>
&lt;p>方法就是遍历中间点 $k$，表示两堆的分割点，也就遍历了所有可能的合并情况，从中取最优，这也正是区间dp的精华所在。&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;p>我们发现，跑完之后的dp数组中成三角形，这也正是区间dp区别于线性dp最显而易见的地方。&lt;/p>
&lt;h3 id="环">环&lt;/h3>
&lt;p>很多时候，题目中会给出“……连成一个环”。&lt;/p>
&lt;p>这似乎，又是一个很难很难的问题……&lt;/p>
&lt;p>不，聪明的人类总是有&lt;del>流氓&lt;/del>的做法。&lt;/p>
&lt;p>其实，就是把原来的数组在结尾在拼接一个一样的，但是最长的区间长度不变即可。(注意遍历时区间起止点的坐标范围和 $+1$ 问题)&lt;/p>
&lt;h2 id="几道题">几道题&lt;/h2>
&lt;p>莫得办法，dp这玩意只能用题去体会。&lt;/p></description></item><item><title>堆</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</guid><description/></item><item><title>SPFA-DFS负环证明</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/spfa-dfs%E8%B4%9F%E7%8E%AF%E8%AF%81%E6%98%8E/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/spfa-dfs%E8%B4%9F%E7%8E%AF%E8%AF%81%E6%98%8E/</guid><description>&lt;h1 id="spfa-dfs负环证明">SPFA-DFS负环证明&lt;/h1>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>让我们先来看结论：&lt;/p>
&lt;img src="graph.png" alt="spfa" style="zoom:60%;" />
&lt;p>如上图，明显可以看出 4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 8 -&amp;gt; 9 -&amp;gt; 10 -&amp;gt; 11 -&amp;gt; 12 -&amp;gt; 4 构成了一个负环。&lt;/p>
&lt;p>以任意节点为起点，用SPFA-DFS查找负环，则有：&lt;/p>
&lt;p>​ 若存在负环，则&lt;strong>一定&lt;/strong>存在特定的至少一对终止点之间的不重叠顶点最短路径的边权从起点&lt;strong>依次&lt;/strong>相加&lt;strong>始终&lt;/strong>为负。&lt;/p>
&lt;h2 id="正解">正解&lt;/h2>
&lt;p>我们只考虑在负环上的节点(因为我们只需证明这样的点对存在，非负权边节点情况过于复杂且并不影响答案的正确性，故忽略)。&lt;/p>
&lt;img src="%E8%B4%9F%E7%8E%AF.png" alt="fuhuan" style="zoom:67%;" />
&lt;p>我们对这个图重复进行如下操作：&lt;/p>
&lt;ol>
&lt;li>对于连续的正(负)权边进行合并，并删去权值为0的边，得到一个正负权边交替相连的图。
&lt;img src="1.png" alt="dsf" style="zoom:67%;" />&lt;/li>
&lt;li>对于一个正负权边交替相连的图，将一条负边 $i$​，$i$​ 的起止两个节点和 $i$​ 指向的正权边分为一组，求两个边权和并作为新边边权合并。新的边表示已 $i$​ 的起点为遍历起点，经过两条边之后的边权和。和为负，则说明可以走过这两条边；和为正，则说明不可以以其作为起点。
&lt;img src="2.png" style="zoom:67%;" />&lt;/li>
&lt;/ol>
&lt;p>第3步&lt;img src="3.png" alt="dfadf" style="zoom:67%;" />&lt;/p>
&lt;p>第4步&lt;img src="4.png" alt="adf" style="zoom:67%;" />&lt;/p>
&lt;p>直到图中仅剩下两个节点和两条边，这时，一定有两边之和小于0。(因为两边之和即为环上边权之和)&lt;/p>
&lt;p>因此，从这时负边的起点开始遍历原来的负环，保证边权依次相加为负。&lt;/p>
&lt;p>对于任意一条负边，表示从起始节点到终止节点所包含的边依次相加为负，边权为从起点走到终点后的边权和。我们每次选择的均为负边起点。&lt;/p></description></item><item><title>三分</title><link>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E4%B8%89%E5%88%86/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E4%B8%89%E5%88%86/</guid><description/></item><item><title>左偏树（可并堆）</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E5%81%8F%E6%A0%91/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E5%81%8F%E6%A0%91/</guid><description/></item><item><title>树形dp</title><link>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2dp/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2dp/</guid><description>&lt;h1 id="树形dp">树形dp&lt;/h1>
&lt;h2 id="树上最大独立集问题">树上最大独立集问题&lt;/h2>
&lt;p>树形dp最经典的问题。&lt;/p>
&lt;h3 id="问题详情">问题详情&lt;/h3>
&lt;p>一句话：给一棵大小为 $n$ 的树，求最大点权独立集。&lt;/p>
&lt;p>先来看一下啥是独立集，再考虑最大点权的问题。&lt;/p>
&lt;p>选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。&lt;/p>
&lt;p>**最大点权：**即在所有可能存在的独立集中，点权之和(若没有点权，则认为所有点的点权都是$1$)最大的称为最大点权独立集。&lt;/p>
&lt;p>&lt;del>聪明的你立刻联想到了最大独立集=最大匹配！&lt;/del>&lt;/p>
&lt;p>&lt;del>醒醒，二分图匹配没有点权。&lt;/del>&lt;/p>
&lt;p>因此，我们要使用dp思想！&lt;/p>
&lt;p>首先，解决第一个问题——很可能题目并没有指定根节点($root$)，而仅仅给了你一个无向连通图($n$ 个节点 $n-1$ 条边，保证任意两两节点连通)&lt;/p>
&lt;p>我们直接任意选择一个作为根($root$)不就完了嘛！&lt;del>就是这么简单粗暴&lt;/del>&lt;/p>
&lt;img src="ea711e92b4b28994d0dea763f041320f.png" alt="fa" style="zoom:70%;" />
&lt;p>对于整个大问题，dp就是不断求解一个个小问题的过程。&lt;/p>
&lt;p>对于任意一个节点，状态只有两种：&lt;/p>
&lt;ol>
&lt;li>在最大点权独立集中。&lt;/li>
&lt;li>不在最大点权独立集中。&lt;/li>
&lt;/ol>
&lt;p>因此，我们用 $dp[i][0]$ 表示节点 $i$ 不在独立集中时以节点 $i$ 为根的树的最大点权独立集；用 $dp[i][1]$ 表示节点 $i$ 在独立集中时以节点 $i$ 为根的树的最大点权独立集。&lt;/p>
&lt;p>状态转移方程:
$$
\begin{aligned}
&amp;amp;dp[i][1]=\sum dp[son[i][a]][0]\space+val[i]
\&amp;amp;dp[i][0]=\sum max(dp[son[i][a]][0],dp[son[i][a]][1])
\end{aligned}
$$
$son[i][a]$ 记录节点 $i$ 的儿子。&lt;/p>
&lt;p>如果节点 $i$ 在独立集中，则 $i$ 的任何儿子一定不在独立集中。因此，我们只需要把以 $i$ 的儿子们为根且根节点不在独立集中的最大独立集求和再加上节点 $i$ 的点权，就得到正确的解。&lt;/p>
&lt;p>而如果节点 $i$ 不在独立集中，则 $i$ 的儿子在与不在均可。因此，我们要把以 $i$ 的儿子们为根的最大独立集(因此要在根节点在和不在两个中取最大值)求和即可。&lt;/p>
&lt;p>而dp完成后，可得到 $ans=max(dp[root][0],dp[root][1])$。&lt;/p>
&lt;p>至于如何遍历一棵树，当然是&lt;a href="https://xuxihe.vercel.app/oiblogs/graph%e5%9b%be%e8%ae%ba/%e6%90%9c%e7%b4%a2.md">DFS&lt;/a>！&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;h2 id="install-apps">install APPs！&lt;/h2>
&lt;p>众所周知(就算你不知，现在也知了)，背包是可以挂在树上的。&lt;/p>
&lt;p>433大大的疑惑：现在，433明白，自己需要 $n$ 个软件，并且假设她清楚每个软件所需要的安装时间 $w[i]$ 以及实用价值(搞完之后$jj$们能获得的满足感) $val[i]$ (虽然但是这并不可能)，而她因为要练习~~(不，因为烦躁)~~，只有 $m$ 的时间来搞这些事情(否则将因个人原因摧残与迫害电脑)。但是，众所周知(虽然但是可能433不知)，某一些软件依赖于其他软件(这里，我们规定若存在依赖，有且仅有一个依赖项)，如：美颜相机依赖于摄像头驱动——一种433不会搞的东西($jj$们为此卖力的教)，所以，安装任何软件之前，都应确保其依赖的软件全部安装。问能取得的最大价值是多少。&lt;/p>
&lt;p>由上述问题我们发现，软件之间具有依赖关系，一般地，某个物品的依赖物品只有一个~~(如果有多个的话可以考虑把出题人挂在树上)~~(但某个物品可以同时被多个物品依赖)，且依赖关系可以表示为一棵树：如果选择一个物品，则必须选择它的父节点。&lt;/p>
&lt;p>比如，若我们规定 $a$ 依赖于 $b$ 表示为 $a\rightarrow{b}$，则
$$
b\rightarrow{a}
\newline
c\rightarrow{a}
\newline
d\rightarrow{a}
\newline
e\rightarrow{b}
\newline
f\rightarrow{b}
\newline
g\rightarrow{c}
$$&lt;/p>
&lt;p>可以用下图表示：&lt;/p>
&lt;img src="graph%20(1).png" alt="fadf" style="zoom:80%;" />
&lt;h3 id="思路">思路&lt;/h3>
&lt;p>背包和树形dp结合，转化为分组背包问题。&lt;/p>
&lt;p>首先，我们明确，进行树形dp时我们是&lt;strong>从下至上&lt;/strong>进行的，因此我们对节点 $i$ 进行状态转移时，节点 $i$ 的所有儿子的dp值是已知的。&lt;/p>
&lt;p>$dp[i][j]$ 表示以节点 $i$ 为根的树中背包容量为 $j$ 时所能取得的最大价值。&lt;/p>
&lt;p>由图的意义我们可以得知，如果要选择以节点 $i$ 为根节点的树中任意一个节点，都必须选择节点 $i$ (必须按照深度逐一装)。&lt;/p>
&lt;p>因此，留给节点 $i$ 的儿子们的空间只有 $j-w[i]$。我们要在节点 $i$ 的 $k$ 个儿子中，每个儿子分配 $t_k$ 的背包空间，使得 $\sum_{a=1}^kdp[son[i][a]][t_a]\space|\sum_{a=1}^kt_a=j-w[i]$ 最大。&lt;/p>
&lt;p>对此，我们直接进行三重循环即可。因此，时间复杂度为 $O(n^3)$。&lt;/p>
&lt;h3 id="环">环&lt;/h3>
&lt;p>我们知道一般图上是无法dp的。因为图上的环会导致&lt;strong>循环转移&lt;/strong>，即存在后效性(求出的dp值可能不正确)。这在dp问题中是不允许存在的。&lt;/p>
&lt;p>一般图转化为无环图的主要方法是将强连通分量缩成一个点。&lt;/p>
&lt;p>依赖性背包中的强连通分量就是一个环。环中的每个点&lt;strong>或者全选，或者全不选&lt;/strong>，因此可以缩点。&lt;/p>
&lt;p>将强连通分量中的每个点的重量求和作为新点的重量，价值求和作为新点的价值。&lt;/p>
&lt;p>剩下的就是依赖性背包板子了。&lt;/p>
&lt;h3 id="最后的一点儿">最后的一点儿&lt;/h3>
&lt;p>我们将所有依赖关系连边之后就形成一张&lt;strong>图&lt;/strong>。&lt;/p>
&lt;p>如果没有“循环依赖”关系（即环），这些依赖关系就形成若干棵外向树，即&lt;strong>外向树森林&lt;/strong>。&lt;/p>
&lt;p>建立虚拟根节点，价值和重量均为 $0$，并将所有没有依赖的物品都与 $root$ 连边，则转化为一棵外向树。&lt;/p>
&lt;h2 id="基环树上的dp">基环树上的dp&lt;/h2>
&lt;h3 id="首先">首先&lt;/h3>
&lt;p>在学习基环树上的dp之前，就得先把标题看懂——了解奇环树是啥。&lt;/p>
&lt;p>奇环树，就是：&lt;/p>
&lt;ol>
&lt;li>在一棵树上增加一条边。&lt;/li>
&lt;li>个树上有一个环。&lt;/li>
&lt;li>有 $n$ 个点和 $m$ 条边的无向连通图。&lt;/li>
&lt;/ol>
&lt;p>奇环树的情况：&lt;/p>
&lt;ul>
&lt;li>无向&lt;img src="FRnQMj.png" alt="fadf" style="zoom:80%;" />&lt;/li>
&lt;li>有向
&lt;ol>
&lt;li>基环外向树(每个点只有一条入边)。&lt;img src="FRnlss.png" alt="adf" style="zoom:80%;" />&lt;/li>
&lt;li>基环内向树(每个点只有一条出边)。&lt;img src="FRn1Ln.png" alt="fds" style="zoom:80%;" />&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>因为奇环树的边数 $-1$ 便形成了一棵树，因此仍将其视作”树”来解决问题。&lt;/p>
&lt;p>&lt;del>（没看懂）每个点只和一个点连边所形成的无向图一定是一片基环树森林。&lt;/del>&lt;/p>
&lt;p>对于这种&lt;del>恶心&lt;/del>的树，我们也采取一种暴力的手段来对付，就是在环上任意删一条边，然后转化为一棵树，跑树形dp即可。&lt;/p>
&lt;h3 id="找环">找环&lt;/h3>
&lt;p>不管你对于出题人命制的题目有多大的意见~~(tmd，为神魔有环——优美中国话)~~，你都得一步步来——先找到环。&lt;/p>
&lt;p>找到一条边即可，不需要记录所有环上节点。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>无向图：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>你飞速的撸出了一窜&lt;a href="https://xuxihe.vercel.app/oiblogs/graph%e5%9b%be%e8%ae%ba/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f/">拓扑排序&lt;/a>的模板。&lt;/li>
&lt;li>接着，恭喜，环找到了。(入度 $\ge{2}$ 的点就是环上的点，和上一个被访问的点之间的边一定是环边)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>有向图：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>你疯狂的搞出了一份DFS标准模板，调试完成。&lt;/li>
&lt;li>恭喜，环也找到了。(DFS时若某一个节点被访问第二次，即是环上的点，和上一个被访问的点之间的边一定是环边)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="round-1">round $1$&lt;/h3>
&lt;p>但是注意，当我们删去边 $u\rightarrow{v}$ 并以节点 $u$ 为根跑树形dp后，虽然进行了删边操作，但实际上是有的，因此节点 $u$ 和节点 $v$ 仅能选择其中一个，从而出现两种情况：&lt;/p>
&lt;ol>
&lt;li>$dp[u][0]$ 表示强制不选节点 $u$，因此对于节点 $v$ 是否选择无限制，此情况一定成立。&lt;/li>
&lt;li>$dp[u][1]$ 表示强制选择节点 $u$，这时候节点 $v$ 必定不可以选择，但是我们并不清楚节点 $v$ 的选择情况，所以这个dp值在某些情况下是错误的，不能取。&lt;/li>
&lt;/ol>
&lt;p>$dp[u][0]$ 对于节点 $u$ 和 $v$ 的选和不选两种状态的覆盖情况为：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">节点&lt;/th>
&lt;th style="text-align:center">选&lt;/th>
&lt;th style="text-align:center">不选&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">$u$&lt;/td>
&lt;td style="text-align:center">$\times$&lt;/td>
&lt;td style="text-align:center">$\checkmark$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$v$&lt;/td>
&lt;td style="text-align:center">$\checkmark$&lt;/td>
&lt;td style="text-align:center">$\checkmark$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>因此，我们需要考虑一下一定选择 $u$ 节点的情况，因此，我们以节点 $v$ 为根再跑一遍树状dp，而 $dp[v][0]$ 就包含了选择节点 $u$ 的情况。&lt;/p>
&lt;p>最后，我们需要在两种情况下选择较大值 $max(dp[u][0],dp[v][0])$ 即可。&lt;/p>
&lt;h3 id="round-2">round $2$&lt;/h3>
&lt;p>对于这个选与不选的问题，还有一种思考的维度。&lt;/p>
&lt;p>我们考虑节点 $u$ 可能的两种情况：&lt;/p>
&lt;ol>
&lt;li>$dp[u][0]$ 强制不选，这时对节点 $v$ 的状态没有要求，不做处理，正常跑dp即可。、&lt;/li>
&lt;li>$dp[i][1]$ 强制选择，这时节点 $v$ 必须不选，因此，再跑一次dp，将 $dp[v][1]$ 初始化为 $-\infty$ (表示不存在这种情况，进行dp时是不会选择如此不好的节点的，强制保证了不选节点 $v$)。&lt;/li>
&lt;/ol>
&lt;h3 id="外向dag">外向DAG&lt;/h3>
&lt;p>每个点都有且只有一个&lt;strong>入度&lt;/strong>，并且环内的节点方向指向环外，因此任何一个点沿着唯一入边走都会走到环上。&lt;/p>
&lt;h3 id="内向dag">内向DAG&lt;/h3>
&lt;p>每个点都有且只有一个&lt;strong>出度&lt;/strong>，并且环外的节点方向指向环内，因此任何一个点沿着唯一出边走都会走到环上。&lt;/p>
&lt;h2 id="有向无环图dag上的dp拓扑序oiblogsgraph图论拓扑排序dp">有向无环图(DAG)上的dp(&lt;a href="https://xuxihe.vercel.app/oiblogs/graph%e5%9b%be%e8%ae%ba/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f/">拓扑序&lt;/a>dp)&lt;/h2>
&lt;p>因为有向无环图有拓扑序，所以我们按拓扑序转移即可保证无后效性(即改变已经访问过的节点)。&lt;/p>
&lt;p>DAG上的dp可以在 $O(n+m)$ 的时间复杂度内解决&lt;strong>DAG上最短/最长路、最短路计数&lt;/strong>等基本问题。&lt;/p>
&lt;h2 id="其他应用一些奇怪的题的题解">其他应用(一些奇怪的题的题解)&lt;/h2>
&lt;p>&lt;del>有时间再补&lt;/del>&lt;/p></description></item><item><title>强连通分量与缩点</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E4%B8%8E%E7%BC%A9%E7%82%B9/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E4%B8%8E%E7%BC%A9%E7%82%B9/</guid><description>&lt;h1 id="强连通分量与缩点">强连通分量与缩点&lt;/h1>
&lt;h2 id="又是啥玩意">又是啥玩意&lt;/h2>
&lt;h3 id="强连通">强连通&lt;/h3>
&lt;p>&lt;del>在&lt;strong>有向图&lt;/strong> $G$ 中，两个顶点 $u$，$v$ 间有一条从 $u$ 到 $v$ 的有向路径，同时还有一条从 $v$ 到 $u$ 的有向路径，则节点 $u$ 和 节点 $v$ 强连通。&lt;/del>&lt;/p>
&lt;p>啥玩意嘛。&lt;/p>
&lt;p>简单一点，&lt;strong>有向图&lt;/strong>中，两个节点之间可以&lt;strong>互相&lt;/strong>到达，则这两个节点强连通。&lt;/p>
&lt;h3 id="强连通图">强连通图&lt;/h3>
&lt;p>若有向图 $G$ 的每两个顶点都强连通，则 $G$ 是一个强连通图。&lt;/p>
&lt;h3 id="强连通分量">强连通分量&lt;/h3>
&lt;p>&lt;del>有向非强连通图的极大强连通子图，称为强连通分量。&lt;/del>&lt;/p>
&lt;p>又是嘛?&lt;/p>
&lt;p>一个图 $G$，如果是有向图，但是不是强连通图，则图 $G$ 的所有是强连通图的子图中最大的(节点数最多的)称为强连通分量。&lt;/p>
&lt;h2 id="咋求向你缓缓打出一个">咋求？&lt;del>(向你缓缓打出一个？)&lt;/del>&lt;/h2>
&lt;h3 id="tarjan算法">Tarjan算法&lt;/h3>
&lt;p>经典算法？&lt;/p>
&lt;p>首先，需要知道关于&lt;a href="https://xuxihe.vercel.app/oiblogs/graph%e5%9b%be%e8%ae%ba/%e6%90%9c%e7%b4%a2/%e6%90%9c%e7%b4%a2/">DFS生成树&lt;/a>的一些东西。&lt;/p>
&lt;p>观察发现，任何一个强连通分量中必须有至少一个返祖边，因此如果结点 $u$ 是某个强连通分量在搜索树中遇到的第一个结点，那么这个强连通分量的其余结点肯定是在搜索树中以 $u$ 为根的子树中。$u$ 被称为这个强连通分量的根。Tarjan便以此为基础，进行求解。&lt;/p>
&lt;h4 id="维护变量">维护变量&lt;/h4>
&lt;ul>
&lt;li>$dfn[i]$：维护节点 $i$ 的&lt;a href="https://xuxihe.vercel.app/oiblogs/graph%e5%9b%be%e8%ae%ba/%e6%90%9c%e7%b4%a2/%e6%90%9c%e7%b4%a2/">dfs搜索序&lt;/a>。&lt;/li>
&lt;li>$low[i]$：维护节点 $i$ 的子树中和子树中通过一条不在搜索树上的边能到达的所有结点的最小dfn值。&lt;/li>
&lt;li>$stack:run$：维护一个队列，保证上面的节点在以底下第一个 $low[i]=dfn[i]$ 的节点为根的强连通分量中。&lt;/li>
&lt;/ul>
&lt;p>从而我们得到两个推论：&lt;/p>
&lt;ol>
&lt;li>上节点的 $dfn$ 都大于该结点的 $dfn$ 。&lt;/li>
&lt;li>从根开始的一条路径上的 $dfn$ 严格递增，$low$ 严格非降。&lt;/li>
&lt;/ol>
&lt;h4 id="三种情况">三种情况&lt;/h4>
&lt;p>对于当前节点 $u$，有一条 $u\rightarrow{v}$ 的边：&lt;/p>
&lt;ol>
&lt;li>节点 $v$ 未被访问过：继续对 $v$ 进行深度搜索。在回溯过程中，更新 $low[u]=min(low[u],low[v])$。&lt;/li>
&lt;li>节点 $v$ 被访问过，并且在栈中：说明找到一个返祖边，直接更新 $low[u]=min(low[u],low[v])$ 即可。&lt;/li>
&lt;li>节点 $v$ 被访问过，并且不在栈中：节点 $v$ 的强连通分量的根节点已经被找到，其强连通分量已经确定，不用操作。&lt;/li>
&lt;/ol>
&lt;h4 id="注意">注意&lt;/h4>
&lt;img src="graph%20(1).png" style="zoom: 75%;" />
&lt;p>当我们回溯到节点 $i$，发现其 $low[i]=dfn[i]$ 时，说明我们找到一个强连通分量的根节点，栈中在节点 $i$ 上面的都在以节点 $i$ 为根的强连通分量中，因此，对于 $\forall{}\space node\space x\in{upper\space i},\space low[x]=dfn[i]$ 。&lt;/p>
&lt;p>否则，看上图…………经过细致的观察，我们发现，节点 $1、7、5、8、3、4$ 为强连通分量。如果你不在出栈的时候再更新一次，你就惊喜的发现，$low[4]=4$ ？？？因为搜索到 $4\rightarrow8$ 这条边的时候，因为节点 $8$ 刚刚搜搜索到一条至 $low=4$ 的节点，所以$low[8]=4$，就导致 $low[4]=4$，而后没有边再访问到节点 $4$，因此其 $low$ 值无法得到更新，始终为 $4$ ！！！然而，这显然是错的…………&lt;/p>
&lt;p>然后，注意一定要在子树都搜索完成后，在进行弹栈操作。这样，保证横叉边也可以积攒在栈中。&lt;/p>
&lt;h4 id="缩点">缩点&lt;/h4>
&lt;p>&lt;del>看起来好高深的ya子&lt;/del>&lt;/p>
&lt;p>这玩意菜的一批。&lt;/p>
&lt;p>就是对于原来图中的边 $u\rightarrow v$ ，若 $low[u]\neq low[v]$ ，则在新图中连接一条 $low[u]\rightarrow low[v]$ 的边；若 $low[u]=low[v]$ ，则不执行任何操作。&lt;/p>
&lt;p>这时候，我们会发现有可能连重了…………不影响的，好吧，不要强迫症。&lt;/p>
&lt;h4 id="板子">板子&lt;/h4>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3387" target="_blank" rel="noopener">洛谷P3387 【模板】缩点&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using std::max;
using std::min;
const int maxn = 1e4 + 9;
std::vector&amp;lt;int&amp;gt; next[maxn];
std::vector&amp;lt;int&amp;gt; nnet[maxn];
std::vector&amp;lt;int&amp;gt; root;
std::stack&amp;lt;int&amp;gt; run;
int n, m, val[maxn], dfn[maxn], low[maxn], cnt, nval[maxn], ans;
std::bitset&amp;lt;maxn&amp;gt; ins;
void tarjan(int now) //我们直接使用dfn[i]==0?来判断节点 i 是否被访问过
{
ins[now] = 1; //对于任何一个没有被访问过的节点,有可能是根,加入栈
run.push(now);
dfn[now] = low[now] = ++cnt; //我们不清楚其子树
for (int i : next[now]) //遍历所有出度
{
if (!dfn[i]) //如果没有访问过,递归查找并update
{
tarjan(i);
low[now] = min(low[now], low[i]);
}
else if (ins[i]) //如果访问过,直接更新
{
low[now] = min(low[now], low[i]);
}
}
if (dfn[now] == low[now]) //我们搜索完了整个子树,若成立,即可判断当前节点是强连通分量的根
{
while (!run.empty() &amp;amp;&amp;amp; dfn[run.top()] != low[run.top()]) //将压在当前节点上的都弹出
{
nval[low[now]] += val[run.top()]; //统计强连通分量中节点权值和
low[run.top()] = min(low[run.top()], low[now]); //标记所有强连通分量的节！！！
ins[run.top()] = 0; //不在栈中了
run.pop();
}
run.pop(); //同上
ins[now] = 0;
nval[low[now]] += val[now];
}
}
void find(int now) //直接DFS暴搜找到最大路径
{
cnt += nval[now];
int len = nnet[now].size();
if (!len)
{
ans = max(ans, cnt);
}
for (int i = 0; i &amp;lt; len; i++)
{
find(nnet[now][i]);
}
cnt -= nval[now];
}
int main()
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
for (int i = 1; i &amp;lt;= n; i++)
{
scanf(&amp;quot;%d&amp;quot;, &amp;amp;val[i]);
}
int u, v;
for (int i = 0; i &amp;lt; m; i++)
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;u, &amp;amp;v);
next[u].push_back(v);
}
for (int i = 1; i &amp;lt;= n; i++) //防止出现非连通图,对于所有没被遍历到的点做Tarjan
{
if (!dfn[i])
{
ins.reset(); //多次不清空,暴零两行泪
while (!run.empty())
run.pop();
tarjan(i);
}
}
ins.reset(); //废物利用qwq
for (int j = 1; j &amp;lt;= n; j++)
{
for (int i : next[j])
{
if (low[j] != low[i]) //这就是传说中的缩点
{
nnet[low[j]].push_back(low[i]);
ins[low[i]] = 1; //记录入度
}
}
}
for (int i = 1; i &amp;lt;= n; i++)
{
if (!ins[i]) //找到图中所有入度为0的点为根(非连通图可能有多个根)
{
root.push_back(i);
}
}
for (int now : root) //对于每个根,跑DFS
{
cnt = 0; //又是废物利用qwq
find(now);
}
printf(&amp;quot;%d&amp;quot;, ans);
return 0;
}
&lt;/code>&lt;/pre></description></item><item><title>平衡树</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/</guid><description>&lt;h1 id="平衡树">平衡树&lt;/h1>
&lt;h2 id="二叉搜索树">二叉搜索树&lt;/h2>
&lt;p>&lt;strong>二叉搜索树&lt;/strong>是一种二叉树形的数据结构，各节点权值按中序遍历排列单调不增(或不降)。&lt;/p>
&lt;p>&lt;em>中序遍历：先左再中后右&lt;/em>&lt;/p>
&lt;p>二叉搜索树上的基本操作所花费的时间与树的高度成正比。对于一个有 $n$​个结点的二叉搜索树中，这些操作的最优时间复杂度为 $O(\log{n})$​，最坏为 $O(n)$​。&lt;strong>随机构造一棵二叉搜索树的期望高度为 $O(\log{n})$​​&lt;/strong>。&lt;/p>
&lt;p>二叉搜索树其实是一个暴力版本的平衡树，平衡树在二叉搜索树上通过一些算法，将树高严格或期望维持在$\log{n}$​​，但相差不会太大，保证不会退化成一条链。&lt;/p>
&lt;h2 id="各家的平衡树">各家的平衡树&lt;/h2>
&lt;p>平衡树按照应用可以分为两类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>权值平衡树&lt;/strong>：维护一个有序可重集合(按&lt;strong>权值&lt;/strong>排序，中序遍历为已排序的集合)；&lt;/li>
&lt;li>&lt;strong>序列平衡树&lt;/strong>：维护一个序列(按原始&lt;strong>下标&lt;/strong>排序，中序遍历即为序列)，&lt;strong>并不是所有平衡树都能够用作序列平衡树&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>注意，并不是所有家的平衡树都能作为以上任意一种平衡树使用。&lt;/p>
&lt;p>按照平衡树高度又可以分为两类：&lt;/p>
&lt;ul>
&lt;li>强平衡树：树高严格为$O(\log{n})$&lt;/li>
&lt;li>弱平衡树：树高期望为$O(\log{n})$&lt;/li>
&lt;/ul>
&lt;p>常见的平衡树有：&lt;/p>
&lt;ul>
&lt;li>Splay&amp;mdash;伸展树&lt;/li>
&lt;li>Treap&amp;mdash;树堆
&lt;ul>
&lt;li>旋转式Treap&lt;/li>
&lt;li>分裂式Treap(又称fhq-treap，因为是fhq发明的)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>AVL树&lt;/li>
&lt;li>SgT&amp;mdash;替罪羊树(比较有意思，发现树高不为$\log{n}$​时，整个推倒重新建树，复杂度竟然也不高!?)&lt;/li>
&lt;li>RBT&amp;mdash;红黑树(最快的，没有之一，C++ STL都是这个，yyds!)&lt;/li>
&lt;li>…………&lt;/li>
&lt;/ul>
&lt;p>OI中较常用的是 Splay 和 fhq-treap(剩下的性价比不高，要就不是难写，要就不是即难写还慢)。&lt;/p>
&lt;p>&lt;del>所以，你的推是哪个?&lt;/del>&lt;/p>
&lt;h1 id="fhq-treap平衡树">fhq-treap平衡树&lt;/h1>
&lt;p>这东西以一种不可思议的方式运行着。具体来说，就是一言不合，就把你劈成两半……&lt;del>怕了怕了&lt;/del>&lt;/p>
&lt;p>treap 这个单词是由 tree 和 heap 组合而来，这表明 Treap 是一种由&lt;strong>树&lt;/strong>和&lt;strong>堆&lt;/strong>组合形成的数据结构。&lt;/p>
&lt;h2 id="高级之处">高级之处&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>代码短，比线段树长不了多少。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>思想简单易懂，导致的就是Debug时间减少。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>两种平衡树均可使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可支持持久化。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="准备工作">准备工作&lt;/h2>
&lt;h6 id="先来康康需要哪些变量">先来康康需要哪些变量：&lt;/h6>
&lt;ol>
&lt;li>son数组：记录每个节点的儿子节点的编号 son [i] [0] 表示 $i$​ 号节点左儿子的编号，son [i] [1] 为右儿子的编号。&lt;/li>
&lt;li>tot：记录总结点个数，声明一个新节点时会用到。&lt;/li>
&lt;li>root：记录根节点编号。&lt;/li>
&lt;li>size数组：size[i]标记以 $i$ 节点为根的子树大小(包括 $i$ 号节点本身)。&lt;/li>
&lt;li>val数组：记录每个节点的权值。&lt;/li>
&lt;li>rnd数组：记录每个节点的随机优先级。fhq-treap 的每个结点上具有一个$priority$值 ，fhq-treap 除了要满足中序遍历有序的性质之外，还需满足父节点的 $priority$(随便一种关系，如大于、小于等于……)两个儿子的$priority$。在一般的实现中， $priority$是每个结点建立时随机生成的，因此 fhq-treap 是期望平衡的。&lt;/li>
&lt;/ol>
&lt;p>最基本的平衡树的空间复杂度为 $O(5n)$​，当然也可以动态优化，但并不能起到较为显著的效果(每个节点都有可能被访问)。&lt;/p>
&lt;h6 id="宏定义">宏定义&lt;/h6>
&lt;p>有效降低代码长度、出错概率以及Debug时间。&lt;/p>
&lt;pre>&lt;code class="language-c++">#define Ls son[pos][0]
#define Rs son[pos][1]
&lt;/code>&lt;/pre>
&lt;h6 id="build_new_node函数">build_new_node函数&lt;/h6>
&lt;p>声明一个新的节点&lt;/p>
&lt;pre>&lt;code class="language-c++">inline int nnd(int x) //声明一个新的节点并分配priority值
{
size[++tot] = 1;
val[tot] = x; //注意，维护有序队列时，应把x替换成tot，想清楚要维护的是什么
rnd[tot] = rand();
return tot;
}
&lt;/code>&lt;/pre>
&lt;h6 id="update函数">update函数&lt;/h6>
&lt;p>更新当前节点的size信息&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void upd(int pos) //更新节点size大小
{
size[pos] = size[Rs] + size[Ls] + 1;
}
&lt;/code>&lt;/pre>
&lt;h2 id="核心操作分裂与合并">核心操作——分裂与合并&lt;/h2>
&lt;h3 id="分裂">分裂&lt;/h3>
&lt;p>一共两种分裂方法，适用于不同场景。（作为区间平衡树时只有按节点数分裂一种）.&lt;/p>
&lt;p>分裂基本原理为每次判断当前根节点将被分到左右哪侧，再递归分裂根节点位于另一侧的子树，将分裂结果的同侧部分接在原位。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>按权值分裂：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>按照设定的key值为分裂条件，将小于等于key的节点挂在左边，大于key的挂在右边。&lt;/p>
&lt;/li>
&lt;li>
&lt;pre>&lt;code class="language-c++">inline void spv(int pos, int key, int &amp;amp;l, int &amp;amp;r) //按照权值分裂,pos当前节点编号,key分裂值,&amp;amp;l左侧挂载位置,&amp;amp;r右侧挂载位置
{
if (pos == 0) //没有叶子节点,结束递归
{
l = r = 0; //没有叶子节点,结束递归,并将挂载点赋值0(空)
return;
}
if (val[pos] &amp;lt;= key) //如果当前节点小于等于key,则将左子树(都小于当前节点,所以都小于key值)和当前节点挂在左侧,继续分裂右子树
{
l = pos; //挂在上次传递的挂载点位置
spv(Rs, key, Rs, r); //递归分裂右子树,因为右子树中所有值均大于当前节点,因此如果仍有小于key值的应挂在当前节点的右儿子的地方
}
else //如果当前节点大于key,则将右子树(都大于当前节点,所以都大于key值)和当前节点挂在右侧,继续分裂左子树
{
r = pos; //挂在上次传递的挂载点位置
spv(Ls, key, l, Ls); //递归分裂左子树,因为左子树中所有值均小于当前节点,因此如果仍有大于key值的应挂在当前节点的左儿子的地方
}
upd(pos); //更新节点size大小(因为分裂开后,子树大小有改变)
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>按节点个数分裂：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>按照设定的key值，在左侧挂key个最小的节点，其余的挂在右侧。&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>```c++
inline void spn(int pos, int key, int &amp;amp;l, int &amp;amp;r) //按照节点个数分裂,pos当前节点编号,key分裂值,&amp;amp;l左侧挂载位置,&amp;amp;r右侧挂载位置
{
if (pos == 0) //没有叶子节点,结束递归,并将挂载点赋值0(空)
{
l = r = 0;
return;
}
if (size[Ls] + 1 &amp;lt;= key) //如果左子树和当前节点个数之和小于等于key,则挂在左侧,继续在右子树中选key-size[Ls]-1个加入左侧
{
l = pos; //挂在上次传递的挂载点位置
spn(Rs, key - size[Ls] - 1, Rs, r); //递归分裂右子树,因为已经在左侧又挂了size[Ls]+1个节点,所以要在右子树中再选key-size[Ls]-1个即可
}
else //如果左子树和当前节点个数之和大于key,不满足条件,继续在右子树查找size合适的子树
{
r = pos; //挂在上次传递的挂载点位置
spn(Ls, key, l, Ls); //递归分裂左子树,因为并没有在左侧挂任何节点,因此key不改变
}
upd(pos); //更新节点size大小(因为分裂开后,子树大小有改变)
}
```
&lt;/code>&lt;/pre>
&lt;h3 id="合并">合并&lt;/h3>
&lt;p>合并是分裂的逆操作，基本原理为按照优先级判断哪棵树的根将成为新树的根，之后递归地合并另一棵树与当前树的对应子树。&lt;/p>
&lt;p>需要注意的是：fhq-treap 的合并操作相当于只是简单拼接两棵树的中序遍历，&lt;strong>不会检查权值是否有序&lt;/strong>(理论上如果操作正确的话，分裂出的子树均为有序)，如果被合并的两棵树权值大小关系有误，将导致之后按权值分裂是出现不可预期的结果！&lt;/p>
&lt;pre>&lt;code class="language-c++">inline int tog(int l, int r) //合并两棵树,l左侧树的根节点,r右侧树的根节点;递归思想
{
if (l == 0 || r == 0) //如果任意一个树是空的,剩余的树的根节点就是挂载点
return l + r;
if (rnd[l] &amp;lt; rnd[r]) //优先级定义,可以随便写
{
son[l][1] = tog(son[l][1], r); //右侧树挂载左侧树的右侧
upd(l); //更新左侧树根节点的信息
return l; //返回新树的根节点
}
son[r][0] = tog(l, son[r][0]); //左侧树挂载右侧树的左侧
upd(r); //更新右侧树根节点的信息
return r; //返回新树的根节点
}
&lt;/code>&lt;/pre>
&lt;h2 id="各种操作">各种操作&lt;/h2>
&lt;p>总之就是使用上面三种核心操作，实现的一系列qwq的实际操作。&lt;/p>
&lt;p>&lt;del>感受fhq脑洞之大吧&lt;/del>&lt;/p>
&lt;h6 id="inside插入">inside插入&lt;/h6>
&lt;pre>&lt;code class="language-c++">inline void ins(int v)
{
spv(root, v, ll, rr); //按照v分割成根节点为ll和rr两棵子树
root = tog(tog(ll, nnd(v)), rr); //先合并ll和新加入的节点,再和rr合并,然后更新总树的根节点
}
&lt;/code>&lt;/pre>
&lt;h6 id="delete删除">delete删除&lt;/h6>
&lt;p>若有多个相同的数，只删除一个。&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void del(int val)
{
spv(root, val, ll, rr); //按照v分割成根节点为ll和rr两棵子树
spn(ll, size[ll] - 1, ll, LL); //再在左侧分割出1个节点挂在右侧
root = tog(ll, rr); //合并新ll和rr,不合并第二次分裂的右侧1个节点,即删除,然后更新总树的根节点
}
&lt;/code>&lt;/pre>
&lt;h6 id="order-value查询key值的排名">order-value查询key值的排名&lt;/h6>
&lt;p>排名定义为比当前数小的数的个数 $+1$ 。&lt;/p>
&lt;pre>&lt;code class="language-c++">inline int ordv(int v)
{
spv(root, v - 1, ll, rr); //将所有小于v的数分割
int r = size[ll]; //记录根节点size,即所有小于v的节点的数量,后续合并时可能变化
root = tog(ll, rr); //合并分裂开的两棵树
return r + 1; //返回注意+1
}
&lt;/code>&lt;/pre>
&lt;h6 id="order-num查询第key个数的值">order-num查询第key个数的值&lt;/h6>
&lt;pre>&lt;code class="language-c++">inline int ordn(int k)
{
spn(root, k, ll, rr); //分裂出前k个节点
spn(ll, k - 1, ll, RR); //再分裂出前k-1个节点,这样右侧就有一个排名为k的节点,其下标为RR
root = tog(tog(ll, RR), rr); //合并分裂开的两棵树
return val[RR]; //返回编号为RR的节点的权值
}
&lt;/code>&lt;/pre>
&lt;h6 id="fir查询前驱前驱定义为小于x且最大的数">fir查询前驱(前驱定义为小于x，且最大的数)&lt;/h6>
&lt;pre>&lt;code class="language-c++">inline int fit(int v)
{
spv(root, v - 1, ll, rr); //先分裂出所有小于v的节点
spn(ll, size[ll] - 1, ll, RR); //再在小于v的节点中分裂出最大的一个,因为ll是根节点,size[ll]即为小于v的节点数量
root = tog(tog(ll, RR), rr); //合并分裂开的ll,前缀和rr
return val[RR]; //返回前驱的值
}
&lt;/code>&lt;/pre>
&lt;h6 id="back查询后继后继定义为大于x且最小的数">back查询后继(后继定义为大于x，且最小的数)&lt;/h6>
&lt;pre>&lt;code class="language-c++">inline int back(int v)
{
spv(root, v, ll, rr); //先分裂出所有小于等于v的节点
spn(rr, 1, LL, rr); //再在大于v的节点中分裂出最小的一个
root = tog(tog(ll, LL), rr); //合并分裂开的ll,后缀和rr
return val[LL]; //返回后缀的值
}
&lt;/code>&lt;/pre>
&lt;h2 id="懒标记">“懒”标记&lt;/h2>
&lt;p>在某些时候，当实现一个对于区间的操作时，也可以在平衡树上使用“懒”标记以达到降低时间复杂度的目的。&lt;/p>
&lt;p>和&lt;a href="./%e7%ba%bf%e6%ae%b5%e6%a0%91.md">线段树&lt;/a>一样，也应该注意标记的下放和优先级关系。&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>状压dp</title><link>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/</guid><description>&lt;h1 id="状压dp">状压dp&lt;/h1>
&lt;p>又是二进制的东西……&lt;del>烦躁&lt;/del>&lt;/p>
&lt;p>这东西只是一个辅助，用来优化暴力或dp空间的。&lt;/p>
&lt;h2 id="用武之地">用武之地&lt;/h2>
&lt;p>当状态维数 $n$ 很多但每一维状态数 $k$ 都很少(一般是 $2$)的时候，我们可以用一个 $n$ 位 $k$ 进制整数来表示这维状态。&lt;/p>
&lt;p>下面，我们单表状态数为 $2$ 的情况。&lt;/p>
&lt;p>在学习状压dp之前，我们应该清楚所有的dp是解决&lt;strong>多&lt;/strong>阶段&lt;strong>决策最&lt;/strong>优化问题的一种思想方法。请注意&lt;strong>多阶段&lt;/strong>这三个字，如何定义状态是动态规划最重要的一步。状态的定义也就决定了阶段的划分。&lt;/p>
&lt;p>动态规划多阶段一个&lt;strong>重要&lt;/strong>的特性就是&lt;strong>无后效性&lt;/strong>(值对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的发展，而只能通过当前的这个状态。换句话说影响当前阶段状态只可能是前一阶段的状态，而不能是后续的状态)&lt;/p>
&lt;p>那么可以看出如何&lt;strong>定义状态&lt;/strong>是至关重要的，因为状态决定了阶段的划分，阶段的划分保证了无后效性。&lt;/p>
&lt;p>因此，我们为了保证无后效性，通常要在转移的时候带上足够的数据(很可能是一个数组)，这时的空间开销就会很大，因此我们把原数组中的每一位表示为某一个数字的某一位，这样只需要携带 $O(1)$ 的空间转移了。&lt;/p>
&lt;h2 id="例子">例子&lt;/h2>
&lt;p>我们回想&lt;a href="./%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98.md">01背包&lt;/a>，如果我们要让你记录一下具体是怎么装的如何？当时，我们给出了反向迭代推导的方法。&lt;/p>
&lt;p>但是，我们也可以在每次dp决策的时候就记录一下，并带着选择的方式转移，这样我们就不用回溯了(典型的牺牲空间换取时间的办法)。&lt;/p>
&lt;p>我们开了一个数组，&lt;code>bool ji[n][k][n]&lt;/code>(虽然可以一维优化)，但是我十分不爽，这搞的空间过大了！&lt;/p>
&lt;p>所以，我们想起了状压dp，因此，我们现在要降成二维&lt;code>int ji[n][k]&lt;/code>，$ji[i][j]$ 表示对应dp表第 $i$ 行第 $j$ 列的选择方式：第 $1$ 个物品对应 $ji[i][j]$ 第一位的 $0/1$，第 $2$ 个对应第二位的 $0/1\space\dots\dots$&lt;/p>
&lt;p>然后，我们把这个二进制数存在一个&lt;code>int&lt;/code>里不就可了嘛，这样你就塞下了 $32$ 位的状态，真香。&lt;/p>
&lt;h2 id="从-on-到-o2n">从 $O(n!)$ 到 $O(2^n)$&lt;/h2>
&lt;p>状压dp是最接近暴力的一种dp，因为它可以完整地记录每一种状态。&lt;/p>
&lt;p>但它又比 $O(n!)$ 的纯暴力搜索要优一些，因为它舍弃了状态的更新顺序的记录。&lt;/p>
&lt;p>所以很多情况下，状压dp就是将 $O(n!)$ 的暴力优化到的另一个 $O(2^n)$ 暴力的过程。&lt;/p>
&lt;h2 id="子集枚举">子集枚举&lt;/h2>
&lt;h2 id="合理运用小范围数据">合理运用小范围数据&lt;/h2>
&lt;p>状压dp中 $2^n$ 的复杂度使得题目中的某些数据范围也会很小（一般在 $25$ 以下）。当遇到 $\le{25}$ 数据范围时一定要敏感。&lt;/p></description></item><item><title>树链刨分</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</guid><description>&lt;h1 id="树链刨分">树链刨分&lt;/h1>
&lt;p>一种极致优化的树上算法，据说07年被某个集训队队员搞出来的。&lt;/p>
&lt;p>关于DFN序，参见&lt;a href="https://xuxihe.vercel.app/oiblogs/graph%e5%9b%be%e8%ae%ba/%e6%90%9c%e7%b4%a2/%e6%90%9c%e7%b4%a2/">搜索&lt;/a>。&lt;/p>
&lt;h2 id="一波约定">一波约定&lt;/h2>
&lt;p>为方便起见,我们约定一棵树的某些数据如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>$siz[i]$ 表示 $i$ 结点的子树大小&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$dep[i]$ 表示 $i$ 结点的所在深度(定义根的所在深度为$1$)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$fa[i]$ 表示 $i$ 结点的父结点编号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$bson[i]$ 表示 $i$ 节点的重儿子的编号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$top[i]$ 表示 $i$ 节点所在链的顶端节点&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="儿子还分轻重">儿子还分轻重?&lt;/h2>
&lt;p>对于任意一个&lt;strong>非叶子&lt;/strong>结点，它的子结点中 $siz$ 最大的定义为它的重儿子，其余的子结点定义为它的轻儿子。注意：重儿子有且仅有一个，若有多个最大子树，任意选择一个为重儿子，其余为轻儿子即可。叶子节点没有重儿子。&lt;/p>
&lt;blockquote>
&lt;p>很好理解，从字面上来看，重儿子就是子树中节点数最多的那一个，比较“重”；而剩下的儿子的子树节点数比较少，所以就“轻”。&lt;/p>
&lt;/blockquote>
&lt;p>这样，我们可以将树上的边也分为两类：父结点与重儿子之间连接的边为&lt;strong>重边&lt;/strong>，与轻儿子连接的边为&lt;strong>轻边&lt;/strong>。&lt;/p>
&lt;p>进而推广到，由多条重边连接而成的路径为&lt;strong>重链&lt;/strong>。&lt;/p>
&lt;p>看一个例子：&lt;/p>
&lt;img src="%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86.png" alt="adf" style="zoom:80%;" />
&lt;p>其中，&lt;font color="ffbf00">黄色节点&lt;/font>为其父亲节点的&lt;font color="ffbf00">重儿子&lt;/font>，白色为轻儿子；&lt;font color="red">红色边&lt;/font>为&lt;font color="red">重边&lt;/font>，黑色为轻边；&lt;font color="green">绿色底&lt;/font>为&lt;font color="green">重链&lt;/font>。&lt;/p>
&lt;p>如此划分，则：&lt;/p>
&lt;ol>
&lt;li>轻边 $(u,v)$ 中, $size(u)≤ size(\frac{v}{2})$&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>至少存在一个重儿子大于等于自己的 $size$。&lt;/p>
&lt;/blockquote>
&lt;ol start="2">
&lt;li>
&lt;p>从根到某一点的路径上,不超过 $\log{n}$ 条轻链和不超过 $\log{n}$ 条重链。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>树中任意两个节点之间的路径，都可以将其拆分为不超过 $4\log{n}$ 条重链 + 轻边&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="它来了">它来了&lt;/h2>
&lt;p>&lt;del>本质上是一种优化暴力&lt;/del>&lt;/p>
&lt;p>首先，完成树链剖分，有如下操作：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>求出每个节点的子树大小(找到重儿子)，每个节点的深度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在第 $1$ 步的基础上，找出每条轻链和重链&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>简化一下，就是先DFS一次，求DFS序，把烂七八糟的填上；然后再来一次，把轻链和重链搞出来，完事。&lt;/p>
&lt;p>第一次：&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void dfs1(int now, int deep)
{
dep[now] = deep;
int big = 0; //别忘了初始化
for (auto i : next[now])
{
if (!fa[i]) //无向图判断是否是父节点，防止死循环
{
fa[i] = now; //子节点的父亲是自己
dfs1(i, deep + 1); //递归遍历
if (size[i] &amp;gt; big) //有更重的儿子
{
big = size[i];
son[now] = i; //标记重儿子
}
size[now] += size[i]; //加上这个儿子的size
}
}
size[now]++; //加上自己的1个
return;
}
&lt;/code>&lt;/pre>
&lt;p>第二次：&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void dfs2(int now, int t, bool big)
{
//这里如果要维护区间的话，要记录dfn序，注意先遍历重儿子
top[now] = t; //维护链顶端顶点
if (!son[now]) //叶子节点
return;
dfs2(son[now], t, 1); //先递归查找重链
for (int i : next[now])
{
if (i != fa[now] &amp;amp;&amp;amp; i != son[now])
{
dfs2(i, i, 0); //递归轻边
}
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="一些细节">一些细节&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>轻链：&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>很多博文中，我们又看到了一个新的东西——轻链。&lt;/p>
&lt;p>其实，你是&lt;strong>不能&lt;/strong>把轻边连成一条链的，看下图：&lt;/p>
&lt;img src="graph%20(3)-16332643443841.png" style="zoom:70%;" />
&lt;p>我们观察发现，如果我们将 $9$ 挂到 $3$ 上面的话，就和 $3\rightarrow8\rightarrow10$ 这条重链重了，造成求解的失败。&lt;/p>
&lt;ol start="2">
&lt;li>&lt;strong>top：&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>在树链刨分中，我们要把一条重链上的点看做一个点，即这条重链的顶点，比较是均以顶点去比较。&lt;/p>
&lt;ol start="3">
&lt;li>&lt;strong>跳转fa：&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>注意，每次跳转的时候，都要跳转到顶点的fa，否则就死循环卡那了。&lt;/p>
&lt;h2 id="实战求解lca">实战：求解LCA&lt;/h2>
&lt;p>LCA，最近公共祖先。&lt;/p>
&lt;p>结点 $u$ 和 $v$ 向上跳，每次将&lt;strong>深度较大&lt;/strong>的结点跳到自己所在的链的顶端结点，重复执行直至两个结点位于同一条重链上。&lt;/p>
&lt;p>一个一个的跳，防止跳过了。&lt;/p>
&lt;p>选择深度较大的点，保证了在跳到的链上从顶点到原先的深度可以反复横跳，这样，如果另一个深度较小的点也跳到了同一个链上，则上链深度一定在深度较大的点的横跳范围之内，所以就是LCA。&lt;/p>
&lt;p>这里注意，每次将&lt;strong>链顶深度&lt;/strong>大的点向上跳，当在同一条链上时，取&lt;strong>深度较小&lt;/strong>的点为LCA。&lt;/p>
&lt;p>时间复杂度为 $O(\log{n})$&lt;/p>
&lt;p>[洛谷 P3379 【模板】最近公共祖先（LCA）][https://www.luogu.com.cn/problem/P3379]&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
const int maxn = 5e5 + 9;
int n, m, root, size[maxn], son[maxn], top[maxn], dep[maxn], fa[maxn];
std::vector&amp;lt;int&amp;gt; next[maxn];
inline void dfs1(int now, int deep)
{
dep[now] = deep;
int big = 0, ji = 0;
for (auto i : next[now])
{
if (!fa[i])
{
fa[i] = now;
dfs1(i, deep + 1);
if (size[i] &amp;gt; big)
{
big = size[i];
son[now] = i;
}
size[now] += size[i];
}
}
size[now]++;
return;
}
inline void dfs2(int now, int t, bool big)
{
top[now] = t;
if (!son[now])
return;
dfs2(son[now], t, 1);
for (int i : next[now])
{
if (i != fa[now] &amp;amp;&amp;amp; i != son[now])
{
dfs2(i, i, 0);
}
}
}
inline int lca(int a, int b)
{
while (top[a] != top[b])
{
if (dep[top[a]] &amp;lt; dep[top[b]])
std::swap(a, b);
a = fa[top[a]];
}
return dep[a] &amp;gt; dep[b] ? b : a;
}
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;root);
for (int i = 1; i &amp;lt; n; i++)
{
int a, b;
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
next[a].push_back(b);
next[b].push_back(a);
}
fa[root] = root;
dfs1(root, 1);
dfs2(root, root, 0);
while (m--)
{
int a, b;
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
printf(&amp;quot;%d\n&amp;quot;, lca(a, b));
}
return 0;
}
&lt;/code>&lt;/pre></description></item><item><title/><link>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/manacher%E7%AE%97%E6%B3%95/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/manacher%E7%AE%97%E6%B3%95/</guid><description/></item><item><title>树状数组</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid><description>&lt;h1 id="树状数组">树状数组&lt;/h1>
&lt;p>一种~~&lt;a href="https://xuxihe.vercel.app/oiblogs/basic%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3/%e5%80%8d%e5%a2%9e">&lt;strong>倍增?&lt;/strong>&lt;/a>&lt;a href="https://xuxihe.vercel.app/oiblogs/basic%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3/%e5%88%86%e6%b2%bb">&lt;strong>分治？&lt;/strong>&lt;/a>~~思想下的奇奇怪怪的东西…………&lt;/p>
&lt;p>&lt;del>先放个图&lt;/del>&lt;img src="%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png" alt="树状数组" style="zoom: 50%;" />&lt;/p>
&lt;h2 id="用的地方">用的地方&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>正常数组的单点修改时间复杂度为$O(1)$，区间查询为$O(n)$;
而树状数组的单点修改和区间查询均为$O(\log{n})$。（因为树的高度为$\log{n}$）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>相比于某个更sb的东西：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>单次操作时间复杂度为$O(\log{n})$且常数很小，实际运行效率远优于&lt;a href="https://xuxihe.vercel.app/oiblogs/data%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e7%ba%bf%e6%ae%b5%e6%a0%91/">线段树&lt;/a>&lt;del>(虽然理论上时间复杂度相同)&lt;/del>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>空间复杂度$O(n)$，在某些场景下较&lt;a href="https://xuxihe.vercel.app/oiblogs/data%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e7%ba%bf%e6%ae%b5%e6%a0%91/">线段树&lt;/a>($O(4n)$)有极大优势&lt;/p>
&lt;/li>
&lt;li>
&lt;p>理解以后很好写(它很短，不费手，不需Debug $_{除非手残}$​ &lt;del>(不理解也很好背)&lt;/del> &lt;del>(理解是不可能理解的)&lt;/del>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;p>适用范围比&lt;a href="https://xuxihe.vercel.app/oiblogs/data%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e7%ba%bf%e6%ae%b5%e6%a0%91/">线段树&lt;/a>&lt;strong>小的多&lt;/strong>。树状数组能有的操作，线段树&lt;strong>一定有&lt;/strong>；线段树有的操作，树状数组&lt;strong>大部分没有&lt;/strong>。&lt;/p>
&lt;h2 id="最最最奇怪的地方">最最最奇怪的地方&lt;/h2>
&lt;img src="fenwick1.png" alt="&amp;运算" style="zoom:68%;" />
&lt;p>&lt;del>你这玩意谁想的粗来？&lt;/del>&lt;/p>
&lt;h3 id="先搞一个题外话c中对于负整数是如何存储的">先搞一个题外话——C++中对于负整数是如何存储的。&lt;/h3>
&lt;p>&lt;del>默认都知道变量会预留一个二进制位为符号位，虽然但是并没有什么关系且不知道也不影响&lt;/del>&lt;/p>
&lt;p>对于一个负整数，存贮方法为先将这个数的&lt;strong>绝对值取反&lt;/strong>，**再$+1$**​。&lt;del>(是不是十分反人类!?)&lt;/del>&lt;/p>
&lt;p>举个栗子(上图也有)：$1$​​ &amp;ndash;&amp;gt; $(0001)_2$​ $-1$​ &amp;ndash;&amp;gt; $(1110)_2+(0001)_2$​​ &amp;ndash;&amp;gt; $(1111)_2$&lt;/p>
&lt;h3 id="然后我们惊喜的发现">然后，我们惊喜的发现：&lt;/h3>
&lt;p>咦，如果我们吧原数和原数的相反数与起来好像不错……&lt;/p>
&lt;p>$1&amp;amp;-1$ = $(0001)_2$ &lt;del>好像又回来了？&lt;/del>&lt;/p>
&lt;p>其实是我们得到了原数的lowbit，即原数二进制表示中为$1$的最低位。&lt;/p>
&lt;p>再观察，它好像正好转换成十进制就是它的长度…………&lt;/p>
&lt;p>&lt;del>这个世界好神奇!!!&lt;/del>&lt;/p>
&lt;p>&lt;del>不理解就放过自己吧，背住就好&lt;/del>&lt;/p>
&lt;h2 id="终于进入正题">终于，进入正题&lt;/h2>
&lt;p>&lt;del>最最最奇诡的东西过去了，剩下的就简单?了&lt;/del>&lt;/p>
&lt;p>树状数组的第$i$位维护以第$i$位为终点，长度为$i&amp;amp;-i$的&lt;strong>区间和&lt;/strong>。&lt;/p>
&lt;p>更新时注意要将压在上面的&lt;strong>全部&lt;/strong>更新&lt;/p>
&lt;p>查找时只能查找从$1\sim i$的区间和；要想查找区间$[i,j]$的和，请用 $1\sim j$ 的区间和减去 $1\sim(i-1)$ 的区间和。&lt;/p>
&lt;h6 id="注意-是-i-1-而不是-i-">&lt;strong>注意! 是 $i-1$​​ 而不是 $i$​​ ​！！！&lt;/strong>&lt;/h6>
&lt;p>从第$i$位开始向上查找，将所跳转到的求和，直到下标为$0$​。&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
const int maxe = 5e5 + 9;
int tree[maxe], n, m;
inline void add(int x, int val) //一直更新直到最上层
{
for (; x &amp;lt;= n; x += x &amp;amp; -x)
tree[x] += val;
}
inline int sum(int x) //一直加到下标为0
{
int ans = 0; //注意赋初始值为0，防止奇奇怪怪的事情
for (; x &amp;gt; 0; x -= x &amp;amp; -x)
ans += tree[x];
return ans;
}
int main()
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
for (int i = 1; i &amp;lt;= n; i++)
{
int a;
scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
add(i, a);
}
while (m--)
{
int a, b, c;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c);
if (a == 1)
add(b, c);
else
printf(&amp;quot;%d\n&amp;quot;, sum(c) - sum(b - 1));
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="区间修改和单点查询">区间修改和单点查询&lt;/h2>
&lt;p>用到一个比较神奇但是还能理解的东西&lt;a href="https://xuxihe.vercel.app/oiblogs/others%e6%9d%82%e9%a1%b9/%e5%b7%ae%e5%88%86%e6%95%b0%e7%bb%84/">差分数组&lt;/a>。&lt;/p>
&lt;p>用树状数组维护差分数组，以达到快速区间修改和单点查询的操作。&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
const int maxe = 5e5 + 9;
int tree[maxe], n, m;
inline void add(int x, int val) //没啥不一样
{
for (; x &amp;lt;= n; x += x &amp;amp; -x)
tree[x] += val;
}
inline int sum(int x)
{
int ans = 0;
for (; x &amp;gt; 0; x -= x &amp;amp; -x)
ans += tree[x];
return ans;
}
int main()
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
int a, last = 0;
for (int i = 1; i &amp;lt;= n; i++)
{
scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
add(i, a - last); //建立差分数组
last = a;
}
while (m--)
{
int a, b, c, d;
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
if (a == 1)
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;c, &amp;amp;d);
add(b, d); //将区间起点加val
add(c + 1, -d); //将区间终点后一位减val,消除贡献
}
else
printf(&amp;quot;%d\n&amp;quot;, sum(b));
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="区间求和">区间求和&lt;/h2>
&lt;p>&lt;del>奇妙&lt;/del>&lt;/p>
&lt;p>先让我们看一个$long\space long $的式子：
$$
\begin{aligned}
sum([1,r])=&amp;amp;\sum_{i=1}^{r} a_i=\sum_{i=1}^r\sum_{j=1}^i b_j\=&amp;amp;\sum_{i=1}^r b_i\times(r-i+1)\=&amp;amp;(r+1)\times \color{red}{\sum_{i=1}^r b_i}-\color{red}{\sum_{i=1}^r b_i\times i}
\end{aligned}
$$
&lt;del>你感受到数学的魅力了吗？是不是每一个字符你都认识，但是就是不懂它们组合起来是啥意思&lt;/del>&lt;/p>
&lt;p>亿点点地看，&lt;/p>
&lt;p>$a$ 数组为原始数组(初始值)&lt;/p>
&lt;p>$b$ 数组为树状数组维护的差分数组&lt;/p>
&lt;p>下面把上面那段鬼话变成人话……不用数学符号就是有点长……
$$
\begin{aligned}
\sum([1,r])=&amp;amp;a_1+a_2+a_3+\cdots+a_{r-1}+a_r\=&amp;amp;(b_1)+(b_1+b_2)+(b_1+b_2+b_3)+\cdots+(b_1+b_2+\cdots+b_{r-1})+(b_1+b_2+\cdots+b_{r-1}+b_r)\=&amp;amp;(b_1\times r)+(b_2\times(r-1))+(b_3\times(r-2))+\cdots+(b_{r-1}\times2)+(b_r\times1)\=&amp;amp;\sum_{i=1}^r b_i\times(r-i+1)\=&amp;amp;\color{red}{(r+1)\times\sum_{i=1}^r b_i-\sum_{i=1}^r b_i\times i}
\end{aligned}
$$
推导之后，我们发现，用树状数组维护两个值($b_i$ 和 $b_i\times i$)即可。&lt;/p>
&lt;h2 id="二维多维树状数组">二维、多维树状数组&lt;/h2>
&lt;p>&lt;del>最简单的一种&lt;strong>树套树&lt;/strong>&lt;/del> &lt;del>直接套娃即可&lt;/del> &lt;del>这辈子也别想画出示意图&lt;/del>&lt;/p>
&lt;p>在外层树状数组的每个节点上维护一棵树状数组&lt;/p>
&lt;p>查询/更新时使用二重循环即可。&lt;/p>
&lt;p>&lt;a href="https://baike.baidu.com/item/%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">百度百科&lt;/a> &lt;del>看懂是不可能看懂的，慎重尝试&lt;/del>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
const int maxe = 5e2 + 9;
int n, m, q, tree[maxe][maxe];
inline void add(int x, int y, int val) //注意不能直接调用y,双重循环
{
for (int i = x; i &amp;lt;= n; i += i &amp;amp; -i)
{
for (int j = y; j &amp;lt;= m; j += j &amp;amp; -j)
{
tree[i][j] += val;
}
}
}
inline int sum(int x, int y)
{
int ans = 0;
for (int i = x; i &amp;gt; 0; i -= i &amp;amp; -i)
{
for (int j = y; j &amp;gt; 0; j -= j &amp;amp; -j)
{
ans += tree[i][j];
}
}
return ans;
}
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;q);
for (int i = 1; i &amp;lt;= n; i++)
{
for (int j = 1; j &amp;lt;= m; j++)
{
int a;
scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
add(i, j, a);
}
}
while (q--)
{
char aa[100];
int a, b, c, d;
scanf(&amp;quot;%s%d%d%d&amp;quot;, aa, &amp;amp;a, &amp;amp;b, &amp;amp;c);
if (aa[0] == 'A')
add(a, b, c);
else
{
scanf(&amp;quot;%d&amp;quot;, &amp;amp;d);
printf(&amp;quot;%d\n&amp;quot;, sum(b, d) + sum(a - 1, c - 1) - sum(b, c - 1) - sum(a - 1, d));
//二维前缀和
//减一不搞好,亲人两行泪
}
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="树状数组上的二分">树状数组上的二分&lt;/h2>
&lt;p>建议直接移步&lt;a href="https://xuxihe.vercel.app/oiblogs/data%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e5%b9%b3%e8%a1%a1%e6%a0%91/">平衡树&lt;/a>或者&lt;a href="https://xuxihe.vercel.app/oiblogs/data%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e7%ba%bf%e6%ae%b5%e6%a0%91/">线段树&lt;/a>。&lt;/p>
&lt;p>&lt;strong>摘抄如下：&lt;/strong>&lt;/p>
&lt;p>类似于线段树上二分，树状数组上也可以进行二分。&lt;/p>
&lt;p>使用&lt;strong>树状数组上二分&lt;/strong>（可能需要预先离散化），可以$O(log\space{n})$​查询第 $k$​ 小/大元素，实现类似&lt;strong>平衡树&lt;/strong>的效果。&lt;/p>
&lt;p>主要思想是：按二进制位从高到低逐渐二分出答案。&lt;/p>
&lt;pre>&lt;code class="language-c++">int kth(int k) {
int r = 0, t;
for (int i = LOG_N; i&amp;gt;=0; --i) {
t = r | 1 &amp;lt;&amp;lt; i;
if (t &amp;lt;= n &amp;amp;&amp;amp; d[t] &amp;lt; k)k -= d[t], r = t;
}
return r + 1;
}
&lt;/code>&lt;/pre></description></item><item><title>欧拉回路</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</guid><description>&lt;h1 id="欧拉回路">欧拉回路&lt;/h1>
&lt;h2 id="前置知识">前置知识&lt;/h2>
&lt;p>图 $G$ 中恰好经过所有边一次(不可重复经过)的通路称作欧拉通路，恰好经过所有边一次的回路称作欧拉回路。&lt;/p>
&lt;p>具有欧拉回路的图称为欧拉图，具有欧拉通路但不具有欧拉回路的图称为半欧拉图。&lt;/p>
&lt;p>&lt;strong>存在欧拉通路的充要条件：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>无向图：&lt;/strong> 各点连通，没有或仅有两个奇度结点。(偶度保证一入一出，两个奇度可以作为起止节点)&lt;/li>
&lt;li>&lt;strong>有向图：&lt;/strong> 各点连通，有一个点出度 = 入度 +1，有一个点入度 = 出度 +1，其余点入度 = 出度。(入度出度相同保证一入一出，其余两点为起止节点)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>存在欧拉回路的充要条件：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>**无向图：**各点连通，所有点为偶度。(存在奇度节点即存在起止点，当起止点相同时，$奇数+奇数=偶数$，因此所有节点均为偶度)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**有向图：**各点连通，所有点入度 = 出度。(当其起止点为同一个是，那个点 入度 +1 = 出度 +1，因此所有点入度 = 出度)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="dfs求解">DFS求解&lt;/h2>
&lt;p>利用欧拉定理判断出一个图存在欧拉回路或欧拉通路后，选择一个正确的起始顶点，用DFS算法遍历所有的边(每一条边只遍历一次)，遇到走不通就回退。在搜索前进方向上将遍历过的边按顺序记录下来，这组边的排列就组成了一条欧拉通路或回路。&lt;/p>
&lt;h2 id="fleury佛罗莱算法">Fleury(佛罗莱)算法&lt;/h2>
&lt;p>&lt;del>以后有时间再说&lt;/del>&lt;/p></description></item><item><title>线段树</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid><description>&lt;h1 id="线段树">线段树&lt;/h1>
&lt;h2 id="介绍一下">介绍一下&lt;/h2>
&lt;p>又是一个&lt;a href="">倍增&lt;/a>思想下&lt;del>奇奇怪怪&lt;/del>的东西。&lt;/p>
&lt;p>线段树是一种高效维护(在手不残的前提下)&lt;strong>区间信息&lt;/strong>的数据结构，可以在$O(\log{n})$​​​​时间复杂度内实现单点修改、区间修改、区间查询等(各种稀奇古怪的)操作。树状数组能够解决的问题&lt;strong>理论上&lt;/strong>(注意空间复杂度)都可以用线段树解决。&lt;del>就是慢了点，空间占得大了点儿&lt;/del>&lt;/p>
&lt;p>线段树以树形(满二叉树，二叉搜索树)结构维护着这样一些“线段”(区间)的信息：&lt;/p>
&lt;ul>
&lt;li>根结点对应一条$1\sim n$​的线段。&lt;/li>
&lt;li>任何线段$(l\sim r)$​​​长度$&amp;gt;1$​​​的结点都有恰好两个子结点，分别对应线段 $l\sim mid$​​​ 与 $mid+1\sim r$​​​，其中 $mid=\lfloor\dfrac{l+r}{2}\rfloor$​​​。&lt;/li>
&lt;/ul>
&lt;p>线段树上结点的深度每增大 $1$，线段长度就折半，因此线段树深度为 $\log{n}$​​，由此保证了单点修改复杂度为$O(\log{n})$​。&lt;/p>
&lt;p>对于任意区间，都可以在线段树上找到不重叠的至多 $2\times\log{n}$​ 条线段（每种深度至多两条）将其恰好覆盖，这保证了线段树区间操作复杂度为 $O(\log{n})$​。&lt;/p>
&lt;p>规定根结点编号为 $1$​​​​​​，编号为 $i$​​​​​​ 的结点的两个子结点（若存在）编号为 $2i$​ ​​​​​与 $2i+1$ ​​​​​​。这样定义的结点编号最大不会超过 $4n$​​​​​。&lt;/p>
&lt;p>一棵维护最小值的线段树大概长这样：&lt;img src="src=http%253A%252F%252Fimg-blog.csdnimg.cn%252Fimg_convert%252F1809e9bc319190c55e869070f02a058f.png&amp;refer=http%253A%252F%252Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg" alt="线段树" style="zoom: 40%;" />&lt;/p>
&lt;h2 id="线段树所占空间的计算">线段树所占空间的计算&lt;/h2>
&lt;p>&lt;del>这一段不看不会也罢&lt;/del>，只需要记住开 $4n$​ 个数组就行了。&lt;/p>
&lt;p>关于线段树的空间：如果采用堆式存储(大部分)($2i$​​是 $i$​​的左儿子，$2i+1$​​是 $i$​​的右儿子)，若有 $n$​​ 个叶子结点，则 $d$​​ 数组的范围最大为 $2^{\lceil\log{n}\rceil+1}$​。
分析：容易知道线段树的深度是 $\lceil\log{n}\rceil$​的，则在堆式储存情况下叶子节点（包括无用的叶子节点）数量为 $2^{\lceil\log{n}\rceil}$​个，又由于其为一棵完全二叉树(补齐未使用节点)，则其总节点个数 $2^{\lceil\log{n}\rceil+1}-1$​。当然如果你懒得计算的话可以直接把数组长度设为 $4n$​，因为 $\dfrac{2^{\lceil\log{n}\rceil+1}-1}{n}$​的最大值在 $n=2^x+1(x\in N_+)$​时取到，此时节点数为 $2^{\lceil\log{n}\rceil+1}-1=2^{x+2}-1=4n-5$​。&lt;/p>
&lt;h2 id="正题来了">正题来了&lt;/h2>
&lt;p>其实，没啥好说的，很好理解，很不好背……&lt;/p>
&lt;p>下面这4个函数，构建了最最最简单的线段树，效果大概可树状数组一样。&lt;/p>
&lt;p>ps：变量名尽量统一，好处多多。&lt;/p>
&lt;h6 id="宏定义">宏定义&lt;/h6>
&lt;p>有效降低代码长度、出错概率以及Debug时间。&lt;/p>
&lt;p>如果你很猛，请跳过这一段……&lt;/p>
&lt;p>&lt;del>使用位运算是因为本来线段树就很慢，所以要用快一点的位运算&lt;/del>&lt;/p>
&lt;pre>&lt;code class="language-c++">#define Mid ((l + r) &amp;gt;&amp;gt; 1) //位运算,相当于(l + r)/2
#define Len (r - l + 1) //区间长度,注意+1
#define Root 1, 1, n //根节点调用
#define Lpos pos &amp;lt;&amp;lt; 1 //左儿子节点编号,相当于pos*2
#define Rpos Lpos | 1 //右儿子节点编号,相当于Lpos+1
#define Lson Lpos, l, Mid //左儿子调用
#define Rson Rpos, Mid + 1, r //右儿子调用
#define This pos, l, r //当前节点调用
&lt;/code>&lt;/pre>
&lt;h6 id="update函数">update函数&lt;/h6>
&lt;p>更新节点信息&lt;/p>
&lt;p>视维护啥而定&lt;/p>
&lt;p>&lt;em>for example:&lt;/em>&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void upd(int pos)
{
tree[pos] = tree[Lpos] + tree[Rpos]; //维护区间和
tree[pos] = std::max(tree[Lpos], tree[Rpos]); //维护区间最大值
}
&lt;/code>&lt;/pre>
&lt;h6 id="build函数">build函数&lt;/h6>
&lt;p>从原数组构建线段树&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void build(int pos, int l, int r)//pos当前节点编号，l区间右端点，r区间左端点
{
if (l == r)//区间长度为1则赋值原数组
tree[pos] = in[l];//注意是l而不是pos，是区间在原数组中维护的位置而不是节点编号
else
{
build(Lson);//递归建树
build(Rson);
upd(pos);//更新当前节点信息
}
}
&lt;/code>&lt;/pre>
&lt;h6 id="change_point函数">change_point函数&lt;/h6>
&lt;p>单点修改线段树上某一位的值&lt;/p>
&lt;pre>&lt;code class="language-c++">void cpit(int pos, int l, int r, int point, int val) //pos当前节点编号，l右端点，r左端点，point修改目标编号，val修改值
{
if (l == r) //区间长度为1，进行修改，结束递归
{
tree[pos] = val; //根据题意自行更改
return;
}
if (point &amp;lt;= Mid) //如果区间包含左儿子，递归更改
cpit(Lson, point, val);
else //如果区间包含右儿子，递归更改
cpit(Rson, point, val);
upd(pos); //更新当前节点信息
}
&lt;/code>&lt;/pre>
&lt;h6 id="check_block函数">check_block函数&lt;/h6>
&lt;p>区间(和、最大值等)查询&lt;/p>
&lt;pre>&lt;code class="language-c++">inline int fblk(int pos, int l, int r, int L, int R) //pos当前节点编号，l右端点，r左端点，L查询区间左端点，R查询区间右端点
{
if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) //当前线段树上的线段被查询区间完全包含，返回当前线段维护的信息
{
return tree[pos];
}
stg(This); //下放当前线段的标记
if (R &amp;lt;= Mid) //只包含左儿子，递归查找左儿子，直到被查询线段全部被包含
return fblk(Lson, L, R);
if (L &amp;gt; Mid) //只包含右儿子，递归查找右儿子，直到被查询线段全部被包含
return fblk(Rson, L, R);
return fblk(Lson, L, R) + fblk(Rson, L, R); //左右儿子均含有被查询区间，则同时查找两个儿子
}
&lt;/code>&lt;/pre>
&lt;h3 id="懒标记">“懒”标记&lt;/h3>
&lt;p>区间 $[l,r]$时，如果修改所有与 $[l,r]$相关的线段，那么时间复杂度将退化为 $O(n)$​。&lt;del>那还不如不写&lt;/del>&lt;/p>
&lt;p>线段树通过引入&lt;strong>懒标记&lt;/strong>把对整条线段的修改操作&lt;strong>暂存&lt;/strong>在结点上，当需要访问子节点时&lt;strong>再&lt;/strong>把修改操作应用到子结点上。&lt;/p>
&lt;p>&lt;del>真理：人类因懒而进步&lt;/del>&lt;/p>
&lt;p>针对于每个节点开一个(可能不止)标记位，注意数组长度仍为 $4n$。&lt;/p>
&lt;ul>
&lt;li>维护多个标记时注意&lt;strong>下放的顺序&lt;/strong>，保证先下放的标记不影响后下放的标记。&lt;/li>
&lt;/ul>
&lt;p>​ **例：**同时维护加法标记和乘法标记时，应先下放乘法标记，再下放加法标记。&lt;/p>
&lt;ul>
&lt;li>标记累加时注意其&lt;strong>正确性&lt;/strong>，包括是否要改变&lt;strong>其他标记&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>​ **例：**乘法标记叠加时，加法标记也应乘相应修改值。&lt;/p>
&lt;h6 id="get_tag函数">get_tag函数&lt;/h6>
&lt;p>打标签&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void gtg(int pos, int l, int r, int val) //pos当前节点编号，l右端点，r左端点，val增加量
{
tag[pos] += val; //标签累加
tree[pos] += Len * val; //维护区间和，总增加量=单点增加量*区间长度
}
&lt;/code>&lt;/pre>
&lt;h6 id="send_tag函数">send_tag函数&lt;/h6>
&lt;p>将标签下方给两个儿子&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void stg(int pos, int l, int r) //pos当前节点编号，l右端点，r左端点
{
gtg(Lson, tag[pos]); //把标签下放给左儿子
gtg(Rson, tag[pos]); //把标签下放给右儿子
tag[pos] = 0; //将pos位标签置0(标签以下放给儿子)
}
&lt;/code>&lt;/pre>
&lt;h6 id="change_block函数">change_block函数&lt;/h6>
&lt;p>区间修改&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void cblk(int pos, int l, int r, int L, int R, int val) //pos当前节点编号，l右端点，r左端点，L修改区间左端点，R右端点，val修改值
{
if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) //当前线段树上的线段被查询区间完全包含，打标记
{
gtg(This, val);
return;
}
stg(This); //若两个儿子只有一个被包含，则下方当前线段标记，更新包含修改区间的儿子
if (L &amp;lt;= Mid) //只包含左儿子，递归查找左儿子，直到被修改线段全部被包含
cblk(Lson, L, R, val);
if (R &amp;gt; Mid) //只包含右儿子，递归查找右儿子，直到被修改线段全部被包含
cblk(Rson, L, R, val);
upd(pos); //更新当前节点信息
}
&lt;/code>&lt;/pre>
&lt;h2 id="维护一些奇奇怪怪的东西">维护一些奇奇怪怪的东西&lt;/h2>
&lt;p>单表一些你想也想不到的烂七八糟的用线段树维护的东西。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>区间最大子段和&lt;/p>
&lt;ol>
&lt;li>
&lt;p>最大子段&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最大前缀&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最大后缀&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://faioj.brynhild.online/problem/21002" target="_blank" rel="noopener">序列操作&lt;/a>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>归零标记&lt;/p>
&lt;/li>
&lt;li>
&lt;p>取反标记&lt;/p>
&lt;/li>
&lt;li>
&lt;p>区间和&lt;/p>
&lt;/li>
&lt;li>
&lt;p>连续前缀0或1个数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>连续后缀0或1个数&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>………………………………&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;del>怎么样，意想不到吧&lt;/del>&lt;/p>
&lt;p>为了方便，毕竟谁也不想写 $5、6$ 个update函数去逐一维护。&lt;/p>
&lt;p>所以，C++的&lt;del>高级&lt;/del>语法 &lt;em>bulingbuling&lt;/em> 的出现了。&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&amp;gt; struck结构体 + operator运算符重载&lt;/p>
&lt;p>使用结构体记录所有需要维护的信息并通过 &lt;code>operator +&lt;/code> 实现合并能够有效降低代码难度：&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;h2 id="空间的一点儿优化动态开点线段树">空间的一点儿优化——动态开点线段树&lt;/h2>
&lt;h6 id="引子">引子&lt;/h6>
&lt;p>还是先搞一个非常形象的小&lt;del>故事&lt;/del>吧。&lt;/p>
&lt;p>​ 首先，你想象自己是一位古代的帝王；你精力旺盛，辛勤耕耘20余年，终于在后宫三千佳丽的帮助下，成功为人类的繁衍生息做出了巨大的贡献。&lt;/p>
&lt;p>​ 那么，问题来了。你的儿子女儿加在一起已经快赶上一个师~~(手动狗头)~~的规模了，而恰好你现在手里没有钱(你并不被允许使用那么多内存)，不可能让你的所有子女都住上气派辉煌的宫殿，其中大部分不受宠的就只能住在一些破旧的偏殿里(你在自己的机器中能申请到内存)。&lt;/p>
&lt;p>​ 现在，另一个国家的元首(评测机)来你国访问，你开始炫耀起你对人类所做出的贡献。这时候，正是展现国家经济军事实力、皇帝大臣精神面貌的时候，你当然不能让来访的外国人知道你手里没钱，连自己子女的房子都四处漏风，否则对方就会认为你好欺负，来攻打你(评测机返回MLE，把你的分数打掉)。&lt;/p>
&lt;p>​ 所以，你想到了一个损招：当且仅当你要展示第 $i$ 个儿子时，才把他的房子装修一下，搞好一点，装装样子。至于那些对方看不见的，就爱咋咋地。因为对方时间有限，并不会跟着你看很多的子女(然而仅有的几个住在好地方的又不够展现帝国雄风)，走访的并不会太多，因此并不需要改造太多，国家这点钱还是出得起的(你并没有MLE，骗过了评测机，评测机认为你并不好惹，给了你AC)。&lt;/p>
&lt;h6 id="该正经了">该正经了&lt;/h6>
&lt;p>当需要维护的区间很长(如 $n=10^9$)但操作次数有限(如 $m=10^5$​)时，如果建立出完整的线段树，空间复杂度为 $O(n)$，无法接受。&lt;/p>
&lt;p>但可以发现每次操作涉及到的线段数为 $O(\log{n})$级别，完成所有操作涉及到的区间个数级别为 $O(m\space\log{n})$，这是可以接受的空间开销。&lt;/p>
&lt;p>于是我们放弃之前用数组存储线段树上所有结点的做法，而是在访问到未创建结点时为其分配存储位置，这样的线段树叫做&lt;strong>动态开点线段树&lt;/strong>。&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;h2 id="线段树上二分">线段树上二分&lt;/h2>
&lt;p>~~与树状数组上二分类似，~~线段树上也可以进行二分。概括地说，线段树上二分的实质是利用线段树上当前结点及其两个子节点维护的信息快速判断要查找的位置在左右哪个区间中。由于线段树的深度为 $\log{n}$，所以线段树上二分的复杂度为 $O(\log{n})$。&lt;/p>
&lt;h2 id="权值线段树">权值线段树&lt;/h2>
&lt;p>与树状数组维护可重集合的 &lt;code>count&lt;/code> 数组类似，线段树也可以用来维护可重集合的 &lt;code>count&lt;/code> 数组，这样的线段树常被称作&lt;strong>权值线段树&lt;/strong>。在使用动态开点线段树实现权值线段树时可以放松对权值值域的限制（权值甚至可以取为负数！），这与处理较大权值时需要事先离散化的树状数组相比具有巨大的优势。&lt;/p>
&lt;h2 id="线段树优化建图">线段树优化建图&lt;/h2>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在更多更灵活的题目中，线段树等数据结构往往被用来&lt;strong>快速&lt;/strong>维护一些区间信息，即一种&lt;strong>优化暴力的手段&lt;/strong>。&lt;/p>
&lt;p>这一类问题中，数据结构的维护只是最后一步，难点往往在于想出第一步的 $O(n^2)$或 $O(nm)$的暴力。&lt;/p>
&lt;p>解决这类优化问题时，一般都是在得到暴力解法后，将&lt;strong>要实现的操作&lt;/strong>都列出来，再选择合适的数据结构维护这些操作。&lt;/p>
&lt;p>&lt;strong>考场上遇到这类题目一定要先写出暴力，拿到尽可能多的分数！！&lt;/strong>&lt;/p>
&lt;p>&lt;del>md要是遇到线段树的题，一首《凉凉》送给头秃的自己&lt;/del>&lt;/p></description></item><item><title>二分图匹配</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</guid><description>&lt;h1 id="二分图匹配">二分图匹配&lt;/h1>
&lt;h2 id="前置知识二分图">前置知识——二分图&lt;/h2>
&lt;p>首先，要明白什么是二分图(又称作二部图)。&lt;/p>
&lt;p>形象的描述一下，现在你是某市的市长，而一条大河从你的城市中心穿流而过。所以，你为了使你的城市交通遍历，促进城市发展，你决定在这条河上建桥，以连接河两岸的路口。&lt;/p>
&lt;img src="%E8%8D%89%E7%BA%B8-10.jpg" alt="pi" style="zoom: 33%;" />
&lt;p>如上图，所有河上的桥和路口就组成了一个二分图。&lt;/p>
&lt;p>二分图的定义：如果顶点 $V $ 可分割为两个互不相交的子集 $(A,B)$，并且图中的每条边 $(i，j)$ 所关联的两个顶点 $i$ 和 $j$ 分别属于这两个不同的顶点集 $(i \in A,j \in B)$，则称图G为一个二分图。简而言之，就是顶点集 $V$ 可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。&lt;/p>
&lt;p>意思就说，你把一个图的顶点分到河的两岸，图上所有的边只能是桥，不能是陆地上的公路，即不能在河的一侧修建边。&lt;/p>
&lt;img src="graph.png" alt="sdafa" style="zoom:67%;" />
&lt;p>区别二分图，关键是看点集是否能分成两个独立的点集。无向图G为二分图的&lt;strong>充要条件&lt;/strong>是，$G$ 至少有两个顶点，且其所有环的长度均为偶数，&lt;strong>不存在奇环&lt;/strong>。&lt;strong>可以存在偶环&lt;/strong>，如上图 $2\rightarrow7\rightarrow3\rightarrow8\rightarrow2$ 就是一个偶环，但上图满足二分图。任何无回路的的图均是二分图。&lt;/p>
&lt;p>**总结：**DFS/BFS，如发现奇环则不是二分图，否则是。&lt;/p>
&lt;p>&lt;a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE" target="_blank" rel="noopener">充要条件的证明(百度百科)&lt;/a>&lt;/p>
&lt;p>更简单的：因为每一条边都是从一个集合走到另一个集合，只有走偶数次才可能回到同一个集合。&lt;/p>
&lt;h2 id="最大匹配">最大匹配&lt;/h2>
&lt;p>**匹配：**从二分图中选择 $n$ 条边，保证没有任何一个顶点是两条或以上边的终点。&lt;/p>
&lt;p>一个形象的事情：&lt;/p>
&lt;p>现在你变身成为了月老，发现今天有 $n$ 个男生和 $m$ 个女生在你的庙(月老庙)前许愿求姻缘。你今天很高兴，决定帮帮他们。他们每个人祈祷的时候都说了他们心仪的对象，你将他们整理了一下，将可能(符合双方的要求 -__- )的两个人之间连一条线(假设没有gay)，建立了一个二分图。&lt;/p>
&lt;p>这时候，作为善良的你，需要履行帮助人类繁衍生息的职责，因此要促成尽可能多的情侣狗，问最多能搞成几对？&lt;/p>
&lt;p>数学表示：若 $E'\in E$，且 $E'$ 中任意两条边不共用同一个顶点，则称 $E'$ 是二分图 $G$ 的一个匹配。&lt;/p>
&lt;p>**最大匹配：**边数最多的匹配(促成的情侣狗最多)。即 $E'$ 中边数最大。&lt;/p>
&lt;p>**完美匹配：**所有向你求愿单身狗都变成了情侣狗。即 $E'=E$。&lt;/p>
&lt;h2 id="匈牙利算法寻找最大匹配">匈牙利算法——寻找最大匹配&lt;/h2>
&lt;h3 id="交替路与增广路">交替路与增广路&lt;/h3>
&lt;p>**交替路：**从一个未匹配点出发，依次经过非匹配边、匹配边，并且第一条和最后一条边均为非匹配边，形成的路径叫交替路。&lt;/p>
&lt;p>**增广路：**从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>红色的边为当前的匹配
&lt;img src="%E5%A2%9E%E5%B9%BF%E8%B7%AF1.png" alt="1" style="zoom:13%;" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>紫色的边为当前匹配的增广路
&lt;img src="%E5%A2%9E%E5%B9%BF%E8%B7%AF2.png" alt="2" style="zoom:13%;" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将增广路中匹配的边和非匹配变交换，匹配边数 $+1$
&lt;img src="%E5%A2%9E%E5%B9%BF%E8%B7%AF3.png" alt="3" style="zoom:13%;" />&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="匈牙利算法的真面目">匈牙利算法的真面目&lt;/h3>
&lt;p>匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。&lt;del>(看完的都是好宝宝)&lt;/del>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/qq_41730082/article/details/81162561?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162919822716780274126376%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=162919822716780274126376&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81162561.pc_search_result_control_group&amp;amp;utm_term=%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D&amp;amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">有意思的博文一篇&lt;/a>&lt;/p>
&lt;p>简单一点，就是一个不断逼近答案的过程。&lt;/p>
&lt;p>对于每个节点，执行如下步骤：&lt;/p>
&lt;ol>
&lt;li>如果连接这个节点的任何一条边可以被选中，则将这条边加入匹配，返回TRUE。&lt;/li>
&lt;li>如果莫得可以加入的边了，那么可以推导出连接它的所有边均为非匹配边。然后开始逐个寻找增广路，直到全部遍历完成(返回FALSE)或者把其中的某一条边加入匹配(即找到了一条增广路，返回TRUE)。&lt;/li>
&lt;/ol>
&lt;p>&lt;del>这个东西的烦人之处在于这玩意的代码………………难以理解，需得手推&lt;/del>&lt;/p>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3386" target="_blank" rel="noopener">洛谷P3386&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;vector&amp;gt;
const int maxe = 600;
int n, m, e, ans, pot[maxe]; //一共有n个男生,m个女生,共e条边,pot[i]表示第i个女生属于的男生编号
std::bitset&amp;lt;maxe&amp;gt; vis; //标记是否访问过(名花有主)
std::vector&amp;lt;int&amp;gt; con[maxe]; //以男生的角度记录这张图(因为要遍历男生找女生)
inline bool dfs(int now)
{
for (auto i : con[now]) //遍历他有好感的所有女生
{
if (!vis[i]) //如果这个女生现在莫得npy
{
vis[i] = 1; //表示你就是我的了
if (!pot[i] || dfs(pot[i])) //如果你原先没有npy或者前男友鱼塘里还有
{
pot[i] = now; //你现在彻底是我的了
return true; //表示我找到npy了(-_-)
}
}
}
return false; //我没有找到(T_T)
}
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;e);
for (int i = 0; i &amp;lt; e; i++)
{
int a, b;
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
con[a].push_back(b);
}
for (int i = 1; i &amp;lt;= n; i++)
{
vis.reset(); //每次都重新分配
if (dfs(i)) //如果现在的这个男生找到了npy,就又多了一对情侣
ans++;
}
printf(&amp;quot;%d&amp;quot;, ans);
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>时间复杂度 $O(nm)$ 。&lt;/p>
&lt;h2 id="最大匹配的引申">最大匹配的引申&lt;/h2>
&lt;h3 id="最小边覆盖-n---最大匹配">最小边覆盖= n - 最大匹配&lt;/h3>
&lt;p>一个边集里的边能覆盖所有的点，最小边覆盖是满足这个要求的所有边集中边数最少的一个。&lt;/p>
&lt;p>&lt;strong>证明：&lt;/strong>&lt;/p>
&lt;p>因为边数越小越好，则每条边能覆盖的点一定是越多越好(尽量每条边都覆盖2个点)，而最大匹配找出了最多覆盖2个点的边。而剩下的就只能一条边覆盖一个点了。&lt;/p>
&lt;p>所以，设总顶点数为 $n$，最大匹配边为 $m$，则可以得到
$$
最小边覆盖=m+(n-2m)=n-m
$$&lt;/p>
&lt;h3 id="最小点覆盖--最大匹配">最小点覆盖 = 最大匹配&lt;/h3>
&lt;p>**最小点覆盖：**假如选了一个点就相当于覆盖了以它为端点的所有边。最小点覆盖就是选择最少的点来覆盖所有的边。&lt;/p>
&lt;p>**证明：**由最大匹配可知，不存在一条边的两个端点均没有被在最大匹配集合中的边所连接的情况(否则这条边就可以加入匹配)。因此，我们可以将边分为两类：匹配边和非匹配边；也可以将点分为两类：是匹配边的端点和不是匹配边的端点。&lt;/p>
&lt;img src="%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96.png" alt="df" style="zoom:13%;" />
&lt;p>如上图，&lt;font color="red">匹配边&lt;/font>，非匹配边，&lt;font color="purple">匹配边的端点&lt;/font>，&lt;font color="green">不是匹配边的端点&lt;/font>。&lt;/p>
&lt;p>在&lt;font color="purple">匹配边的端点&lt;/font>中选择有相邻&lt;font color="green">不是匹配边的端点&lt;/font>的点即可。&lt;/p>
&lt;p>这样的点保证之多有最大匹配个。&lt;/p>
&lt;p>首先，我们只要没傻到在同一条&lt;font color="red">匹配边&lt;/font>上选择两个点就行，这样，所有的&lt;font color="red">匹配边&lt;/font>均可被覆盖。&lt;/p>
&lt;p>同一条&lt;font color="red">匹配边&lt;/font>上的端点不可能同时与&lt;font color="green">不是匹配边的端点&lt;/font>相邻，否则构成一条增广路(如上图，若有11号节点与9号节点连接，则 $11\rightarrow9\rightarrow5\rightarrow10$ 构成增广路)。&lt;/p>
&lt;p>因此，最小点覆盖 = 最大匹配。&lt;/p>
&lt;h3 id="最大独立集--n---最小点覆盖">最大独立集 = n - 最小点覆盖&lt;/h3>
&lt;p>选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。找出一个包含顶点数最多的独立集称为最大独立集。&lt;/p>
&lt;p>**证明：**去掉最小点覆盖的顶点后，所有点之间不连通(因为删去最小点覆盖保证所有边均删除，因此不会出现连通)。&lt;/p>
&lt;h3 id="最小不可重链覆盖">最小不可重链覆盖&lt;/h3>
&lt;h3 id="有权最大匹配等">有权最大匹配等&lt;/h3>
&lt;p>参见&lt;a href="">网络流&lt;/a>和&lt;a href="">费用流&lt;/a>。&lt;/p></description></item><item><title>ST表</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/st%E8%A1%A8/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/st%E8%A1%A8/</guid><description/></item><item><title>溶解性表</title><link>https://xuxihe.vercel.app/courses/chemistry/%E6%BA%B6%E8%A7%A3%E6%80%A7%E8%A1%A8/</link><pubDate>Thu, 18 Nov 2021 20:52:27 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/%E6%BA%B6%E8%A7%A3%E6%80%A7%E8%A1%A8/</guid><description>&lt;h2 id="表格">表格&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">离子&lt;/th>
&lt;th style="text-align:center">$\ce{OH-}$&lt;/th>
&lt;th style="text-align:center">$\ce{NO^-3}$&lt;/th>
&lt;th style="text-align:center">$\ce{Cl-}$&lt;/th>
&lt;th style="text-align:center">$\ce{SO^2-_4}$&lt;/th>
&lt;th style="text-align:center">$\ce{CO^2-_3}$&lt;/th>
&lt;th style="text-align:center">$\ce{S^2-}$&lt;/th>
&lt;th style="text-align:center">$\ce{SO^2-_3}$&lt;/th>
&lt;th style="text-align:center">$\ce{SiO^2-_3}$&lt;/th>
&lt;th style="text-align:center">$\ce{PO^3-_4}$&lt;/th>
&lt;th style="text-align:center">$\ce{CH3COO-}(\ce{Ac-})$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">$\ce{H+}$&lt;/td>
&lt;td style="text-align:center">&lt;font color="blue">$\ce{H2O}$&lt;/font>&lt;/td>
&lt;td style="text-align:center">溶、挥&lt;/td>
&lt;td style="text-align:center">溶、挥&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶、挥&lt;/td>
&lt;td style="text-align:center">溶、挥&lt;/td>
&lt;td style="text-align:center">溶、挥&lt;/td>
&lt;td style="text-align:center">微&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{NH+4}$&lt;/td>
&lt;td style="text-align:center">溶、挥&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">——&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{K+}$&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Na+}$&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Ba^2+}$&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">——&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Ca^2+}$&lt;/td>
&lt;td style="text-align:center">&lt;strong>微&lt;/strong>&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">微&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">——&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Mg^2+}$&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">&lt;strong>微&lt;/strong>&lt;/td>
&lt;td style="text-align:center">——&lt;/td>
&lt;td style="text-align:center">&lt;strong>微&lt;/strong>&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Al^3+}$&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">——&lt;/td>
&lt;td style="text-align:center">——&lt;/td>
&lt;td style="text-align:center">——&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Mn^2+}$&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Zn^2+}$&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Fe^2+}$&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Fe^3+}$&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">——&lt;/td>
&lt;td style="text-align:center">——&lt;/td>
&lt;td style="text-align:center">——&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Cu^2+}$&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Ag+}$&lt;/td>
&lt;td style="text-align:center">——&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">&lt;strong>微&lt;/strong>&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Pb^2+}$&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;td style="text-align:center">&lt;strong>微&lt;/strong>&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">不&lt;/td>
&lt;td style="text-align:center">溶&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>说明：&lt;/strong>“溶”表示某种物质可溶于水，“不”表示不溶于水，“微”表示微溶于水，“挥”表示挥发性，“——”表示那种物质不存在或遇到水就分解了，为空表示一般用不到 &lt;del>(用的时候再说)&lt;/del>。&lt;/p>
&lt;h2 id="背诵方法">背诵方法(?)&lt;/h2>
&lt;p>&lt;del>其实可以看做是个概括总结&lt;/del>&lt;/p>
&lt;p>钾钠硝铵醋可溶，氯除银铅(微溶)均可溶。&lt;/p>
&lt;p>氢氧只溶钾钠钡(钙微溶)，硫酸沉钙(微溶)钡银铅。&lt;/p>
&lt;p>碳亚硫硅磷酸硫，除钾钠铵均不溶。&lt;/p>
&lt;p>银除硝酸都不溶(硫酸银微溶)，单独记忆五微溶。&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>test</title><link>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/test/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/test/</guid><description>&lt;p>$$
\left\{\begin{aligned}
a=b\newline b=c \newline c=a
\end{aligned}\right.
$$&lt;/p></description></item><item><title>字典树</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%A0%91/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%A0%91/</guid><description>&lt;h1 id="字典树">字典树&lt;/h1>
&lt;h2 id="这是一棵神奇的树">这是一棵神奇的树&lt;/h2>
&lt;p>&lt;del>字典树，顾名思义，就是一个字典。&lt;/del>&lt;/p>
&lt;p>字典树，又称前缀树，作用是储存一些字符串……方便查询与修改。&lt;/p>
&lt;p>具体来说，就是将每一个字符串变成树上的一条链，从 $root$ 到每个叶子节点就是我们要储存的一个字符串。&lt;/p>
&lt;p>举个栗子，我们要储存 $ababa$ 、$badab$ 、$adace$ 、$abace$ 、$cdeab$ 、$abcab$ 、$ccc$ ，就是下图：&lt;/p>
&lt;img src="%E5%AD%97%E5%85%B8%E6%A0%91.png" alt="fa" style="zoom:80%;" />
&lt;p>当然，我们也可以在边上存储字符，具体操作可按照个人喜好来搞，均可以实现字典树的种种操作。&lt;/p>
&lt;p>对于字符串 $aba$ 改如何储存呢？很简单，在其结尾打一个 $tag$ 即可。&lt;/p>
&lt;h2 id="基本操作">基本操作&lt;/h2>
&lt;p>注意，我们下面讨论的都是节点存储字符的情况，而并非字符存储在边上。&lt;del>其实都差不多，就是如何理解的问题。&lt;/del>&lt;/p>
&lt;h3 id="结构">结构&lt;/h3>
&lt;pre>&lt;code class="language-c++">int tot; //记录总节点个数，用于分配新的节点
struct node //每个节点储存节点编号、节点上的字符和是否是结尾
{
int id;
char val;
bool tag;
};
std::vector&amp;lt;node&amp;gt; next[maxe]; //储存每个节点的儿子,便于查找
&lt;/code>&lt;/pre>
&lt;h3 id="插入">插入&lt;/h3>
&lt;pre>&lt;code class="language-c++">inline void ins(char *in) //本来应该是dfs的,只不过优化为循环了
{
int now = 0, len = strlen(in); //标记当前节点的编号,字符串的长度
for (int i = 0; i &amp;lt; len; i++)
{
int ci = next[now].size(); //遍历子节点
bool is = 0; //记录是否找到可以用的链
for (int j = 0; j &amp;lt; ci; j++)
{
if (next[now][j].val == in[i])
{
if (i == len - 1) //如果是字符串结尾就打tag
next[now][j].tag = 1;
is = 1;
now = next[now][j].id; //跳转到这个儿子，继续ins
break;
}
}
if (!is) //如果没有匹配的节点,就要新建一个
{
next[now].push_back(node{++tot, in[i], i == len - 1 ? true : false});
now = tot; //跳转到新建的节点
}
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="查找">查找&lt;/h3>
&lt;pre>&lt;code class="language-c++">inline bool find(char *in) //本来应该是dfs的,只不过优化为循环了
{
int now = 0, len = strlen(in); //标记当前节点的编号,字符串的长度
for (int i = 0; i &amp;lt; len; i++)
{
int ci = next[now].size(); //遍历子节点
bool is = 0; //记录是否找到可以用的链
for (int j = 0; j &amp;lt; ci; j++)
{
if (next[now][j].val == in[i])
{
is = 1; //标记找到了
if (i == len - 1) //如果是结尾,则判断是否有tag(若没有,就是字典中某个字符串的前缀)
is = next[now][j].tag;
now = next[now][j].id;
break;
}
}
if (!is) //如果没找到合适的子节点,说明树中没有这个字符串
return false;
if (i == len - 1) //如果全部匹配,则字典中有所查询的字符串
return true;
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="另一种">另一种&lt;/h3>
&lt;p>我们还可以按照边来储存字符，并且我们可以在一定程度上用时间换空间(其实只是减小了常数)。&lt;/p>
&lt;p>直接对于每个节点开出字符范围大小的数组，对应位置储存对应字符的儿子节点(如果有的话)，这样就省去了查找子节点是啥子的时间，但是同时要在空间上做出一定的牺牲，适用于字符范围较小的字典。&lt;/p>
&lt;p>&lt;a href="http://faioj.brynhild.online/problem/30034" target="_blank" rel="noopener">FaiOJ #30034. 「一本通 2.1 例 2」图书管理&lt;/a> &lt;del>就是板子&lt;/del>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
struct node
{
int next[60];//我们直接开出全部字符范围,然后按照下标存储
bool tag; //0~29 30~59
} nodes[3000000];
int root = 1, tot = 1;
inline void ins(char *in)
{
int pos = root, val;//val就是让你省一点代码
for (; *in; ++in) //这玩意和 for(int i = 0;i &amp;lt; len;i++)一个意思
{
val = (*in) &amp;gt;= 'A' &amp;amp;&amp;amp; (*in) &amp;lt;= 'Z' ? (*in) - 'A' : (*in) - 'a' + 30;//找到相对应的下标
if (!nodes[pos].next[val])//没有这个节点
nodes[pos].next[val] = ++tot;
pos = nodes[pos].next[val];//跳转到下一个,继续插入
}
nodes[pos].tag = true;//结尾打tag
}
inline bool find(char *in)
{
int pos = root, val;
for (; *in; ++in)
{
val = (*in) &amp;gt;= 'A' &amp;amp;&amp;amp; (*in) &amp;lt;= 'Z' ? (*in) - 'A' : (*in) - 'a' + 30;
if (!nodes[pos].next[val])
return false;
pos = nodes[pos].next[val];
}
return nodes[pos].tag&amp;gt;0?true:false;
}
int len;
char ord[10], name[500];
int main()
{
scanf(&amp;quot;%d&amp;quot;, &amp;amp;len);
while (len--)
{
scanf(&amp;quot;%s %[^\n]&amp;quot;, ord, name);
if (ord[2] == 'd')
ins(name);
else
printf(&amp;quot;%s\n&amp;quot;, find(name) ? &amp;quot;yes&amp;quot; : &amp;quot;no&amp;quot;);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="这玩意能干啥">这玩意能干啥&lt;/h2>
&lt;p>字典树因为其特有的结构，在大量字符串的查找、修改、比较中有较大的优势。&lt;/p>
&lt;p>还可以进行转化，用于比较二进制($k$进制)下的数字大小等。亦可以用于关于前缀的若干问题。&lt;/p>
&lt;p>但是，还是那句话，数据结构都是用来在暴力的情况下进行优化的……&lt;/p>
&lt;h1 id="01-trie">$01$​-Trie&lt;/h1>
&lt;h2 id="没错这个东西用来搞二进制的">没错，这个东西用来搞二进制的&lt;/h2>
&lt;p>&lt;strong>01-trie&lt;/strong>是将整数的二进制表示（位数固定，补前导零）看做一个字符串，按二进制位&lt;strong>从高到低&lt;/strong>的顺序插入构建出的字符集为 ${0,1}$ 的字典树。&lt;/p>
&lt;p>事实上，与平衡树类似，01-trie也可以用于维护一个有序集合，支持插入、删除、数查排名、排名查数等操作。但由于空间开销大等原因，很少见到这样使用01-trie的OI选手。&lt;del>(我会&lt;a href="./%e5%b9%b3%e8%a1%a1%e6%a0%91.md">平衡树&lt;/a>，还要这玩意干屁)&lt;/del>&lt;/p>
&lt;p>01-trie 最常见的应用是快速计算数 $x$ 与字典树中所有数异或结果的&lt;strong>最大值&lt;/strong>或最小值。以最大值为例，具体的做法是从树根开始（即按二进制位从高到低）贪心：&lt;/p>
&lt;ul>
&lt;li>若存在与 $x$ 当前位上的值相反的边，则走这条边，使这一位的异或结果成为 $1$；&lt;/li>
&lt;li>若不存在，则走相同的边，使这一位的异或结果为 $0$。&lt;/li>
&lt;/ul>
&lt;p>答案从高位到低位~~(说话算数的到说话不算数的)~~依次构造，正确性显然。&lt;/p>
&lt;h2 id="板子">板子&lt;/h2>
&lt;p>&lt;a href="http://faioj.brynhild.online/problem/30050" target="_blank" rel="noopener">FaiOJ #30050. 「一本通 2.3 例 2」The XOR Largest Pair&lt;/a>&lt;/p></description></item><item><title>差分约束</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</guid><description>&lt;p>&lt;a href="https://blog.csdn.net/consciousman/article/details/53812818?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162925274616780265475802%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=162925274616780265475802&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53812818.pc_search_result_control_group&amp;amp;utm_term=%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F&amp;amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">难懂但是比较全的博文&lt;/a>&lt;/p>
&lt;h2 id="这是啥子">这是啥子?&lt;/h2>
&lt;p>简单来说，差分约束就是把不等式转变成图的一种思想。因为题目可能会给你很多不等式，使用数学方法很有可能无解，而且难以找到这些不等式之间的联系。但是当我们把它们转化成图之后，就可以使用图论的思想来解题。&lt;/p>
&lt;p>通常，差分约束是用来解决求一组形如 $a-b\leq{c}$ 的不等式的可能最大/最小解。&lt;/p>
&lt;p>对于每一个 $i-j\le z$，建立一条从 $j$ 到 $i$ 权值为 $z$ 的有向边，将求解 $a-b\le{c}$ 的最大/最小值转化为求从 $b$ 到 $a$ 的最短/最长路径长度。&lt;/p>
&lt;h2 id="三角不等式">三角不等式&lt;/h2>
&lt;p>若有一个不等式组：&lt;/p>
&lt;p>$$
\begin{cases}\begin{aligned}\begin{array}{rcl}
&amp;amp;C-B\le{a}\newline&amp;amp;C-A\le{b}\newline&amp;amp;B-A\le{c}
\end{array}\end{aligned}\end{cases}
$$&lt;/p>
&lt;p>则根据上述条件，可以建图如下：&lt;/p>
&lt;img src="graph.png" alt="adf" style="zoom:95%;" />
&lt;p>由不等式相加组合，可得到 $max(C-A)=min(b,a+c)$，这也正好对应图中 $A$ 到 $C$ 的最短路。&lt;/p>
&lt;p>对于最大值：
$$
\begin{aligned}
\begin{cases}\begin{array}{rcl}
&amp;amp;C-B\ge{a}\newline&amp;amp;C-A\ge{b}\newline&amp;amp;B-A\ge{c}
\end{array}
\end{cases}
\end{aligned}
$$
由不等式相加组合，可得到 $min(C-A)=max(b,a+c)$，这也正好对应图中 $A$ 到 $C$ 的最长路。&lt;/p>
&lt;p>因此，对三角不等式加以推广，变量 $n$ 个，不等式 $m$ 个，要求 $C-A$ 的最大/最小值，便就是求取建图后 $A-C$ 的最短/最长路。&lt;/p>
&lt;p>另：&lt;/p>
&lt;ol>
&lt;li>若出现 $C-A=b$ 的情况，可以拆分为 $C-A\ge{b}$ 和 $C-A\le{b}=A-C\ge{-b}$ 或 $C-A\ge{b}=A-C\le{-b}$ 和 $C-A\le{b}$ 两条边。&lt;/li>
&lt;li>若出现 $C-A&amp;gt;b$的情况，因为题目中大多是整形数据，因此变为 $C-A\ge{b+1}$ 即可。&lt;/li>
&lt;li>值得注意的一点是：若建立的图不联通，则需要加入一个超级源点 $S$，在 $S$ 和其他的每个点之间建立一条权值为 $0$ 的&lt;strong>无向边&lt;/strong>，然后从 $S$ 点开始求解即可。&lt;/li>
&lt;/ol>
&lt;h2 id="无名算法">无名算法&lt;/h2>
&lt;p>流程：&lt;/p>
&lt;ol>
&lt;li>构建基于不等式的关系图。&lt;/li>
&lt;li>跑&lt;a href="./%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84.md">最短路&lt;/a>(注意，最长路可以通过spfa求出来，只需要改下松弛的方向即可，即&lt;code>if(dis[v] &amp;lt; dis[u] + val(u,v)) dis[v] = dis[u] + val(u,v)&lt;/code>。当然我们可以把图中所有的边权取负，求取最短路，两者是等价的。)&lt;/li>
&lt;li>建图后不一定存在最短路/最长路，因为可能存在负环/正环，判断差分约束系统是否存在解一般判环即可。&lt;/li>
&lt;/ol>
&lt;p>一些注意事项：&lt;/p>
&lt;ol>
&lt;li>根据条件把题意通过变量组表达出来得到不等式组，注意要发掘出隐含的不等式，比如说前后两个变量之间隐含的不等式关系。&lt;/li>
&lt;li>建好图之后直接spfa求解，一般不能用dijstra算法，因为通常存在负边。&lt;/li>
&lt;li>注意初始化的问题。&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P5960" target="_blank" rel="noopener">洛谷P5960&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>分散系</title><link>https://xuxihe.vercel.app/courses/chemistry/%E5%88%86%E6%95%A3%E7%B3%BB/</link><pubDate>Mon, 13 Dec 2021 21:52:27 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/%E5%88%86%E6%95%A3%E7%B3%BB/</guid><description>&lt;h2 id="定义">定义&lt;/h2>
&lt;p>把一种（或多种）物质以粒子的形式分散到另一种（或多种）物质中所形成的混合物。&lt;/p>
&lt;p>**分散质：**被分散成粒子的物质。&lt;/p>
&lt;p>**分散剂：**另一种物质。&lt;/p>
&lt;h2 id="分类">分类&lt;/h2>
&lt;p>根据分散质粒子直径的大小。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">粒子直径&lt;/th>
&lt;th style="text-align:center">分散系名称&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">$\pu{&amp;lt; 1nm}$&lt;/td>
&lt;td style="text-align:center">溶液&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\pu{1nm}\sim\pu{100nm}$&lt;/td>
&lt;td style="text-align:center">胶体&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{&amp;gt;100nm}$&lt;/td>
&lt;td style="text-align:center">浊液&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>本质区别：粒子直径。&lt;/p>
&lt;h3 id="溶液">溶液&lt;/h3>
&lt;p>均一、稳定、透明。&lt;/p>
&lt;p>能透过滤纸和半透膜。&lt;/p>
&lt;h3 id="胶体">胶体&lt;/h3>
&lt;h4 id="组成">组成&lt;/h4>
&lt;p>单个高分子/多分子集合。&lt;/p>
&lt;h4 id="分类-1">分类&lt;/h4>
&lt;p>根据分散剂种类。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">分散剂种类&lt;/th>
&lt;th style="text-align:center">分散系名称&lt;/th>
&lt;th style="text-align:center">实例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">固体&lt;/td>
&lt;td style="text-align:center">固溶胶&lt;/td>
&lt;td style="text-align:center">有色玻璃&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">液体&lt;/td>
&lt;td style="text-align:center">液溶胶&lt;/td>
&lt;td style="text-align:center">$\ce{Fe(OH)3}$ 胶体&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">气体&lt;/td>
&lt;td style="text-align:center">气溶胶&lt;/td>
&lt;td style="text-align:center">云、雾&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="性质">性质&lt;/h4>
&lt;h5 id="稳定性">稳定性&lt;/h5>
&lt;p>**介稳性：**均一、稳定&lt;/p>
&lt;h6 id="原因">原因&lt;/h6>
&lt;p>某些特定的带点粒子（胶粒带电，胶体不带电）&lt;/p>
&lt;ol>
&lt;li>正电
&lt;ul>
&lt;li>金属氧/氢氧化物&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>负电
&lt;ul>
&lt;li>非金属氧化物&lt;/li>
&lt;li>金属硫化物&lt;/li>
&lt;li>硅酸&lt;/li>
&lt;li>土壤&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不带电&lt;/li>
&lt;li>不确定&lt;/li>
&lt;/ol>
&lt;h5 id="电泳">电泳&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">原理&lt;/th>
&lt;th style="text-align:center">现象&lt;/th>
&lt;th style="text-align:center">备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">胶粒在外加电场的作用下进行定向运动&lt;/td>
&lt;td style="text-align:center">正（阴）/负（阳）极颜色加深（不聚沉）&lt;/td>
&lt;td style="text-align:center">不能区别溶液和胶体；不适用于固溶胶&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5 id="聚沉">聚沉&lt;/h5>
&lt;ol>
&lt;li>长时间加热&lt;/li>
&lt;li>加入带有相反电荷的粒子（血型、墨水）&lt;/li>
&lt;li>加电解质（豆浆制豆腐、三角洲的形成、向 $\ce{FeCl3}$ 中滴加稀硫酸先沉淀后溶解）&lt;/li>
&lt;/ol>
&lt;h5 id="半透膜">半透膜&lt;/h5>
&lt;p>胶体能透过滤纸，不能透过半透膜。&lt;/p>
&lt;h6 id="常见半透膜">常见半透膜&lt;/h6>
&lt;ol>
&lt;li>动物肠衣膜&lt;/li>
&lt;li>羊皮纸&lt;/li>
&lt;li>玻璃纸&lt;/li>
&lt;li>胶带薄膜&lt;/li>
&lt;/ol>
&lt;h6 id="分离小分子与胶体">分离小分子与胶体&lt;/h6>
&lt;p>把混有小分子杂质的胶体装入半透膜，并浸入溶剂中，渗析使杂质从胶体中分离，提纯胶体。&lt;/p>
&lt;h5 id="吸附性">吸附性&lt;/h5>
&lt;p>吸附水中的杂质，使之沉降。&lt;/p>
&lt;ol>
&lt;li>明矾( $\ce{KAl(SO4)2*12H2O}$ )：水解为 $\ce{Al(OH)3}$ 胶体。&lt;/li>
&lt;li>铁剂( $\ce{Fe2(SO4)3}$ 和 $\ce{FeCl3}$ )：生成为 $\ce{Fe(OH)3}$ 胶体。&lt;/li>
&lt;/ol>
&lt;h4 id="应用">应用&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>医学&lt;/p>
&lt;ul>
&lt;li>血液透析（渗析）&lt;/li>
&lt;li>凝血 $\ce{FeCl3}$ （聚沉）&lt;/li>
&lt;li>血型（聚沉）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>自然界&lt;/p>
&lt;ul>
&lt;li>三角洲（聚沉）&lt;/li>
&lt;li>清晨光线（丁达尔效应）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>工农业生产&lt;/p>
&lt;ul>
&lt;li>土壤保肥
&lt;ul>
&lt;li>$\ce{NO^-3}$ 肥效差，$\ce{NH^+4}$ 肥效好&lt;/li>
&lt;li>盐碱地保肥性差（聚沉）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>净水&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="浊液">浊液&lt;/h3>
&lt;p>不均一、不稳定。&lt;/p>
&lt;ol>
&lt;li>悬浊液：固体分散质&lt;/li>
&lt;li>乳浊液：液体分散质&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>01分数规划</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/</guid><description>&lt;h1 id="01分数规划">01分数规划&lt;/h1>
&lt;h2 id="问题">问题&lt;/h2>
&lt;p>使两个线性函数的比值最大或最小的问题，称作分数规划问题或双曲线问题。&lt;/p>
&lt;p>而01分数规划和01背包问题差不多：&lt;/p>
&lt;p>我们现在有 $n$ 个物品，每一个物品均有一个 $val$ 和 $cost$，$x_i\in[0,1]$ 表示第 $i$ 物品是(1)否(0)选择。&lt;/p>
&lt;p>从 $n$ 个物品必须选择 $k$ 个，求下式的最大/最小值。
$$
\frac{\sum_{i=1}^nval_i\times{x_i}}{\sum_{i=1}^ncost_i\times{x_i}}
$$&lt;/p>
&lt;h2 id="二分解法">二分解法&lt;/h2>
&lt;p>&lt;a href="https://xuxihe.vercel.app/oiblogs/basic%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3/%e5%88%86%e6%b2%bb/">二分在这边&lt;/a>&lt;/p>
&lt;p>假设答案为 $ans$
$$
ans=min(\frac{\sum_{i=1}^nval_i\times{x_i}}{\sum_{i=1}^ncost_i\times{x_i}})
$$
则一定有
$$
ans\times{\sum_{i=1}^ncost_i\times{x_i}}=\sum_{i=1}^nval_i\times{x_i}
$$
即
$$
\sum_{i=1}^nval_i\times{x_i}-ans\times{\sum_{i=1}^ncost_i\times{x_i}}=0
$$
所以，将每个物品的权值置为 $v-r\times{c}$，排序后，判断前k个物品的权值和与 $0$ 比较，进而缩小二分界限，得出 $ans$ 值。&lt;/p>
&lt;h1 id="最大比率环">最大比率环&lt;/h1>
&lt;p>和01分数规划思路基本相同，建立好模型后二分答案。&lt;/p>
&lt;p>通过判断图内是否存在负环来调整二分界限&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://img-blog.csdnimg.cn/20210213120449912.png" alt="fa" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title>Hash表</title><link>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hash%E8%A1%A8/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hash%E8%A1%A8/</guid><description/></item><item><title>坐标距离</title><link>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%9D%90%E6%A0%87%E8%A1%A8%E7%A4%BA%E6%B3%95/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%9D%90%E6%A0%87%E8%A1%A8%E7%A4%BA%E6%B3%95/</guid><description>&lt;h1 id="坐标之间的常用距离">坐标之间的常用距离&lt;/h1>
&lt;p>通常，OI中使用到的两点之间坐标(针对于维度大于一的坐标系)通常用如下三种。&lt;/p>
&lt;h2 id="欧几里得距离">欧几里得距离&lt;/h2>
&lt;p>定义为&lt;strong>以两点为端点的线段的长度&lt;/strong>。&lt;/p>
&lt;p>如下图，欧几里得距离为&lt;font color="red">线段d&lt;/font>的长度。&lt;/p>
&lt;img src="geogebra-export.png" alt="adf" style="zoom:16%;" />
&lt;p>$S=\sqrt{\abs{1-3}^2+\abs{5-2}^2}\approx3.61$&lt;/p>
&lt;h2 id="曼哈顿距离">曼哈顿距离&lt;/h2>
&lt;p>两点 $x,y,z\space\cdots\cdots$ 坐标差的绝对值之和。&lt;/p>
&lt;p>如下图，曼哈顿距离为&lt;font color="red">线段d和线段g&lt;/font>的长度之和。&lt;/p>
&lt;img src="geogebra-export-16292841405421.png" alt="adsf" style="zoom:16%;" />
&lt;p>$S=\abs{5-2}+\abs{1-3}=3+2=5$&lt;/p>
&lt;h2 id="切比雪夫距离">切比雪夫距离&lt;/h2>
&lt;p>两点 $x,y,z\space\cdots\cdots$ 坐标差的绝对值的最大值。&lt;/p>
&lt;p>如下图，切比雪夫距离为&lt;font color="red">线段d和线段g&lt;/font>中长度较大的那一个，即&lt;font color="red">线段d&lt;/font>。&lt;/p>
&lt;img src="geogebra-export-16292841405421.png" alt="fa" style="zoom:16%;" />
&lt;p>$S=max(\abs{5-2},\abs{1-3})=max(3,2)=3$&lt;/p>
&lt;h2 id="坐标转化">坐标转化&lt;/h2>
&lt;p>一般提示距离的字眼：&lt;/p>
&lt;ul>
&lt;li>**欧几里得距离：**平面最短距离。&lt;/li>
&lt;li>**曼哈顿距离：**从一个点出发，可以上下左右移动到另一点，移动的最小步数。&lt;/li>
&lt;li>**切比雪夫距离：**从一个点出发，可以向八个方向（包括斜向）移动，移动点最小步数。(因为斜着移动同时改变两个坐标)&lt;/li>
&lt;/ul>
&lt;p>曼哈顿距离和切比雪夫距离之间可以通过坐标的变换进行相互转化：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>将每一个点 $(x,y)$ 转化为 $(x+y,x−y)$ ，新坐标系下的切比雪夫距离即为原坐标系下的曼哈顿距离。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将每一个点 $(x,y)$ 转化为 $(\frac{x+y}{2},\frac{x−y}{2})$，新坐标系下的曼哈顿距离即为原坐标系下的切比雪夫距离。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;del>这一段背住得了，&lt;a href="https://zhuanlan.zhihu.com/p/32878257" target="_blank" rel="noopener">证明&lt;/a>不看也罢。&lt;/del>&lt;/p></description></item><item><title>电解质</title><link>https://xuxihe.vercel.app/courses/chemistry/%E7%94%B5%E8%A7%A3%E8%B4%A8/</link><pubDate>Thu, 18 Nov 2021 20:57:24 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/%E7%94%B5%E8%A7%A3%E8%B4%A8/</guid><description>&lt;h2 id="酸">酸&lt;/h2>
&lt;h3 id="强酸">强酸&lt;/h3>
&lt;p>$\ce{HCl}$ 、$\ce{H2SO4}$ 、$\ce{HNO3}$ 、$\ce{HClO4}$(高氯酸) 、$\ce{HI}$(氢碘酸) 、$\ce{HBr}$(氢溴酸)&lt;/p>
&lt;h3 id="中强酸">中强酸&lt;/h3>
&lt;p>$\ce{H2SO3}$(亚硫酸) 、$\ce{H3PO4}$(磷酸) 、$\ce{H2C2O4}$(草酸)&lt;/p>
&lt;h3 id="较弱酸">较弱酸&lt;/h3>
&lt;p>$\ce{H2CO3}$ 、$\ce{CH3COOH}$(醋酸，又写作 $\ce{HAc}$ ) 、$\ce{HF}$(氢氟酸)&lt;/p>
&lt;h3 id="弱酸">弱酸&lt;/h3>
&lt;p>$\ce{H2S}$(氢硫酸) 、$\ce{HClO}$(次氯酸) 、$\ce{H2SiO3}$(硅酸)&lt;/p>
&lt;h2 id="碱">碱&lt;/h2>
&lt;h3 id="强碱">强碱&lt;/h3>
&lt;p>$\ce{KOH}$ 、$\ce{NaOH}$ 、$\ce{Ca(OH)2}$ 、$\ce{Ba(OH)2}$&lt;/p>
&lt;h3 id="弱碱">弱碱&lt;/h3>
&lt;p>$\ce{NH3*H2O}$ 、难溶性的碱&lt;/p>
&lt;h2 id="盐">盐&lt;/h2>
&lt;p>大部分盐都是电解质。&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>氧化还原</title><link>https://xuxihe.vercel.app/courses/chemistry/%E6%B0%A7%E5%8C%96%E8%BF%98%E5%8E%9F/</link><pubDate>Thu, 18 Nov 2021 20:59:03 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/%E6%B0%A7%E5%8C%96%E8%BF%98%E5%8E%9F/</guid><description>&lt;h2 id="氧化剂">氧化剂&lt;/h2>
&lt;h3 id="常见氧化剂">常见氧化剂&lt;/h3>
&lt;ol>
&lt;li>活泼型较强的非金属单质：$\ce{O2}$ 、$\ce{Cl2}$ 等。&lt;/li>
&lt;li>变价元素的最高价态化合物：$\ce{HNO3}$ 、$\ce{FeCl3}$ 、$\ce{KMnO4}$ 等。&lt;/li>
&lt;li>其他：$\ce{HClO}$ 、$\ce{H2O2}$ 等。&lt;/li>
&lt;/ol>
&lt;h3 id="强氧化剂">强氧化剂&lt;/h3>
&lt;p>$\ce{MnO4- -&amp;gt;[失 3e-] MnO2}$ 、$\ce{ClO- -&amp;gt;[失 e-] 1/2Cl2}$ 、$\ce{Fe^3+ -&amp;gt;[失 e-] Fe^2+}$ 、$\ce{NO^-3 + H+ -&amp;gt;[] NO}$ 、$\ce{Cr2O7^2- -&amp;gt;[] }$&lt;/p>
&lt;h3 id="氧化性">氧化性&lt;/h3>
&lt;p>$\ce{I2-&amp;gt;[失 2e-]2I-}$ &lt;font color=red size=5> &amp;lt; &lt;/font> $\ce{Fe^3+-&amp;gt;[失 e-]Fe^2+}$ &lt;font color=red size=5> &amp;lt; &lt;/font> $\ce{Br2-&amp;gt;[失 2e-]2Br-}$ &lt;font color=red size=5> &amp;lt; &lt;/font> $\ce{Cl2-&amp;gt;[失 2e-]2Cl-}$&lt;/p>
&lt;h2 id="还原剂">还原剂&lt;/h2>
&lt;h3 id="常见还原剂">常见还原剂&lt;/h3>
&lt;ol>
&lt;li>活泼金属单质：$\ce{Al}$ 、$\ce{Fe}$ 、$\ce{Zn}$&lt;/li>
&lt;li>非金属单质：$\ce{H2}$ 、$\ce{C}$&lt;/li>
&lt;li>变价元素的最低价态化合物：$\ce{CO}$ 、$\ce{KI}$&lt;/li>
&lt;li>其他：$\ce{NH3}$&lt;/li>
&lt;/ol>
&lt;h3 id="强还原剂">强还原剂&lt;/h3>
&lt;p>$\ce{S^2&amp;ndash;&amp;gt;[]}$ 、$\ce{I- -&amp;gt;[得 e-]1/2I2}$ 、$\ce{SO^2-_3 -&amp;gt;[得 2e-] SO^{2-}_4 }$ 、$\ce{Fe^2+ -&amp;gt;[得 e-]Fe^3+}$ 、$\ce{S2O3^2- -&amp;gt;}$ 、$\ce{C2O4^2- -&amp;gt;[]}$&lt;/p>
&lt;h3 id="还原性">还原性&lt;/h3>
&lt;p>$\ce{I- -&amp;gt;[得 e-]1/2I2}$ &lt;font color=red size=5>&amp;gt;&lt;/font> $\ce{Fe^2+ -&amp;gt;[得 e-]Fe^2+}$ &lt;font color=red size=5>&amp;gt;&lt;/font> $\ce{Br- -&amp;gt;[得 e-]1/2Br2}$ &lt;font color=red size=5>&amp;gt;&lt;/font> $\ce{Cl- -&amp;gt;[得 e-]1/2Cl2}$&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>焰色实验</title><link>https://xuxihe.vercel.app/courses/chemistry/%E7%84%B0%E8%89%B2%E5%AE%9E%E9%AA%8C/</link><pubDate>Thu, 18 Nov 2021 21:06:12 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/%E7%84%B0%E8%89%B2%E5%AE%9E%E9%AA%8C/</guid><description>&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic2.zhimg.com%2F50%2Fv2-672b019eb1f9fbaae8a0b4d5bfb1823d_hd.jpg&amp;amp;refer=http%3A%2F%2Fpic2.zhimg.com&amp;amp;app=2002&amp;amp;size=f9999,10000&amp;amp;q=a80&amp;amp;n=0&amp;amp;g=0n&amp;amp;fmt=jpeg?sec=1638025271&amp;amp;t=162516d2b176665efc7e8131678431d2" alt="没了请自行Google啊baidu啊啥的" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">金属元素&lt;/th>
&lt;th style="text-align:center">焰色&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">$\ce{Na}$&lt;/td>
&lt;td style="text-align:center">黄色&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Ba}$&lt;/td>
&lt;td style="text-align:center">黄绿色(俗称鬼火)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Cu}$&lt;/td>
&lt;td style="text-align:center">绿色&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Ca}$&lt;/td>
&lt;td style="text-align:center">砖红色&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{K}$&lt;/td>
&lt;td style="text-align:center">紫色(被黄光掩盖，应透过蓝色钴玻璃观察)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Li}$&lt;/td>
&lt;td style="text-align:center">紫红色&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Rb}$ (铷)&lt;/td>
&lt;td style="text-align:center">紫色(同 $\ce{K}$ )&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Sr}$ (锶)&lt;/td>
&lt;td style="text-align:center">洋红色&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>火焰黄色&lt;/strong> $\rightarrow$ 一定有 $\ce{Na}$ 元素，可能有 $\ce{K}$ 元素。&lt;/p>
&lt;p>&lt;strong>物理变化！！！&lt;/strong>&lt;/p>
&lt;p>&lt;strong>实验步骤&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>烧：&lt;/strong> 把铂丝(铬丝/钨丝/光洁无锈的铁丝)在酒精灯(最好是煤气灯，火焰本身最好无色)外焰上灼烧，至与原来的火焰颜色相同。&lt;/li>
&lt;li>&lt;strong>蘸：&lt;/strong> 蘸取待测液体。&lt;/li>
&lt;li>&lt;strong>烧：&lt;/strong> 在外焰上灼烧，观察焰色。&lt;/li>
&lt;li>&lt;strong>洗：&lt;/strong> 用盐酸洗净。(通常情况下，氯化物沸点低)&lt;/li>
&lt;li>&lt;strong>烧：&lt;/strong> 再在外焰上灼烧，至与原来的火焰颜色相同。&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>物质的量</title><link>https://xuxihe.vercel.app/courses/chemistry/%E7%89%A9%E8%B4%A8%E7%9A%84%E9%87%8F/</link><pubDate>Sun, 21 Nov 2021 14:59:26 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/%E7%89%A9%E8%B4%A8%E7%9A%84%E9%87%8F/</guid><description>&lt;h2 id="物质的量">物质的量&lt;/h2>
&lt;p>&lt;strong>物质的量&lt;/strong>是7个基本物理量之一，用于将可称量的物质与难以称量的微观粒子之间建立联系，表示&lt;b>&lt;font color=red size=4>含有一定数目例子的集合体&lt;/font>&lt;/b>，符号为 $n$ 。&lt;/p>
&lt;p>**注意：**物质的量是一个整体，是一个物理量的名称。&lt;/p>
&lt;p>&lt;del>这玩意你理解的话，可以用到任何玩意上，甚至是混合物。&lt;/del>&lt;/p>
&lt;h2 id="单位">单位&lt;/h2>
&lt;p>作为一个物理量，自然，有着单位。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">名称&lt;/th>
&lt;th style="text-align:center">简称&lt;/th>
&lt;th style="text-align:center">符号&lt;/th>
&lt;th style="text-align:center">所含粒子数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">摩尔&lt;/td>
&lt;td style="text-align:center">摩&lt;/td>
&lt;td style="text-align:center">$\pu{mol}$&lt;/td>
&lt;td style="text-align:center">&lt;strong>约&lt;/strong>为$\pu{6.02\times 10^{23} mol^{-1}}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="阿伏伽德罗常数">阿伏伽德罗常数&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">名称&lt;/th>
&lt;th style="text-align:center">定义&lt;/th>
&lt;th style="text-align:center">符号&lt;/th>
&lt;th style="text-align:center">通常表示&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">阿伏伽德罗常数&lt;/td>
&lt;td style="text-align:center">$\pu{1 mol}$ 任何粒子的粒子数&lt;/td>
&lt;td style="text-align:center">$N_A$&lt;/td>
&lt;td style="text-align:center">$\pu{6.02\times10^{23} mol^{-1}}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="辨析">辨析&lt;/h3>
&lt;p>某化学老师吐槽：谁翻译的这个玩意儿啊，真不咋地！&lt;/p>
&lt;p>因为一些qqgg的原因，&lt;strong>物质的量&lt;/strong>这个物理量被非常直白~~(无脑)~~的翻译成了&lt;strong>物质的量&lt;/strong>。因为这个名词和其所属都有一个“量”字，所以就十分容易搞晕了。&lt;/p>
&lt;p>tips：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>物质的量与阿伏伽德罗常数：$1\space mol$ 任何物质都含有 $N_A$ 个粒子。&lt;/p>
&lt;ol>
&lt;li>阿伏伽德罗常数是个数字，&lt;del>虽然人类还不能精确&lt;/del>，单位是**“个”**。&lt;/li>
&lt;li>物质的量和长度，时间，力等是一样的，单位是**“摩”**。&lt;/li>
&lt;li>题目中一般~~(不排除某些丧心病狂的出题人)~~问**“量”&lt;strong>的时候，回答 $\pu{ans mol}$ ；而问 &lt;strong>&amp;ldquo;数&amp;rdquo;&lt;/strong>、&lt;/strong>“个”**的时候，回答 $(\pu{ans mol}\times6.02)\times10^{23}个$ 或 $\pu{ans\space N_A}$ 。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>物质的量是从属于物理量这一大类，与长度等属于同一类名词，&lt;strong>不是单位！&lt;/strong> 不要和摩尔搞混了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>虽然答题得参见第一条，但是在心里可以将粒子数转换为以摩尔为单位，便于计算。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="摩尔质量">摩尔质量&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>定义&lt;/th>
&lt;th>符号&lt;/th>
&lt;th>常用单位&lt;/th>
&lt;th>数值特点&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>摩尔质量&lt;/td>
&lt;td>单位&lt;strong>物质的量&lt;/strong>的物质所具有的质量&lt;/td>
&lt;td>$M$&lt;/td>
&lt;td>$\pu{g/mol}$( $\pu{g\space\cdot\space mol^{-1}}$)&lt;/td>
&lt;td>以克为单位时，与该粒子的式量(相对原子/分子质量)相等&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>公式：&lt;/strong> $物质的量=\frac{质量}{摩尔质量}$ ，即 $n=\frac{m}{M}$&lt;/p>
&lt;h2 id="气体摩尔体积">气体摩尔体积&lt;/h2>
&lt;p>总所周知，描述气体的量，体积比质量更方便。而既然是量，那必可以用物质的量来描述。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>定义&lt;/th>
&lt;th>影响因素&lt;/th>
&lt;th>常用单位&lt;/th>
&lt;th>标准状况$^1$&lt;/th>
&lt;th>室温$^2$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>气体摩尔体积&lt;/td>
&lt;td>单位物质的量的气体所占有的体积&lt;/td>
&lt;td>温度和压强&lt;/td>
&lt;td>$\pu{L/mol}$ ($\pu{L·mol-1}$) 和 $\pu{m^3/mol}$ ($\pu{m^3·mol^{-1}}$)&lt;/td>
&lt;td>$\pu{22.4 L/mol}$&lt;/td>
&lt;td>$\pu{24.5L/mol}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>$^1$：$\pu{0^\circ C}$ 和 $\pu{101kPa}$&lt;/p>
&lt;p>$^2$：$\pu{25^\circ C}$ 和 $\pu{101 kPa}$&lt;/p>
&lt;/blockquote>
&lt;h3 id="阿伏伽德罗定律">阿伏伽德罗定律&lt;/h3>
&lt;h4 id="内容">内容&lt;/h4>
&lt;p>在&lt;strong>相同&lt;/strong>的&lt;strong>温度和压强&lt;/strong>下，&lt;strong>相同体积&lt;/strong>的&lt;strong>任何气体&lt;/strong>都含有相同数目的粒子。&lt;/p>
&lt;h4 id="微观解释">微观解释&lt;/h4>
&lt;p>物体体积大小取决于构成这种物质的&lt;strong>粒子的数量&lt;/strong>、&lt;strong>粒子的大小&lt;/strong>和&lt;strong>粒子之间的距离&lt;/strong>。在 $\pu{1mol}$ 任何物质中，粒子数一定相等，因此，其体积主要取决于构成物质的粒子的&lt;strong>大小&lt;/strong>和&lt;strong>间距&lt;/strong>。&lt;/p>
&lt;p>因此，当&lt;strong>粒子数量相同&lt;/strong>时：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>状态&lt;/th>
&lt;th>粒子间距&lt;/th>
&lt;th>粒子大小&lt;/th>
&lt;th>决定因素&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>固体&lt;/td>
&lt;td>极小&lt;/td>
&lt;td>各异&lt;/td>
&lt;td>粒子大小&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>液体&lt;/td>
&lt;td>小&lt;/td>
&lt;td>各异&lt;/td>
&lt;td>粒子大小&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>气体&lt;/td>
&lt;td>远大于粒子直径&lt;/td>
&lt;td>可忽略&lt;/td>
&lt;td>粒子间距&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="粒子间距">粒子间距&lt;/h4>
&lt;p>影响因素：温度、压强和粒子数。&lt;/p>
&lt;div>
&lt;style>
.markmap > svg {
width: 100%;
height: 300px;
}
&lt;/style>
&lt;div class="markmap">
# 粒子间距
## 粒子数
## 体积
###
#### 温度
#### 压强
###
#### 质量
##### 粒子数
#### 密度
&lt;/div>
&lt;script src="https://cdn.jsdelivr.net/npm/markmap-autoloader">&lt;/script>
&lt;/div>
&lt;h5 id="关系">关系&lt;/h5>
&lt;ol>
&lt;li>体积、质量、密度：$\rho=\frac{m}{v}$ ，即确定两个，第三个确定；确定一个，其余两个成比例。&lt;/li>
&lt;li>体积、温度、压强：&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>条件&lt;/th>
&lt;th>公式&lt;/th>
&lt;th>文字解释&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$T$ 、$p$ 、$V$ 、$n$ 中任意三个相同&lt;/td>
&lt;td>$T_1=T_2$ 、$p_1=p_2$ 、$V_1=V_2$ 、$n_1=n_2$&lt;/td>
&lt;td>三同推一同&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$T$ 、$p$ 、$V$ 相同&lt;/td>
&lt;td>$\frac{M_1}{M_2}=\frac{m_1}{m_2}$&lt;/td>
&lt;td>同温同压同体积的两种&lt;strong>气体&lt;/strong>摩尔质量与质量成正比&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$T$ 、$p$ 相同&lt;/td>
&lt;td>$\frac{V_1}{V_2}=\frac{n_1}{n_2}$ 、$\frac{\rho_1}{\rho_2}=\frac{M_1}{M_2}$&lt;/td>
&lt;td>同温同压下，两种&lt;strong>气体&lt;/strong>体积与物质的量成正比，密度与摩尔质量成正比(代入公式1求出)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$T$ 、$V$ 相同&lt;/td>
&lt;td>$\frac{p_1}{p_2}=\frac{n_1}{n_2}$&lt;/td>
&lt;td>同温同体积下，两种&lt;strong>气体&lt;/strong>压强与物质的量成正比&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$n$ 、$T$ 相同&lt;/td>
&lt;td>$\frac{p_1}{p_2}=\frac{V_1}{V_2}$&lt;/td>
&lt;td>同温同物质的量下，两种&lt;strong>气体&lt;/strong>压强与体积成正比&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="平均摩尔质量气体">平均摩尔质量(气体)&lt;/h3>
&lt;p>平均摩尔质量 $\overline{M}=\rho_{混}V_{混}=\frac{m_总}{n_总}$&lt;/p>
&lt;p>相对密度 $D=\frac{M_1}{M_2}=\frac{\rho_1}{\rho_2}$&lt;/p>
&lt;p>计算方法：
$$
\begin{aligned}
M_1&amp;amp;\space\space\space\space\space\space\space |\overline{M}-M_2|\newline
&amp;amp;\space\backslash \space\space /\newline
&amp;amp;\space\space\overline{M}\space\space\space\overline{\space\space\space\space\space\space\space\space\space\space\space\space\space\space}\space\space\space=\frac{n_1}{n_2}\newline
&amp;amp;\space/\space\space\backslash\newline
M_2&amp;amp;\space\space\space\space\space\space\space |\overline{M}-M_1|
\end{aligned}
$$&lt;/p>
&lt;h2 id="物质的量浓度">物质的量浓度&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">名称&lt;/th>
&lt;th style="text-align:center">定义&lt;/th>
&lt;th style="text-align:center">符号&lt;/th>
&lt;th style="text-align:center">单位&lt;/th>
&lt;th>公式&lt;/th>
&lt;th style="text-align:center">备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">物质的量浓度&lt;/td>
&lt;td style="text-align:center">单位体积的&lt;strong>溶液&lt;/strong>里所含溶质的物质的量&lt;/td>
&lt;td style="text-align:center">$c$&lt;/td>
&lt;td style="text-align:center">$\pu{mol/L}$ ($\pu{mol·L^{-1}}$)&lt;/td>
&lt;td>$c=\frac{n}{V}$&lt;/td>
&lt;td style="text-align:center">气体溶于水按&lt;strong>气体&lt;/strong>物质的量算&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>溶液混合：&lt;/p>
&lt;ol>
&lt;li>等质量：$w'=\frac{w_1+w_2}{2}$&lt;/li>
&lt;li>等体积：
&lt;ol>
&lt;li>$\rho&amp;gt;1$：$w'&amp;gt;\frac{w_1+w_2}{2}$&lt;/li>
&lt;li>$\rho&amp;lt;1$：$w'&amp;lt;\frac{w_1+w_2}{2}$&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="配置一定物质的量浓度的溶液">配置一定物质的量浓度的溶液&lt;/h2>
&lt;ol>
&lt;li>算&lt;/li>
&lt;li>称&lt;/li>
&lt;li>溶&lt;/li>
&lt;li>转移&lt;/li>
&lt;li>洗&lt;/li>
&lt;li>摇&lt;/li>
&lt;li>定容&lt;/li>
&lt;li>装瓶&lt;/li>
&lt;/ol>
&lt;p>注意：容量瓶一定带容积。&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>酸</title><link>https://xuxihe.vercel.app/courses/chemistry/%E9%85%B8/</link><pubDate>Sat, 27 Nov 2021 16:32:17 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/%E9%85%B8/</guid><description>&lt;h2 id="定义">定义&lt;/h2>
&lt;p>在水中电离出的阳离子只有 $\ce{H+}$ 的化合物。&lt;/p>
&lt;h2 id="电离氢离子个数">电离氢离子个数&lt;/h2>
&lt;ul>
&lt;li>一元酸&lt;/li>
&lt;li>多元酸&lt;/li>
&lt;/ul>
&lt;h2 id="强弱">强弱&lt;/h2>
&lt;ol>
&lt;li>强酸：$\ce{HCl}$ 、$\ce{H2SO4}$ 、$\ce{HNO3}$ 、$\ce{HClO4}$ 、$\ce{HI}$ 、$\ce{HBr}$&lt;/li>
&lt;li>中强酸：$\ce{H2SO3}$ 、$\ce{H3PO4}$ 、$\ce{H2C2O4}$ (草酸)&lt;/li>
&lt;li>较弱酸：$\ce{H2CO3}$ 、$\ce{CH3COOH}$ 、$\ce{HF}$&lt;/li>
&lt;li>弱酸：$\ce{H2S}$、$\ce{HClO}$ 、$\ce{H2SiO3}$&lt;/li>
&lt;/ol>
&lt;p>详细见&lt;a href="./%e7%94%b5%e8%a7%a3%e8%b4%a8/">电解质&lt;/a>。&lt;/p>
&lt;h2 id="酸的氧化性">酸的氧化性&lt;/h2>
&lt;p>所有酸的通性。&lt;/p>
&lt;p>因为 $\ce{H+}$ 离子可以得电子降价，即 $\ce{2H+-&amp;gt;[得\space2e^-]H_2 ^}$；因为所有酸均可电离出 $\ce{H+}$ ，所以都具有氧化性。&lt;/p>
&lt;h2 id="氧化性的酸">氧化性的酸&lt;/h2>
&lt;p>酸中阴离子具有氧化性。&lt;/p>
&lt;p>例：$\ce{HCr2O7}$ 、$\ce{HMnO4}$ 、$\ce{HClO}$ 、$\ce{浓HNO3}$ 、$\ce{稀HNO3}$ 、$\ce{浓H2SO4}$&lt;/p>
&lt;h2 id="非氧化性的酸">非氧化性的酸&lt;/h2>
&lt;p>酸中阴离子不具有氧化性。&lt;/p>
&lt;p>例：$\ce{稀HSO4}$ 、$\ce{HCl}$&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>碱</title><link>https://xuxihe.vercel.app/courses/chemistry/%E7%A2%B1/</link><pubDate>Mon, 13 Dec 2021 21:32:17 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/%E7%A2%B1/</guid><description>&lt;h2 id="定义">定义&lt;/h2>
&lt;p>在水溶液中电离出的阴离子只有 $\ce{OH-}$ 的化合物。&lt;/p>
&lt;h2 id="电离出氢氧根个数">电离出氢氧根个数&lt;/h2>
&lt;ul>
&lt;li>一元碱&lt;/li>
&lt;li>多元碱&lt;/li>
&lt;/ul>
&lt;h2 id="强弱">强弱&lt;/h2>
&lt;ol>
&lt;li>强碱：$\ce{NaOH}$ 、$\ce{KOH}$ 、$\ce{Ca(OH)2}$ 、$\ce{Ba(OH)2}$&lt;/li>
&lt;li>弱碱：$\ce{NH3*H2O}$ 、难溶碱&lt;/li>
&lt;/ol>
&lt;p>详见&lt;a href="./%e7%94%b5%e8%a7%a3%e8%b4%a8/">电解质&lt;/a>。&lt;/p>
&lt;h2 id="溶解性">溶解性&lt;/h2>
&lt;ol>
&lt;li>易溶：$\ce{NaOH}$ 、$\ce{KOH}$ 、$\ce{Ba(OH)2}$ 、$\ce{NH3*H2O}$&lt;/li>
&lt;li>微溶：$\ce{Ca(OH)2}$&lt;/li>
&lt;li>难溶：加热易分解&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>Na钠</title><link>https://xuxihe.vercel.app/courses/chemistry/na/</link><pubDate>Thu, 18 Nov 2021 21:08:39 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/na/</guid><description>&lt;h2 id="单质">单质&lt;/h2>
&lt;h3 id="物理性质">物理性质&lt;/h3>
&lt;ol>
&lt;li>软&lt;/li>
&lt;li>银白色金属光泽&lt;/li>
&lt;li>熔点低 ($\rm97.8^\circ{C}$)&lt;/li>
&lt;li>密度小 ($\pu{0.971g/cm^3}$)&lt;/li>
&lt;li>能导电&lt;/li>
&lt;/ol>
&lt;p>$\ce{K}$ 、$\ce{Na}$ 合金做原子反应堆导热剂。&lt;/p>
&lt;p>高压钠灯透雾能力强。&lt;/p>
&lt;h3 id="化学性质">化学性质&lt;/h3>
&lt;p>钠的化学性质&lt;strong>非常活泼&lt;/strong>，表现出&lt;strong>很强的还原性&lt;/strong>。&lt;/p>
&lt;p>在熔融状态下置换贵重金属：&lt;strong>钛钽铌铬锆钾&lt;/strong>。$\ce{Na + KCl \overset{熔融}{=} NaCl + K_{(g)} ^}$&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">$\ce{4Na + O2 = 2Na2O}$&lt;/th>
&lt;th style="text-align:center">钠的表面变暗&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">$\ce{2Na + O2 \triangleq Na2O2}$&lt;/td>
&lt;td style="text-align:center">&lt;strong>与氧气剧烈反应，发出黄色火焰，生成淡黄色固体&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{2Na + 2H2O = 2NaOH + H2 ^}$&lt;/td>
&lt;td style="text-align:center">&lt;strong>浮熔游响红&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{2Na + Cl2 \overset{点燃}{=} 2NaCl}$&lt;/td>
&lt;td style="text-align:center">&lt;strong>发出黄色火焰，生成白色固体&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{2Na + S \triangleq NaS}$&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{2Na + 2H+ = 2Na+ + H2 ^}$ (与 $\ce{H+}$ 反应)&lt;/td>
&lt;td style="text-align:center">&lt;strong>浮熔游响红，比水更剧烈&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="化合物">化合物&lt;/h2>
&lt;h3 id="氧化钠">氧化钠&lt;/h3>
&lt;p>碱性氧化物&lt;/p>
&lt;p>$\ce{Na2O + H2O = 2NaOH}$&lt;/p>
&lt;p>$\ce{Na2O + CO2 = Na2CO3}$&lt;/p>
&lt;p>$\ce{Na2O + H2SO4 = NaSO4 + H2O}$&lt;/p>
&lt;p>$\ce{2Na2O + O2 \triangleq 2Na2O2}$ (热稳性不如 $\ce{Na2O2}$ )&lt;/p>
&lt;h3 id="过氧化钠">过氧化钠&lt;/h3>
&lt;p>可用作供氧剂、漂白剂、消毒剂。&lt;/p>
&lt;p>同时具有氧化性和还原性，发生氧化、还原、歧化反应。&lt;/p>
&lt;p>$\ce{Na2O2 -&amp;gt;[加入] 酚酞溶液}$ 先变红，后褪色。&lt;/p>
&lt;p>$\ce{2Na2O2 + 2H2O = 4NaOH + O2 ^}$&lt;/p>
&lt;p>$\ce{2Na2O2 + 2CO2 = 2Na2CO3 + O2}$&lt;/p>
&lt;p>$\ce{2Na2O2 + 2H2SO4 = 2NaSO4 + 2H2O + O2 ^}$&lt;/p>
&lt;h3 id="碳酸钠">碳酸钠&lt;/h3>
&lt;p>白色粉末，加入少量水变为晶体( $\ce{Na2CO3*x H2O}$ )，并放热。&lt;/p>
&lt;p>俗称苏打，纯碱。&lt;/p>
&lt;p>重要的化工原料，广泛运用于纺织、制皂、造纸、制玻璃等。&lt;/p>
&lt;p>比碳酸氢钠同等条件下溶解度更大，水溶液碱性更强。&lt;/p>
&lt;p>$\ce{Na2CO3 + H+ = 2Na+ +HCO^-3}$ (酸少/碳酸钠多)&lt;/p>
&lt;p>$\ce{Na2CO3 + 2H+ = 2Na+ + H2O +CO2 ^}$ (酸多/碳酸钠少)&lt;/p>
&lt;h3 id="碳酸氢钠">碳酸氢钠&lt;/h3>
&lt;p>细小的白色晶体，溶于水吸热。&lt;/p>
&lt;p>俗称小苏打。&lt;/p>
&lt;p>制药(胃酸过多，应避免穿孔)、焙制糕点、泡沫灭火器。&lt;/p>
&lt;p>比碳酸钠同等条件下溶解度更小，水溶液碱性更弱。&lt;/p>
&lt;p>$\ce{2NaHCO3 \triangleq Na2CO3 + H2O + CO2 ^}$&lt;/p>
&lt;p>$\ce{NaHCO3 + H+ = Na+ + H2O + CO2 ^}$&lt;/p>
&lt;p>同时滴入 $\ce{H+}$ ，$\ce{NaHCO3}$ 比 $\ce{Na2CO3}$ 先出气泡；等量且少量的与足量 $\ce{H+}$ 反应，$\ce{NaHCO3}$ 产生的 $\ce{CO2}$ 多。&lt;/p>
&lt;h3 id="侯氏制碱法">侯氏制碱法&lt;/h3>
&lt;p>先向饱和氯化钠溶液中通入足量氨气，再通入足量二氧化碳。&lt;/p>
&lt;ol>
&lt;li>$\ce{NH3 + CO2 = NH4HCO3}$&lt;/li>
&lt;li>$\ce{NH4HCO3 + NaCl = NaHCO3 v + NH4Cl}$&lt;/li>
&lt;li>$\ce{2NaHCO3 \triangleq Na2CO3 + H2O + CO2 ^}$&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>Cl氯</title><link>https://xuxihe.vercel.app/courses/chemistry/cl/</link><pubDate>Thu, 18 Nov 2021 21:12:41 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/cl/</guid><description>&lt;h2 id="单质">单质&lt;/h2>
&lt;h3 id="物理性质">物理性质&lt;/h3>
&lt;ol>
&lt;li>标准状况下为气体&lt;/li>
&lt;li>黄绿色&lt;/li>
&lt;li>有刺激性气味&lt;/li>
&lt;li>有毒&lt;/li>
&lt;li>密度大于空气&lt;/li>
&lt;li>易液化(液氯)&lt;/li>
&lt;li>$1:2$ 溶于水(氯水)&lt;/li>
&lt;li>难溶于饱和氯化钠溶液&lt;/li>
&lt;/ol>
&lt;h3 id="化学性质">化学性质&lt;/h3>
&lt;p>氯气是&lt;strong>很活泼&lt;/strong>的非金属单质，具有&lt;strong>强氧化性&lt;/strong>。&lt;/p>
&lt;h4 id="与金属非金属单质反应">与金属、非金属单质反应&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">$\ce{2Na + Cl2 \triangleq 2NaCl}$&lt;/th>
&lt;th style="text-align:center">黄色火焰&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">$\ce{2Fe + Cl2 \triangleq 2FeCl3}$&lt;/td>
&lt;td style="text-align:center">&lt;strong>棕色烟，溶于水呈黄色&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Cu + Cl2 \triangleq CuCl2}$&lt;/td>
&lt;td style="text-align:center">&lt;strong>棕色烟，溶于水呈黄色(极少水)/蓝色(较多水)/蓝绿色(少量水)&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{H2 + Cl2 \overset{点燃}{=}2HCl}$&lt;/td>
&lt;td style="text-align:center">&lt;strong>安静地燃烧，苍白色火焰，生成的 $\ce{HCl_{(g)}}$ 与水蒸气结合，产生白色雾(盐酸小液滴)&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{H2 + Cl2 \overset{光照}{=}2HCl}$&lt;/td>
&lt;td style="text-align:center">&lt;strong>爆炸&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{P + Cl2 \overset{点燃}{=} PCl3}$&lt;/td>
&lt;td style="text-align:center">&lt;strong>固体，烟，白色&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{P + Cl2 \overset{点燃}{=} PCl5}$&lt;/td>
&lt;td style="text-align:center">&lt;strong>液体，瓶口有白色雾&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="与还原性化合物反应">与还原性化合物反应&lt;/h4>
&lt;p>$\ce{Cl2 + S^2- = S v + 2Cl-}$&lt;/p>
&lt;ul>
&lt;li>$\ce{Cl2 + Na2S = S v + 2NaCl}$&lt;/li>
&lt;li>$\ce{Cl2 + H2S = S v + 2HCl}$&lt;/li>
&lt;/ul>
&lt;p>$\ce{Cl2 + 2I- = I2 + 2Cl-}$&lt;/p>
&lt;ul>
&lt;li>用湿润的淀粉碘化钾试纸测氯气
&lt;ol>
&lt;li>少量：$\ce{Cl2 + 2KI = I2 + 2KCl}$ (变蓝)&lt;/li>
&lt;li>足量：$\ce{I2 + 5Cl2 + 6H2O = 2HIO3 + 10HCl}$ (褪色)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>$\ce{Cl2 + SO^2-_3 = SO^2-_4 + 2Cl-}$&lt;/p>
&lt;p>$\ce{Cl2 + 2Fe^2+ = 2Fe^3+ + 2Cl-}$&lt;/p>
&lt;p>$\ce{Cl2 + 2Br- = Br2 + 2Cl-}$&lt;/p>
&lt;p>$\left{\begin{array}{rcl}\begin{aligned}&amp;amp;\ce{3Cl2 + 2NH3\space(少量) = N2 + 6HCl}\newline&amp;amp;\ce{3Cl2 + 8NH3\space (足量) = N2 + 6NH4Cl}\end{aligned}\end{array}\right.$&lt;/p>
&lt;ul>
&lt;li>用蘸有浓氨水的抹布检查 $\ce{Cl2}$ 的管道是否漏气 ($\ce{NH4Cl}$ 白烟)&lt;/li>
&lt;/ul>
&lt;h4 id="与水反应">与水反应&lt;/h4>
&lt;p>一部分氯气：$\ce{Cl2 + H2O = HCl + HClO}$&lt;/p>
&lt;h5 id="氯水">氯水&lt;/h5>
&lt;h6 id="新制氯水">新制氯水&lt;/h6>
&lt;ul>
&lt;li>
&lt;p>成分：$\ce{Cl2}$ 、$\ce{HCl}$ 、$\ce{HClO}$ 、$\ce{H2O}$ ( $\ce{Cl2}$ 、$\ce{H2O}$ 、$\ce{HClO}$ 、$\ce{Cl-}$ 、$\ce{H+}$ 、$\ce{OH-}$ 、$\ce{ClO-}$ )&lt;/p>
&lt;/li>
&lt;li>
&lt;p>淡黄绿色：含较多有 $\ce{Cl2}$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不稳定性：$\ce{2HClO \overset{光照}{=} 2HCl + O2 ^}$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>漂白性：$\ce{ClO-}$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>氧化性：$\ce{ClO-}$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>酸性：较弱，$\ce{H+}$ 浓度低&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h6 id="久置氯水">久置氯水&lt;/h6>
&lt;ul>
&lt;li>
&lt;p>成分：$\ce{HCl}$ 、$\ce{H2O}$ ( $\ce{Cl-}$ 、$\ce{H+}$ 、$\ce{OH-}$ 、$\ce{H2O}$ )&lt;/p>
&lt;/li>
&lt;li>
&lt;p>无色&lt;/p>
&lt;/li>
&lt;li>
&lt;p>等价于盐酸&lt;/p>
&lt;/li>
&lt;li>
&lt;p>无漂白性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>氧化性：弱 ($\ce{H+}$)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>酸性：强，$\ce{H+}$ 浓度高&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="与碱反应">与碱反应&lt;/h4>
&lt;p>$\ce{Cl2 + 2OH- = Cl- + ClO- + H2O}$&lt;/p>
&lt;ul>
&lt;li>$\ce{Cl2 + 2NaOH = NaCl + NaClO + H2O}$&lt;/li>
&lt;li>$\ce{2Cl2 + 2Ca(OH)2 = Ca(ClO2)+ CaCl2 + 2H2O}$&lt;/li>
&lt;/ul>
&lt;p>$\ce{3Cl2 + 6OH- \triangleq 5Cl- + ClO^-_3 + 3H2O}$&lt;/p>
&lt;h3 id="实验室制备">实验室制备&lt;/h3>
&lt;img src="%E5%AE%9E%E9%AA%8C%E8%A3%85%E7%BD%AE.png" style="zoom: 45%;" />
&lt;p>浓盐酸与二氧化锰反应&lt;/p>
&lt;p>$\ce{MnO2 + 4HCl(浓) \triangleq MnCl2 + Cl2 ^ + 2H2O}$&lt;/p>
&lt;ol>
&lt;li>
&lt;p>$\ce{HCl}$：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>酸性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还原性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>浓盐酸：稀盐酸还原性弱&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>其他氧化剂(无需加热)：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>$\ce{KMnO4}$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$\ce{K2MnO4}$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$\ce{KClO3}$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$\ce{Ca(ClO)2}$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$\ce{K2Cr2O7}$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>杂质：&lt;/p>
&lt;ul>
&lt;li>氯化氢：饱和食盐水&lt;/li>
&lt;li>水：浓硫酸&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="工业制备">工业制备&lt;/h3>
&lt;p>电解饱和食盐水&lt;/p>
&lt;p>$\ce{2NaCl + 2H2O \overset{电解}{=} H2 ^ + 2NaOH + Cl2 ^}$&lt;/p>
&lt;h3 id="氯溴碘检验">氯溴碘检验&lt;/h3>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">单质&lt;/th>
&lt;th style="text-align:center">颜色状态&lt;/th>
&lt;th style="text-align:center">水溶液&lt;/th>
&lt;th style="text-align:center">有机溶剂&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">$\ce{Cl2}$&lt;/td>
&lt;td style="text-align:center">黄绿色气体&lt;/td>
&lt;td style="text-align:center">浅黄绿色&lt;/td>
&lt;td style="text-align:center">浅黄绿色&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{Br2}$&lt;/td>
&lt;td style="text-align:center">深棕红色液体&lt;/td>
&lt;td style="text-align:center">黄(橙)色&lt;/td>
&lt;td style="text-align:center">橙(红)色/红棕色&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">$\ce{I2}$&lt;/td>
&lt;td style="text-align:center">黑紫色固体&lt;/td>
&lt;td style="text-align:center">黄色&lt;/td>
&lt;td style="text-align:center">紫(紫红)色&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol start="2">
&lt;li>
&lt;p>离子：&lt;/p>
&lt;ul>
&lt;li>$\ce{Cl-}$
&lt;ol>
&lt;li>加入硝酸酸化&lt;/li>
&lt;li>加入 $\ce{AgNO3}$ 溶液，出现 $\ce{AgCl}$ 白色沉淀&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;h2 id="cebr-">$\ce{Br-}$&lt;/h2>
&lt;h2 id="2-加入-ceagno3-溶液出现-ceagbr-浅黄色沉淀">1. 加入硝酸酸化
2. 加入 $\ce{AgNO3}$ 溶液，出现 $\ce{AgBr}$ 浅黄色沉淀&lt;/h2>
1. 加入氯水 $\ce{Cl2 + 2Br- = 2Cl- + Br2}$
2. 加入四氯化碳 $\ce{CCl4}$ ，下层( $\ce{CCl4}$ )的 $\ce{Br2}$ 呈棕红色&lt;/li>
&lt;li>
&lt;h2 id="cei-">$\ce{I-}$&lt;/h2>
1. 加入硝酸酸化
2. 加入 $\ce{AgNO3}$ 溶液，出现 $\ce{AgI}$ 黄色沉淀
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>加入氯水 $\ce{Cl2 + 2I- = 2Cl- + I2}$&lt;/li>
&lt;li>加入四氯化碳 $\ce{CCl4}$ ，下层( $\ce{CCl4}$ )的 $\ce{I2}$ 呈紫色 &lt;font color=red>/&lt;/font> 加入淀粉，溶液呈蓝色&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="化合物">化合物&lt;/h2>
&lt;h3 id="次氯酸">次氯酸&lt;/h3>
&lt;h4 id="化学性质-1">化学性质&lt;/h4>
&lt;ol>
&lt;li>弱酸性&lt;/li>
&lt;li>强氧化性&lt;/li>
&lt;li>不稳定性：$\ce{2HClO \overset{光照}{=}2HCl + O2 ^}$&lt;/li>
&lt;/ol>
&lt;h4 id="用途">用途&lt;/h4>
&lt;ol>
&lt;li>漂白剂&lt;/li>
&lt;li>消毒液&lt;/li>
&lt;/ol>
&lt;h3 id="漂白液">漂白液&lt;/h3>
&lt;h4 id="制备">制备&lt;/h4>
&lt;p>常温下，将 $\ce{Cl2}$ 通入 $\ce{NaOH}$ 溶液。&lt;/p>
&lt;p>$\ce{Cl2 + 2NaOH = NaCl + NaClO +H2O}$&lt;/p>
&lt;h4 id="优点">优点&lt;/h4>
&lt;p>低温下三年分解一半左右，稳定性远强于 $\ce{HClO}$&lt;/p>
&lt;h4 id="生效">生效&lt;/h4>
&lt;p>$\ce{NaClO + CO2 + H2O = HClO + NaHCO3}$&lt;/p>
&lt;blockquote>
&lt;p>无论 $\ce{CO2}$ 多少，均生成 $\ce{NaHCO3}$&lt;/p>
&lt;/blockquote>
&lt;h3 id="漂白粉">漂白粉&lt;/h3>
&lt;p>&lt;strong>注意：&lt;/strong>$\color{red}{\ce{Ca(ClO)2 + SO2 + H2O \neq CaSO3 v + 2HClO}}$ &lt;font color=blue>(这个方程式是错的)&lt;/font>&lt;/p>
&lt;h4 id="制备-1">制备&lt;/h4>
&lt;p>将 $\ce{Cl2}$ 通入冷的石灰乳 $\ce{[Ca(OH)2]}$ 中。&lt;/p>
&lt;p>$\ce{2Cl2 + 2Ca(OH)2 = Ca(ClO)2 + CaCl2 + 2H2O}$&lt;/p>
&lt;h4 id="优点-1">优点&lt;/h4>
&lt;p>稳定性更强&lt;/p>
&lt;h4 id="生效-1">生效&lt;/h4>
&lt;ul>
&lt;li>工业：$\ce{Ca(ClO)2 + 2HCl = CaCl2 + 2HClO}$&lt;/li>
&lt;li>生活：
&lt;ul>
&lt;li>少量 $\ce{CO2}$ ：$\ce{Ca(ClO)2 + CO2 + H2O = CaCO3 v + 2HClO}$&lt;/li>
&lt;li>大量 $\ce{CO2}$ ：$\ce{Ca(ClO)2 + 2CO2 + 2H2O = Ca(HCO3)2 + 2HClO}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="失效">失效&lt;/h4>
&lt;ol>
&lt;li>与空气中 $\ce{CO2}$ 和 水蒸气接触&lt;/li>
&lt;li>次氯酸光照分解盐酸&lt;/li>
&lt;li>再次分解漂白粉&lt;/li>
&lt;/ol>
&lt;h4 id="漂白精">漂白精&lt;/h4>
&lt;p>$\ce{Cl2}$ 与 $\ce{Ca(OH)2}$ 反应充分，并使 $\ce{Ca(ClO)2}$ 成为主要成分。&lt;/p>
&lt;p>即 $\ce{Ca(ClO)2}$ 含量高。&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>Fe铁</title><link>https://xuxihe.vercel.app/courses/chemistry/fe/</link><pubDate>Sat, 27 Nov 2021 15:26:33 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/fe/</guid><description>&lt;h2 id="单质">单质&lt;/h2>
&lt;h3 id="物理性质">物理性质&lt;/h3>
&lt;ol>
&lt;li>银白色金属光泽&lt;/li>
&lt;li>导电导热&lt;/li>
&lt;li>延展性&lt;/li>
&lt;li>熔点高( $\pu{1535 ^\circ C}$ )&lt;/li>
&lt;li>易被磁铁吸引&lt;/li>
&lt;/ol>
&lt;h3 id="化学性质">化学性质&lt;/h3>
&lt;p>铁的化学性质&lt;strong>比较活泼&lt;/strong>，自然界中铁元素&lt;strong>主要&lt;/strong>以 $+2$ 和 $+3$ 价态存在于矿石中，但是可以以&lt;strong>单质&lt;/strong>形式存在，如太空的&lt;strong>陨铁&lt;/strong>。&lt;/p>
&lt;ol>
&lt;li>非金属单质&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$\ce{3Fe + 2O2 \overset{点燃}{=} Fe3O4}$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\ce{2Fe + 3Cl3 \overset{点燃}{=} 2FeCl3}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\ce{Fe + S \triangleq FeS}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol start="2">
&lt;li>酸&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>少量&lt;/th>
&lt;th>$\ce{Fe + NO3- + 4H+ = Fe^{3+} + NO ^ + 4H2O}$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>大量&lt;/strong>&lt;/td>
&lt;td>$\ce{3Fe + 2NO^-_3 + 8H+ = 3Fe^{2+} + 2NO ^ + 4H2O}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>注：&lt;strong>硝酸均为&lt;/strong>稀&lt;/strong>硝酸。&lt;/p>
&lt;ol start="3">
&lt;li>盐溶液&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$\ce{Fe + CuSO4 = FeSO4 + Cu}$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\ce{Fe + 2Fe^{3+} = 3Fe^{2+}}$&lt;/td>
&lt;td>$\ce{Fe + 2Fe(NO3)3 = 3Fe(NO3)2}$ 、$\ce{Fe + 2FeCl3 = 3FeCl2}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol start="4">
&lt;li>水&lt;strong>蒸气&lt;/strong>&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$\ce{3Fe + 4H2O_{(g)}\overset{高温}{=}Fe3O4 + 4H2}$&lt;/th>
&lt;th>先有爆鸣声(氢气不纯净)，后安静燃烧(氢气纯净)。&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;/table>
&lt;p>铁是&lt;strong>还原剂&lt;/strong>，与氧化性较弱的物质(非氧化性酸，硫酸铜等)反应，生成 $\ce{+2}$ 价铁；与氧化性较强的物质(氧化性的酸，氯气等)反应，生成 $+3$ 价的铁。&lt;/p>
&lt;ol>
&lt;li>氧化性粒子顺序：$\ce{Ag+}$ &lt;font color=red size=5>&amp;gt;&lt;/font> $\ce{Fe^3+}$ &lt;font color=red size=5>&amp;gt;&lt;/font> $\ce{Cu^2+}$&lt;/li>
&lt;li>还原性：$\ce{Fe}$ &lt;font color=red size=5>&amp;gt;&lt;/font> $\ce{Cu}$&lt;/li>
&lt;/ol>
&lt;h2 id="氧化物">氧化物&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>化学式&lt;/th>
&lt;th>俗称&lt;/th>
&lt;th>铁的化合价&lt;/th>
&lt;th>颜色状态&lt;/th>
&lt;th>备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>氧化亚铁&lt;/td>
&lt;td>$\ce{FeO}$&lt;/td>
&lt;td>&lt;/td>
&lt;td>$+2$&lt;/td>
&lt;td>黑色粉末&lt;/td>
&lt;td>不稳定，$\ce{6FeO + O2 \triangleq 2Fe3O4}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>氧化铁&lt;/td>
&lt;td>$\ce{Fe2O3}$&lt;/td>
&lt;td>铁红&lt;/td>
&lt;td>$+3$&lt;/td>
&lt;td>红棕色粉末&lt;/td>
&lt;td>常用于油漆、涂料、油墨和橡胶的红色染料&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>四氧化三铁&lt;/td>
&lt;td>$\ce{Fe3O4}$&lt;/td>
&lt;td>磁性氧化铁&lt;/td>
&lt;td>$\frac{+2}{+3}=\frac{1}{2}$&lt;/td>
&lt;td>黑色晶体&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>铁的氧化物均不溶于水或与水反应。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>$\ce{FeO}$&lt;/th>
&lt;th>$\ce{Fe2O3}$&lt;/th>
&lt;th>$\ce{Fe3O4}$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\ce{HCl}$ (非氧化性酸)&lt;/td>
&lt;td>$\ce{FeO + 2HCl = FeCl2 + H2O}$&lt;/td>
&lt;td>$\ce{Fe2O3 + 6HCl = 2FeCl3 + 3H2O}$&lt;/td>
&lt;td>$\ce{Fe3O4 + 8HCl = FeCl2 + 2FeCl3 + 4H2O}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\ce{HNO3}$ (氧化性酸)&lt;/td>
&lt;td>$\ce{3FeO + 10HNO3 = 3Fe(NO3)3 + NO ^ + 5H2O}$&lt;/td>
&lt;td>$\ce{Fe2O3 + 6HNO3 = 2Fe(NO3)3 + 3H2O}$&lt;/td>
&lt;td>$\ce{3Fe3O4 + 28HNO3 = 9Fe(NO3)3 + NO ^ + 14H2O}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\ce{HI}$ (还原性酸)&lt;/td>
&lt;td>$\ce{FeO + 2HI = FeI2 + H2O}$&lt;/td>
&lt;td>$\ce{Fe2O3 + 6HI = 2FeI2 + I2 v + 3H2O}$&lt;/td>
&lt;td>$\ce{Fe3O4 + 8HI = 3FeI2 + I2 v + 4H2O}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="氢氧化物">氢氧化物&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>化学式&lt;/th>
&lt;th>铁的化合价&lt;/th>
&lt;th>颜色状态&lt;/th>
&lt;th>稳定性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>氢氧化亚铁&lt;/td>
&lt;td>$\ce{Fe(OH)2}$&lt;/td>
&lt;td>$+2$&lt;/td>
&lt;td>白色固体&lt;/td>
&lt;td>不稳定 $\ce{4Fe(OH)2 + O2 + H2O = 4Fe(OH)3}$ $\ce{白色 -&amp;gt; 灰绿色 -&amp;gt; 红褐色}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>氢氧化铁&lt;/td>
&lt;td>$\ce{Fe(OH)3}$&lt;/td>
&lt;td>$+3$&lt;/td>
&lt;td>红褐色固体&lt;/td>
&lt;td>常温稳定，加热分解 $\ce{2Fe(OH)3 \triangleq Fe2O3 + 3H2O}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>铁的氢氧化物均难溶于水。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>$\ce{Fe(OH)2}$&lt;/th>
&lt;th>$\ce{Fe(OH)3}$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\ce{}$$\ce{HCl}$ (非氧化性酸)&lt;/td>
&lt;td>$\ce{Fe(OH)2 + 2HCl = FeCl2 + 2H2O}$&lt;/td>
&lt;td>$\ce{Fe(OH)3 + 3HCl = FeCl3 + 3H2O}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\ce{HNO3}$ (氧化性酸)&lt;/td>
&lt;td>$\ce{3Fe(OH)2 + 10HNO3 = 3Fe(NO3)3 + NO ^ + 6H2O}$&lt;/td>
&lt;td>$\ce{Fe(OH)3 + 3HNO3 = Fe(NO3)3 + 3H2O}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\ce{HI}$ (还原性酸)&lt;/td>
&lt;td>$\ce{Fe(OH)2 + 2HI = FeI2 + 2H2O}$&lt;/td>
&lt;td>$\ce{2Fe(OH)3 + 6HI = 2FeI2 + 2I2 +6H2O}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="亚铁盐">亚铁盐&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>亚铁离子&lt;/th>
&lt;th>水溶液&lt;/th>
&lt;th>常见亚铁盐&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\ce{Fe^{2+}}$&lt;/td>
&lt;td>&lt;font color=lightgreen>浅绿色&lt;/font>&lt;/td>
&lt;td>$\ce{FeSO4}$ 、$\ce{FeCl2}$ 等&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="化学性质-1">化学性质：&lt;/h3>
&lt;ol>
&lt;li>复分解反应
&lt;ol>
&lt;li>与碱反应
&lt;ul>
&lt;li>$\ce{Fe + 2OH- = Fe(OH)2 v}$&lt;/li>
&lt;li>$\ce{Fe^2+ + 2NH3*H2O = FE(OH)2 v + 2NH+_4}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>与 $\ce{Na2S}$ 反应
&lt;ul>
&lt;li>$\ce{Fe^2+ + S^2- = FeS v}$ &lt;b>&lt;font color = red>注意：$\ce{Fe^2+}$ 与 $\ce{H2S}$ 不反应，弱酸不能制强酸。&lt;/font>&lt;/b>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>弱氧化性(置换反应)
&lt;ul>
&lt;li>$\ce{Zn + Fe^{2+} = Zn^{2+} + Fe}$&lt;/li>
&lt;li>$\ce{Mg + Fe^{2+} = Mg^{2+} + Fe}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>强还原性
&lt;ol>
&lt;li>与非金属单质反应
&lt;ul>
&lt;li>$\ce{2Fe^2+ + Cl2 = 2Fe^3+ + 2Cl-}$&lt;/li>
&lt;li>$\ce{4Fe^2+ + O2 + 4H+ = 4Fe^3+ + 2H2O}$&lt;/li>
&lt;li>$\ce{Cl2}$ &lt;font color=red size=5> &amp;gt;&lt;/font> $\ce{Br2}$ &lt;font color=red size=5> &amp;gt;&lt;/font> $\ce{Fe^3+}$ &lt;font color=red size=5> &amp;gt;&lt;/font> $\ce{I2}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>与化合物反应
&lt;ul>
&lt;li>$\ce{2Fe^2+ + H2O2 +2H+ = 2Fe^3+ + 2H2O}$&lt;/li>
&lt;li>$\ce{3Fe^2+ NO^-3 + 4H+ = 3Fe^3+ + NO ^ + 2H2O}$&lt;/li>
&lt;li>$\ce{5Fe^2+ + MnO^-4 + 8H+ = 5Fe^3+ + Mn^2+ + 4H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>络合反应
&lt;ul>
&lt;li>$\ce{3Fe^2+ + 2[Fe(CN)6]^3- = Fe3[Fe(CN)6]2 v}$ 蓝色沉淀 (常见 六氰合铁酸钾 $\ce{K3Fe(CN)6}$)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="铁盐">铁盐&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>铁离子&lt;/th>
&lt;th>水溶液&lt;/th>
&lt;th>常见铁盐&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\ce{Fe^3+}$&lt;/td>
&lt;td>&lt;font color=#FFC900>黄色&lt;/font>&lt;/td>
&lt;td>$\ce{Fe2(SO4)3}$ 、$\ce{FeCl3}$ 等&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="化学性质-2">化学性质：&lt;/h3>
&lt;ol>
&lt;li>复分解反应
&lt;ol>
&lt;li>与碱反应
&lt;ul>
&lt;li>$\ce{Fe^3+ + 3OH- = Fe(OH)3 v}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>强氧化性
&lt;ol>
&lt;li>与金属单质反应
&lt;ul>
&lt;li>$\ce{2Fe^3+ + Fe = 3Fe^2+}$&lt;/li>
&lt;li>$\ce{2Fe^3+ + Cu = 2Fe^2+}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>与还原性化合物反应
&lt;ol>
&lt;li>与 $\ce{Na2S}$ 反应&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>$\ce{S^2-}$ 少量：$\ce{2Fe^3+ + S^2- = 2Fe^2+ + S v}$&lt;/li>
&lt;li>$\ce{S^2-}$ 过量：$\ce{2Fe^3+ + 3S^2- = 2FeS v + S v}$&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>与 $\ce{H2S}$ 反应&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>$\ce{2Fe^3+ + H2S = 2Fe^2+ + S v}$&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>与 $+4$ 价 $\ce{S}$ 反应&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>$\ce{2Fe^3+ + SO^2-_3 + H2O = 2Fe^2+ SO^2-_4 + 2H+}$&lt;/li>
&lt;li>$\ce{2Fe^3+ + SO2 + 2H2O = 2Fe^2+ + SO^2-_4 + 4H+}$&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>与 $\ce{I-}$ 反应&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>$\ce{2Fe^3+ 2I- = 2Fe^2+ + I2}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>络合反应
&lt;ul>
&lt;li>$\ce{Fe^3+ + 3SCN- = Fe(SCN)3}$ &lt;font color=red>红色溶液&lt;/font>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>Al铝</title><link>https://xuxihe.vercel.app/courses/chemistry/al/</link><pubDate>Sun, 28 Nov 2021 15:56:41 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/al/</guid><description>&lt;h2 id="单质">单质&lt;/h2>
&lt;h3 id="物理性质">物理性质&lt;/h3>
&lt;ol>
&lt;li>银白色金属光泽&lt;/li>
&lt;li>导电导热&lt;/li>
&lt;li>延展性&lt;/li>
&lt;li>质地柔软&lt;/li>
&lt;li>密度小(轻)&lt;/li>
&lt;/ol>
&lt;h3 id="化学性质">化学性质&lt;/h3>
&lt;p>铝的化学性质&lt;strong>比较活泼&lt;/strong>，是地壳中含量最多的金属元素。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>锈蚀&lt;/p>
&lt;ul>
&lt;li>$\ce{4Al + 3O2 = 2Al2O3}$&lt;/li>
&lt;li>&lt;strong>致密&lt;/strong>的 $\ce{Al2O3}$ 氧化铝薄膜，防止继续锈蚀，起&lt;strong>保护&lt;/strong>作用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>非金属单质&lt;/p>
&lt;ul>
&lt;li>$\ce{4Al + 3O2 \overset{点燃}{=} 2Al2O3}$ 发出耀眼的白光，放出大量热。&lt;/li>
&lt;li>$\ce{2Al + 3S \triangleq Al2S3}$&lt;/li>
&lt;li>$\ce{2ASl + 3Cl2 \overset{点燃}{=} 2AlCl3}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>酸&lt;/p>
&lt;ol>
&lt;li>非氧化性酸
&lt;ul>
&lt;li>$\ce{2Al + 6H+ = 2A^3+ + 3H2 ^}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>氧化性酸
&lt;ul>
&lt;li>$\ce{Al + 4HNO3_{(稀)} = NO ^ + Al(NO)3 + 2H2O}$&lt;/li>
&lt;li>$\ce{Al + 4HNO3_{(浓)} \triangleq NO ^ + Al(NO)3 + 2H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>钝化
&lt;ul>
&lt;li>&lt;strong>冷浓&lt;/strong>硝酸&lt;/li>
&lt;li>浓硫酸&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>碱&lt;/p>
&lt;ul>
&lt;li>$\ce{2Al + 2OH- + 2H2O = 2AlO^-_2 + 3H2 ^}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>盐&lt;/p>
&lt;ul>
&lt;li>$\ce{2Al + 3Fe^2+ = 2Al^3+ + 3Fe}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>金属氧化物&lt;/p>
&lt;ul>
&lt;li>见&lt;a href="#%e9%93%9d%e7%83%ad%e5%8f%8d%e5%ba%94">铝热反应&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="铝热反应">铝热反应&lt;/h4>
&lt;h5 id="实验装置">实验装置&lt;/h5>
&lt;img src="%E8%A3%85%E7%BD%AE.PNG" style="zoom:45%;" />
&lt;h5 id="实验原理">实验原理&lt;/h5>
&lt;p>铝在高温下与活动性弱于铝的金属的氧化物反应，放出大量的热，制出金属单质。&lt;/p>
&lt;p>$\ce{Fe2O3 + 2Al \overset{高温}{=} 2Fe + Al2O3}$ (铁水)&lt;/p>
&lt;h5 id="实验现象">实验现象&lt;/h5>
&lt;ol>
&lt;li>
&lt;p>镁带剧烈燃烧，放出大量的热，并发出耀眼的白光，引燃铝和氧化铁的混合物。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>铝和氧化铁的混合物在高温下发生剧烈的反应，并放出大量的热，纸漏斗的下部被烧穿，有熔融物落入沙中。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h5 id="原理应用">原理应用&lt;/h5>
&lt;ol>
&lt;li>制取&lt;strong>熔点较高&lt;/strong>、&lt;strong>活动性弱于铝&lt;/strong>的金属(通常贵于铝)，如铁、铬、锰、钨等。&lt;/li>
&lt;li>金属焊接，如野外焊接铁轨等。&lt;/li>
&lt;/ol>
&lt;h3 id="工业制备">工业制备&lt;/h3>
&lt;p>铝土矿 $\ce{-&amp;gt;[提纯] Al2O3}$&lt;/p>
&lt;p>$\ce{2Al2O3_{熔融} -&amp;gt;[电解][冰晶石] 4Al + 3O2 ^}$ (冰晶石：$\ce{Na3AlF6}$)&lt;/p>
&lt;h2 id="氧化物">氧化物&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>化学式&lt;/th>
&lt;th>特点&lt;/th>
&lt;th>用途&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>氧化铝&lt;/td>
&lt;td>$\ce{Al2O3}$&lt;/td>
&lt;td>两性氧化物、耐火耐高温&lt;/td>
&lt;td>制造耐火、耐高温器材；工业冶炼铝原料；制作各种宝石&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol>
&lt;li>酸
&lt;ul>
&lt;li>$\ce{Al2O3 + 6H+ = 2Al^3+ + 3H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>碱
&lt;ul>
&lt;li>$\ce{Al2O3 + 2OH- = 2AlO^-2 + H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="铝三角">铝三角&lt;/h2>
&lt;p>$\ce{Al^3+ &amp;lt;=&amp;gt;[3OH-][3H+] Al(OH)3 &amp;lt;=&amp;gt;[OH-][H+] AlO2-}$&lt;/p>
&lt;p>$\ce{Al^3+ + 3AlO^-2 + 6H2O = 4Al(OH)3}$&lt;/p>
&lt;h3 id="铝离子">铝离子&lt;/h3>
&lt;ol>
&lt;li>强碱
&lt;ol>
&lt;li>少量氢氧根
&lt;ul>
&lt;li>$\ce{Al^3+ + 3OH- = Al(OH)3 v}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>大量氢氧根
&lt;ul>
&lt;li>$\ce{Al^3+ + 4OH- = AlO^-2 + 2H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>弱碱
&lt;ul>
&lt;li>$\ce{Al^3+ 3NH3*H2O = Al(OH)3 v + 3NH^+4}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>偏铝酸根&lt;/li>
&lt;/ol>
&lt;h3 id="氢氧化铝">氢氧化铝&lt;/h3>
&lt;ol>
&lt;li>强酸
&lt;ul>
&lt;li>$\ce{Al(OH)3 + 3H+ = Al^3+ + 3H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>强碱
&lt;ul>
&lt;li>$\ce{Al(OH)3 + OH- = AlO^-2 + 2H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不与弱酸、弱碱反应&lt;/li>
&lt;li>不稳定性
&lt;ul>
&lt;li>$\ce{2Al(OH)3 \triangleq AL2O3 + 3H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="电离方程式">电离方程式&lt;/h4>
&lt;ol>
&lt;li>碱式电离：$\ce{Al(OH)3 &amp;lt;=&amp;gt; Al^3+ + 3OH-}$&lt;/li>
&lt;li>酸式电离：$\ce{Al(OH)3 &amp;lt;=&amp;gt; H+ + AlO^-2 + H2O}$&lt;/li>
&lt;/ol>
&lt;h3 id="偏铝酸根">偏铝酸根&lt;/h3>
&lt;ol>
&lt;li>强酸
&lt;ol>
&lt;li>少量氢离子
&lt;ul>
&lt;li>$\ce{AlO^-2 + H+ + H2O = Al(OH)3 v}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>大量氢离子
&lt;ul>
&lt;li>$\ce{AlO^-2 + 4H+ = Al^3+ 2H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>弱酸
&lt;ul>
&lt;li>$\ce{AlO^-2 + H+ + H2O = Al(OH)3 v}$
&lt;ul>
&lt;li>通入少量 $\ce{CO2}$ ：$\ce{2AlO^-2 + CO2 + 3H2O = 2Al(OH)3 v + CO^2^-3}$&lt;/li>
&lt;li>通入大量 $\ce{CO2}$ ：$\ce{AlO^-2 + CO2 + 2H2O = Al(OH)3 v + HCO^-3}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="明矾">明矾&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>化学式&lt;/th>
&lt;th>俗称&lt;/th>
&lt;th>用途&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>明矾&lt;/td>
&lt;td>$\ce{KAl(SO4)*12H2O}$&lt;/td>
&lt;td>明矾&lt;/td>
&lt;td>吸附水中悬浊物，用于净水&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>S硫</title><link>https://xuxihe.vercel.app/courses/chemistry/s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/s/</guid><description>&lt;h2 id="单质">单质&lt;/h2>
&lt;h3 id="物理性质">物理性质&lt;/h3>
&lt;ol>
&lt;li>俗称&lt;strong>硫磺&lt;/strong>&lt;/li>
&lt;li>黄色晶体&lt;/li>
&lt;li>质脆，易研成粉末&lt;/li>
&lt;li>难溶于水，微溶于酒精，易溶于二氯化碳&lt;/li>
&lt;/ol>
&lt;h3 id="化学性质">化学性质&lt;/h3>
&lt;p>硫单质的化学性质&lt;strong>比较活泼&lt;/strong>。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>弱&lt;/strong>氧化性
&lt;ul>
&lt;li>$\ce{S + Fe \triangleq FeS}$&lt;/li>
&lt;li>$\ce{S + 2Cu \triangleq Cu2S}$&lt;/li>
&lt;li>$\ce{S + H2 \triangleq H2S}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>弱&lt;/strong>还原性
&lt;ul>
&lt;li>$\ce{S + O2 \overset{点燃}{=} SO2}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>歧化反应
&lt;ul>
&lt;li>$\ce{3S + 6OH- \triangleq 2S^2- + SO^2-_3 + 3H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="氧化物">氧化物&lt;/h2>
&lt;h3 id="二氧化硫">二氧化硫&lt;/h3>
&lt;h4 id="物理性质-1">物理性质&lt;/h4>
&lt;ol>
&lt;li>无色，有刺激性气味的有毒气体&lt;/li>
&lt;li>密度大于空气($\pu{64 g*mol}$)&lt;/li>
&lt;li>易溶于水($1:40$)&lt;/li>
&lt;/ol>
&lt;h4 id="化学性质-1">化学性质&lt;/h4>
&lt;p>酸性氧化物。&lt;/p>
&lt;ol>
&lt;li>酸性氧化物通性
&lt;ul>
&lt;li>$\ce{SO2 + H2O &amp;lt;=&amp;gt; H2SO3}$&lt;/li>
&lt;li>酸性强与碳酸：$\ce{NaHCO3 + SO2 = NaHSO3 + CO2}$&lt;/li>
&lt;li>碱溶液
&lt;ul>
&lt;li>少量 $\ce{SO2}$：$\ce{SO2 + NaOH = NaHSO3}$&lt;/li>
&lt;li>足量 $\ce{SO2}$：$\ce{SO2 + 2NaOH = Na2SO3 + H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>强还原性
&lt;ul>
&lt;li>$\ce{2SO2 + O2 &amp;lt;=&amp;gt;[\triangle][催化剂] 2SO3}$&lt;/li>
&lt;li>$\ce{H2SO3 + O2 = 2H2SO4}$&lt;/li>
&lt;li>氧化剂
&lt;ul>
&lt;li>$\ce{SO2 + H2O2 = H2SO4}$&lt;/li>
&lt;li>$\ce{3SO2 + 2KMnO4 + 2H2O = 2MnO2 + K2SO4 + 2H2SO4}$ &lt;font color=purple>紫色&lt;/font> $\ce{-&amp;gt;}$ 无色&lt;/li>
&lt;li>$\ce{SO2 + 2FeCl3 + 2H2O = 2FeCl2 + H2SO4 + 2HCl}$ &lt;font color=#D3B85E>棕黄色&lt;/font> $\ce{-&amp;gt;}$ &lt;font color=lightgreen>浅绿色&lt;/font>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>卤素单质($\ce{Cl2}$、$\ce{Br2}$、$\ce{I2}$)
&lt;ul>
&lt;li>$\ce{SO2 + X2 + 2H2O = 2HX + H2SO4}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>弱氧化性
&lt;ul>
&lt;li>$\ce{SO2 + 2H2S = \color{red}{3S} + 2H2O}$ 或 $\ce{SO2 + 2H2S = \color{red}{3S v} + 2H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>漂白性
&lt;ul>
&lt;li>化合性漂白，一定条件下（如加热）可恢复。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="三氧化硫">三氧化硫&lt;/h3>
&lt;p>标准情况下为&lt;strong>液体&lt;/strong>。&lt;/p>
&lt;p>$\ce{SO3 + H2O = H2SO4}$&lt;/p>
&lt;h2 id="浓硫酸">(浓)硫酸&lt;/h2>
&lt;h3 id="工业制备">工业制备&lt;/h3>
&lt;p>$\ce{S/FeS2(黄铁矿) -&amp;gt;[O2] SO2 -&amp;gt;[400\sim500^\circ C 、O2][V2O5 催化剂] SO3 -&amp;gt;[H2O] H2SO4}$&lt;/p>
&lt;h3 id="物理性质-2">物理性质&lt;/h3>
&lt;p>无色、粘稠的油状液体&lt;/p>
&lt;p>沸点较高&lt;/p>
&lt;p>强吸水、脱水性&lt;/p>
&lt;h4 id="黑面包实验">“黑面包”实验&lt;/h4>
&lt;p>浓硫酸将蔗糖、纸张、木材等脱水，形成疏松多孔的碳，并伴随有刺激性气味的气体生成。&lt;/p>
&lt;p>$\ce{2H2SO4(浓) + C \triangleq CO2 ^ + 2SO2 ^ + 2H2O}$&lt;/p>
&lt;h3 id="化学性质-2">化学性质&lt;/h3>
&lt;ol>
&lt;li>强氧化性
&lt;ul>
&lt;li>$\ce{2H2SO4(浓) + Cu \triangleq CuSO4 + SO2 ^ + 2H2O}$ 气泡、白色粉末($\ce{CuSO4}$)、倒入水中呈&lt;font color=blue>蓝色&lt;/font>&lt;/li>
&lt;li>$\ce{2H2SO4(浓) + C \triangleq CO2 ^ + 2SO2 ^ + 2H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>高沸点酸制低沸点酸
&lt;ul>
&lt;li>$\ce{H2SO4(浓) + 2NaCl \triangleq Na2SO4 + 2HCl_{(g)}}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>钝化
&lt;ul>
&lt;li>&lt;strong>冷&lt;/strong>的&lt;strong>浓硫酸&lt;/strong>与铁、铝反应迅速生成致密氧化膜，阻止反应继续发生（&lt;strong>化学变化&lt;/strong>）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="稀硫酸">稀硫酸&lt;/h3>
&lt;p>&lt;a href="./%e9%85%b8.md">酸的通性&lt;/a> ($\ce{H+}$)&lt;/p>
&lt;h2 id="硫酸根离子的检验">硫酸根离子的检验&lt;/h2>
&lt;h3 id="原理">原理&lt;/h3>
&lt;p>$\ce{Ba^2+ + SO^-4 = BaSO4 v}$ 生成不溶于稀盐酸的白色沉淀&lt;/p>
&lt;h3 id="除杂">除杂&lt;/h3>
&lt;p>加入过量稀盐酸。&lt;/p>
&lt;p>$\ce{H+}$：$\ce{CO^2-_3}$、$\ce{SO^2-_3}$&lt;/p>
&lt;p>$\ce{Cl-}$：$\ce{Ag+}$&lt;/p>
&lt;p>排除：$\ce{HNO3 -&amp;gt; SO2 -&amp;gt; SO^2-_4}$、$\ce{H2SO4 -&amp;gt; SO^2-_4}$&lt;/p>
&lt;h2 id="氢硫酸">氢硫酸&lt;/h2>
&lt;ol>
&lt;li>二元弱酸&lt;/li>
&lt;li>还原性
&lt;ul>
&lt;li>$\ce{S^2- -&amp;gt; S -&amp;gt; SO2 -&amp;gt; SO^2-_4}$&lt;/li>
&lt;li>与氧气：
&lt;ul>
&lt;li>氧气少量：$\ce{2H2S_{(g)} + O2 \overset{点燃}{=} 2S v + 2H2O}$&lt;/li>
&lt;li>氧气过量：$\ce{2H2S_{(g)} + 3O2 \overset{点燃}{=} 2SO2 + 2H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>沉淀
&lt;ul>
&lt;li>$\ce{CuS}$、$\ce{FeS}$、$\ce{AgS}$、$\ce{HgS}$ 溶解度&lt;strong>极低&lt;/strong>&lt;/li>
&lt;li>$\ce{H2S + CuSO4 = CuS v + H2SO4}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="大苏打">大苏打&lt;/h2>
&lt;p>硫代硫酸钠，$\ce{Na2\overset{+2}{S2}O3}$，俗称大苏打。&lt;/p>
&lt;p>$\ce{\overset{+2}{S2}O3^2- + 2H+ = SO2 ^ + S v + H2O}$&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>N氮</title><link>https://xuxihe.vercel.app/courses/chemistry/n/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/n/</guid><description>&lt;h2 id="单质">单质&lt;/h2>
&lt;p>不溶于水。&lt;/p>
&lt;p>氮分子中两个氮原子以共价三键连接，化学性质稳定。&lt;/p>
&lt;p>低温液化，做制冷剂。&lt;/p>
&lt;h3 id="固氮">固氮&lt;/h3>
&lt;p>将大气中游离态的氮转化为氮的化合物的过程。&lt;/p>
&lt;h4 id="自然固氮">自然固氮&lt;/h4>
&lt;ol>
&lt;li>$\ce{N2 + O2 \overset{放电}{=} 2NO}$&lt;/li>
&lt;li>豆科植物的根瘤菌&lt;/li>
&lt;/ol>
&lt;h4 id="人工固氮">人工固氮&lt;/h4>
&lt;ol>
&lt;li>合成氨：$\ce{N2 + 3H2 &amp;lt;=&amp;gt;[高温、高压][催化剂] 2NH3}$&lt;/li>
&lt;li>汽车尾气：$\ce{N2 + O2 \overset{高温}{=} 2NO}$&lt;/li>
&lt;li>$\ce{N2 + 3Mg \overset{点燃}{=} Mg3N2}$&lt;/li>
&lt;/ol>
&lt;h2 id="氧化物">氧化物&lt;/h2>
&lt;h3 id="一氧化氮">一氧化氮&lt;/h3>
&lt;ol>
&lt;li>无色有毒气体&lt;/li>
&lt;li>不溶于水&lt;/li>
&lt;li>$\ce{2NO + O2 \overset{\color{red}{常温}}{=} 2NO2}$ 、$\ce{2NO2 \overset{\color{red}{高温}}{=} 2NO + O2}$&lt;/li>
&lt;li>$\ce{2NO + O2 + 2H2O = 2HNO3}$&lt;/li>
&lt;/ol>
&lt;h3 id="二氧化氮">二氧化氮&lt;/h3>
&lt;h4 id="物理性质">物理性质&lt;/h4>
&lt;ol>
&lt;li>红棕色、有刺激性气味的有毒气体&lt;/li>
&lt;li>密度大于空气&lt;/li>
&lt;li>易液化，易溶于水&lt;/li>
&lt;/ol>
&lt;h4 id="化学性质">化学性质&lt;/h4>
&lt;ol>
&lt;li>歧化反应：
&lt;ul>
&lt;li>$\ce{2NO2 + 2NaOH = NaNO3 + NaNO2 + H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>归中反应：
&lt;ul>
&lt;li>$\ce{NO2 + NO + 2NaOH = 2NaNO2 + H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>$\ce{4NO2 + O2 + 2H2O = 4HNO3}$&lt;/li>
&lt;/ol>
&lt;h2 id="氨">氨&lt;/h2>
&lt;h3 id="物理性质-1">物理性质&lt;/h3>
&lt;ol>
&lt;li>无色，有刺激性气味的气体&lt;/li>
&lt;li>密度小于空气&lt;/li>
&lt;li>极易溶于水($1:700$)&lt;/li>
&lt;li>可做制冷剂&lt;/li>
&lt;/ol>
&lt;h3 id="化学性质-1">化学性质&lt;/h3>
&lt;ol>
&lt;li>氨水(一水合氨)：
&lt;ul>
&lt;li>$\ce{NH3 + H2O &amp;lt;=&amp;gt; NH3*H2O &amp;lt;=&amp;gt; NH^+4 + OH-}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>还原性：
&lt;ul>
&lt;li>$\ce{4NH3 + 5O2 \underset{催化剂}{\triangleq} 4NO + 6H2O}$&lt;/li>
&lt;li>$\ce{4NH3 + 6NO \overset{催化剂}{=} 5N2 + 6H2O}$&lt;/li>
&lt;li>$\ce{8NH3 + 6NO2 \overset{催化剂}{=} 7N2 + 12H2O}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>弱碱性：
&lt;ul>
&lt;li>$\ce{NH3 + HCl = NH4Cl}$ &lt;font color=red>白烟&lt;/font>&lt;/li>
&lt;li>$\ce{Fe^3+ + 3NH3*H2O = Fe(OH)3 v + 3NH^+4}$&lt;/li>
&lt;li>$\ce{Al^3+ + 3NH3*H2O = Al(OH)3 v + 3NH^+4}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="铵盐">铵盐&lt;/h2>
&lt;h3 id="物理性质-2">物理性质&lt;/h3>
&lt;ol>
&lt;li>无色或白色晶体&lt;/li>
&lt;li>绝大多数易溶于水&lt;/li>
&lt;/ol>
&lt;h3 id="化学性质-2">化学性质&lt;/h3>
&lt;p>绝大多数受热易分解、与碱反应放出氨。&lt;/p>
&lt;ol>
&lt;li>受热分解：
&lt;ul>
&lt;li>$\ce{NH4Cl \triangleq NH3 ^ + HCl ^}$&lt;/li>
&lt;li>$\ce{NH4HCO3 \triangleq NH3 ^ + H2O + CO2 ^}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>与碱反应：
&lt;ul>
&lt;li>$\ce{2NH4Cl + Ca(OH)2 \triangleq CaCl2 + 2NH3 ^ + 2H2O}$ 氨气实验室制法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="快速制氨">快速制氨&lt;/h3>
&lt;p>浓氨水与碱石灰&lt;/p>
&lt;ol>
&lt;li>碱石灰溶于水放热，温度升高，氨气溶解度降低。&lt;/li>
&lt;li>碱石灰溶于水电离出大量 $\ce{OH-}$，氨气溶解度降低。&lt;/li>
&lt;li>碱石灰吸收水，使溶液中水分子数减少。&lt;/li>
&lt;/ol>
&lt;h3 id="检验">检验&lt;/h3>
&lt;p>与强碱反应生成氨。&lt;/p>
&lt;p>$\ce{NH^+4 + OH- \triangleq NH3 ^ + H2O}$&lt;/p>
&lt;h2 id="硝酸">硝酸&lt;/h2>
&lt;p>无色、易挥发、有刺激性气味的液体，与水任意比例互溶。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>不稳定性：&lt;/p>
&lt;ul>
&lt;li>$\ce{4HNO3(浓) \underset{或光照}{\triangleq} 4NO2 ^ + O2 + 2H2O}$ &lt;font color=brown>棕色试剂瓶&lt;/font>阴凉处保存，久置呈黄色&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>强氧化性：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$\ce{4HNO3(浓) + Cu = Cu(NO3)2 + 2NO2 ^ + 2H2O}$&lt;/th>
&lt;th>迅速反应，放热，产生大量&lt;font color=brown>红棕色气体&lt;/font>，&lt;font color=green>溶液变绿&lt;/font>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\ce{8HNO3(稀) + 3Cu = 3Cu(NO3)2 + 2NO ^ + 4H2O}$&lt;/td>
&lt;td>&lt;strong>反应逐渐加快，产生少量无色气体，遇空气变&lt;font color=brown>红棕色&lt;/font>，&lt;font color=blue>溶液变蓝&lt;/font>&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$\ce{4HNO3(浓) + Zn = Zn(NO3)2 + 2NO2 ^ + 2H2O}$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\ce{8HNO3(稀) + 3Zn = 3Zn(NO3)2 + 2NO ^ 4H2O}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\ce{10HNO3(极稀) + 4Zn = 4Zn(NO3)2 + NH3NO3 + 3H2O}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="./S.md/#%e5%8c%96%e5%ad%a6%e6%80%a7%e8%b4%a8">钝化&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="王水">王水&lt;/h3>
&lt;p>浓硝酸 $:$ 浓盐酸 $= 1:3$ $(V)$&lt;/p>
&lt;p>可溶解金、铂，钝化的铁、铝等。&lt;/p>
&lt;h3 id="工业制法">工业制法&lt;/h3>
&lt;p>$\ce{N2 -&amp;gt;[H2] NH3 -&amp;gt;[O2] NO -&amp;gt;[O2] NO2 -&amp;gt;[H2O] HNO3}$&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>Si硅</title><link>https://xuxihe.vercel.app/courses/chemistry/si/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/courses/chemistry/si/</guid><description>&lt;h2 id="硅">硅&lt;/h2>
&lt;h3 id="物理性质">物理性质&lt;/h3>
&lt;p>带有金属光泽的灰黑色固体，熔点高，硬度大，有脆性。在自然界中，主要以硅酸盐（大多数矿物）和氧化物（水晶、玛瑙）的形式存在。&lt;/p>
&lt;h3 id="化学性质">化学性质&lt;/h3>
&lt;p>常温下不活泼，一般不与其他物质反应，但可以与氟、氢氟酸、碱反应。&lt;/p>
&lt;ol>
&lt;li>$\ce{Si + 2F2 = SiF4 ^}$&lt;/li>
&lt;li>$\ce{Si + 4HF = SiF4 ^ + 2H2 ^}$&lt;/li>
&lt;li>$\ce{Si + 2NaOH + H2O = NaSiO3 + 2H2 ^}$&lt;/li>
&lt;/ol>
&lt;p>在加热或者点燃的条件下可以与氢气、氧气、氯气等反应。&lt;/p>
&lt;ol>
&lt;li>$\ce{Si + O2/2H2/2Cl2 \underset{或加热}{\triangleq} SiO2/SiH4/SiCl4}$&lt;/li>
&lt;/ol>
&lt;h3 id="工业制法">工业制法&lt;/h3>
&lt;ol>
&lt;li>粗硅：$\ce{SiO2 + 2C \overset{高温}{=} Si + 2CO ^}$&lt;/li>
&lt;li>提纯：$\ce{粗硅 -&amp;gt;[HCl] SiHCl3 -&amp;gt;[H2] 高纯硅}$&lt;/li>
&lt;/ol>
&lt;h2 id="二氧化硅">二氧化硅&lt;/h2>
&lt;h3 id="物理性质-1">物理性质&lt;/h3>
&lt;p>熔点高，硬度大，难溶于水。天然存在晶体和无定型两种，统称硅石。&lt;/p>
&lt;h3 id="化学性质-1">化学性质&lt;/h3>
&lt;ol>
&lt;li>与碱反应：$\ce{SiO2 + NaOH = NaSiO3}$&lt;/li>
&lt;/ol>
&lt;h2 id="硅酸">硅酸&lt;/h2>
&lt;h2 id="硅酸盐">硅酸盐&lt;/h2>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>数学表示</title><link>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E6%95%B0%E5%AD%A6%E8%A1%A8%E7%A4%BA/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E6%95%B0%E5%AD%A6%E8%A1%A8%E7%A4%BA/</guid><description>&lt;h1 id="数学表示">数学表示&lt;/h1>
&lt;ol>
&lt;li>$x|y$ ：$x$ 整除 $y$，即存在 $d\in Z$ 使得 $y=dx$&lt;/li>
&lt;/ol></description></item><item><title>突变与重组</title><link>https://xuxihe.vercel.app/courses/biology/%E7%AA%81%E5%8F%98%E4%B8%8E%E9%87%8D%E7%BB%84/</link><pubDate>Thu, 07 Jul 2022 22:33:05 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/biology/%E7%AA%81%E5%8F%98%E4%B8%8E%E9%87%8D%E7%BB%84/</guid><description>&lt;h2 id="基因突变">基因突变&lt;/h2>
&lt;p>DNA分子中发生碱基的&lt;strong>替换&lt;/strong>、&lt;strong>增添&lt;/strong>或&lt;strong>缺失&lt;/strong>，而引起的基因碱基序列的改变。&lt;/p>
&lt;ol>
&lt;li>随机性：可以在任何细胞中的任何时间在任何基因上发生，主要发生在有丝分裂前和减数分裂前的间期&lt;/li>
&lt;li>不定向性&lt;/li>
&lt;/ol>
&lt;h3 id="基因突变不一定使性状改变">基因突变不一定使性状改变&lt;/h3>
&lt;ol>
&lt;li>突变前后，经转录形成的密码子所决定的氨基酸相同&lt;/li>
&lt;li>显性纯合子突变为杂合子：$\ce{AA\rightarrow Aa}$&lt;/li>
&lt;li>内含子发生碱基突变&lt;/li>
&lt;/ol>
&lt;h3 id="细胞的癌变">细胞的癌变&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>原癌基因：表达的蛋白质是细胞正常生长和增殖所必须的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>抑癌基因：抑制细胞的生长和繁殖，或者促进细胞凋亡&lt;/p>
&lt;/li>
&lt;li>
&lt;p>癌变原因&lt;/p>
&lt;ol>
&lt;li>原癌基因突变或过量表达，导致相应蛋白质活性过强&lt;/li>
&lt;li>抑癌基因突变或表达受抑制，导致相应蛋白质活性减弱或失活&lt;/li>
&lt;li>相关基因甲基化&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>癌细胞特点&lt;/p>
&lt;ol>
&lt;li>能够无限增殖&lt;/li>
&lt;li>形态结构发生显著变化&lt;/li>
&lt;li>细胞膜上糖蛋白等物质减少，细胞之间的黏着性显著降低，容易在体内分散和转移&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="例子">例子&lt;/h3>
&lt;ul>
&lt;li>囊性纤维化：基因缺失&lt;/li>
&lt;li>豌豆皱粒：基因增添&lt;/li>
&lt;li>镰状细胞贫血：基因替换&lt;/li>
&lt;/ul>
&lt;h2 id="基因重组">基因重组&lt;/h2>
&lt;p>生物体进行有性生殖的过程中，控制不同性状的基因的重新组合。&lt;/p>
&lt;ol>
&lt;li>非同源染色体自由组合&lt;/li>
&lt;li>同源染色体的非姐妹染色单体缠绕互换&lt;/li>
&lt;/ol>
&lt;h2 id="染色体变异">染色体变异&lt;/h2>
&lt;p>体细胞或生殖细胞内染色体数目或结构的变化。&lt;/p>
&lt;h3 id="数目">数目&lt;/h3>
&lt;ol>
&lt;li>单倍体：花粉（生殖细胞）离体培养&lt;font color=red>（注意：单倍体是指较正常植株，染色体组数量减半，不一定只有 $1$ 个或奇数个染色体组）&lt;/font>&lt;/li>
&lt;li>二倍体：全部动物和过半数的高等植物&lt;/li>
&lt;li>多倍体：
&lt;ol>
&lt;li>三倍体：无籽西瓜、无籽香蕉（减数分裂时出现联会紊乱，不能产生可育配子）&lt;/li>
&lt;li>四倍体：番茄、马铃薯、葡萄&lt;/li>
&lt;li>六倍体：小麦&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>低温诱导或秋水仙素能抑制纺锤体的形成&lt;/p>
&lt;h3 id="结构">结构&lt;/h3>
&lt;h4 id="类型">类型&lt;/h4>
&lt;ol>
&lt;li>缺失&lt;/li>
&lt;li>重复&lt;/li>
&lt;li>易位（移接）：染色体的某一片段移接到另一条&lt;strong>非同源染色体&lt;/strong>上&lt;/li>
&lt;li>倒位&lt;/li>
&lt;/ol>
&lt;h4 id="例子-1">例子&lt;/h4>
&lt;ul>
&lt;li>猫叫综合征：$5$ 号染色体缺失&lt;/li>
&lt;li>果蝇残翅：缺失&lt;/li>
&lt;li>果蝇棒状眼：重复&lt;/li>
&lt;li>果蝇花斑眼：易位（移接）&lt;/li>
&lt;li>果蝇卷翅：倒位&lt;/li>
&lt;li>唐氏综合征（ $21$ 三体综合征）：$21$ 号染色体多一条&lt;/li>
&lt;/ul>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>性状及遗传病</title><link>https://xuxihe.vercel.app/courses/biology/%E6%80%A7%E7%8A%B6%E5%8F%8A%E9%81%97%E4%BC%A0%E7%97%85/</link><pubDate>Thu, 07 Jul 2022 22:10:12 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/biology/%E6%80%A7%E7%8A%B6%E5%8F%8A%E9%81%97%E4%BC%A0%E7%97%85/</guid><description>&lt;ul>
&lt;li>果蝇红眼（显）白眼（隐）：伴X染色体&lt;/li>
&lt;li>抗维生素D佝偻病：伴X显性&lt;/li>
&lt;li>红绿色盲：伴X隐性&lt;/li>
&lt;li>白化病：伴X隐性&lt;/li>
&lt;li>血友病：伴X隐性&lt;/li>
&lt;li>苯丙酮尿症：常染色体隐性&lt;/li>
&lt;li>猫叫综合征：染色体异常（ $5$ 号染色体缺失）&lt;/li>
&lt;li>唐氏综合征（ $21$ 三体综合征、先天愚型）：染色体异常&lt;/li>
&lt;li>软骨发育不全：多基因遗传病（单一软骨发育不全基因即致病）&lt;/li>
&lt;/ul>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>光合呼吸有关计算</title><link>https://xuxihe.vercel.app/courses/biology/%E5%85%89%E5%90%88%E5%91%BC%E5%90%B8%E6%9C%89%E5%85%B3%E8%AE%A1%E7%AE%97/</link><pubDate>Thu, 07 Jul 2022 21:59:35 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/biology/%E5%85%89%E5%90%88%E5%91%BC%E5%90%B8%E6%9C%89%E5%85%B3%E8%AE%A1%E7%AE%97/</guid><description>&lt;h2 id="光照强度">光照强度&lt;/h2>
&lt;ol>
&lt;li>黑暗：只有呼吸作用&lt;/li>
&lt;li>弱光：光合速率小于呼吸速率&lt;/li>
&lt;li>中等光：光合速率等于呼吸速率&lt;/li>
&lt;li>强光：光合速率大于呼吸速率&lt;/li>
&lt;/ol>
&lt;h2 id="计算">计算&lt;/h2>
&lt;p>总光合速率 $=$ 净光合速率 $+$ 呼吸速率&lt;/p>
&lt;ol>
&lt;li>总光合速率（有负值）
&lt;ul>
&lt;li>$\ce{CO2}$ 固定量&lt;/li>
&lt;li>$\ce{O2}$ 产生量&lt;/li>
&lt;li>有机物产生量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>净光合速率（无负值）
&lt;ul>
&lt;li>$\ce{CO2}$ 吸收量（外界）&lt;/li>
&lt;li>$\ce{O2}$ 释放量&lt;/li>
&lt;li>有机物积累量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>光合色素</title><link>https://xuxihe.vercel.app/courses/biology/%E5%85%89%E5%90%88%E8%89%B2%E7%B4%A0/</link><pubDate>Tue, 05 Jul 2022 22:15:25 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/biology/%E5%85%89%E5%90%88%E8%89%B2%E7%B4%A0/</guid><description>&lt;p>&lt;a href="https://imgtu.com/i/jNoDns" target="_blank" rel="noopener">&lt;img src="https://s1.ax1x.com/2022/07/05/jNoDns.jpg" alt="jNoDns.jpg" style="zoom: 67%;" />&lt;/a>&lt;/p>
&lt;h2 id="实验">实验&lt;/h2>
&lt;p>见&lt;a href="%e8%af%95%e5%89%82%e4%b8%8e%e5%ae%9e%e9%aa%8c.md">试剂与实验&lt;/a>&lt;/p>
&lt;h2 id="光合色素">光合色素&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">色素种类&lt;/th>
&lt;th style="text-align:center">色素颜色&lt;/th>
&lt;th style="text-align:center">色素含量（色条宽度）&lt;/th>
&lt;th style="text-align:center">溶解度（扩散速度）（高度）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">叶绿素a&lt;/td>
&lt;td style="text-align:center">&lt;font color=#047475>蓝绿色&lt;/font>&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">叶绿素b&lt;/td>
&lt;td style="text-align:center">&lt;font color=#8acd01>黄绿色&lt;/font>&lt;/td>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">胡萝卜素&lt;/td>
&lt;td style="text-align:center">&lt;font color=#ff7f00>橙黄色&lt;/font>&lt;/td>
&lt;td style="text-align:center">4&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">叶黄素&lt;/td>
&lt;td style="text-align:center">&lt;font color=#f8ce3a>黄色&lt;/font>&lt;/td>
&lt;td style="text-align:center">3&lt;/td>
&lt;td style="text-align:center">2&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="吸收光谱">吸收光谱&lt;/h2>
&lt;ol>
&lt;li>叶绿素（叶绿素a和叶绿素b）主要吸收&lt;font color=#4B0082>蓝紫光&lt;/font>和&lt;font color=red>红光&lt;/font>&lt;/li>
&lt;li>类胡萝卜素（胡萝卜素和叶黄素）主要吸收&lt;font color=#4B0082>蓝紫光&lt;/font>&lt;/li>
&lt;/ol>
&lt;p>&lt;font color=red>注意：当植物光合速率等于呼吸速率时，绿色器官光合作用强度大于呼吸作用强度。&lt;/font>&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>生物呼吸方式</title><link>https://xuxihe.vercel.app/courses/biology/%E7%94%9F%E7%89%A9%E5%91%BC%E5%90%B8%E6%96%B9%E5%BC%8F/</link><pubDate>Tue, 05 Jul 2022 22:05:29 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/biology/%E7%94%9F%E7%89%A9%E5%91%BC%E5%90%B8%E6%96%B9%E5%BC%8F/</guid><description>&lt;h2 id="厌氧菌">厌氧菌&lt;/h2>
&lt;ol>
&lt;li>兼性厌氧菌：酵母菌&lt;/li>
&lt;li>严格厌氧菌：乳酸菌、破伤风杆菌&lt;/li>
&lt;/ol>
&lt;h2 id="无氧呼吸产物">无氧呼吸产物&lt;/h2>
&lt;h3 id="乳酸">乳酸&lt;/h3>
&lt;ul>
&lt;li>马铃薯块茎&lt;/li>
&lt;li>甜菜块根&lt;/li>
&lt;li>玉米胚&lt;/li>
&lt;li>骨骼肌&lt;/li>
&lt;li>哺乳动物成熟红细胞（只能进行无氧呼吸）&lt;/li>
&lt;/ul>
&lt;h3 id="酒精-spacececo2">酒精 $+\space\ce{CO2}$&lt;/h3>
&lt;ul>
&lt;li>高等植物&lt;/li>
&lt;li>酵母菌&lt;/li>
&lt;/ul>
&lt;h2 id="氧气消耗量">氧气消耗量&lt;/h2>
&lt;ol>
&lt;li>$\ce{O2}&amp;gt;\ce{CO2}$：有脂肪等分解&lt;/li>
&lt;li>$\ce{O2}=\ce{CO2}$：只进行有氧呼吸&lt;/li>
&lt;li>$\ce{O2}&amp;lt;\ce{CO2}$：同时进行有氧和无氧呼吸&lt;/li>
&lt;li>$\ce{O2}=0$：只进行无氧呼吸&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>物质的运输</title><link>https://xuxihe.vercel.app/courses/biology/%E7%89%A9%E8%B4%A8%E7%9A%84%E8%BF%90%E8%BE%93/</link><pubDate>Mon, 04 Jul 2022 23:06:47 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/biology/%E7%89%A9%E8%B4%A8%E7%9A%84%E8%BF%90%E8%BE%93/</guid><description>&lt;h2 id="自由扩散简单扩散">自由扩散（简单扩散）&lt;/h2>
&lt;ol>
&lt;li>无机小分子
&lt;ul>
&lt;li>$\ce{H2O}$&lt;/li>
&lt;li>$\ce{O2}$&lt;/li>
&lt;li>$\ce{CO2}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>有机小分子
&lt;ul>
&lt;li>苯&lt;/li>
&lt;li>尿素&lt;/li>
&lt;li>甘油&lt;/li>
&lt;li>乙醇&lt;/li>
&lt;li>脂质小分子：（维生素D、性激素、胆固醇）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="协助扩散">协助扩散&lt;/h2>
&lt;ol>
&lt;li>载体蛋白（构象改变）
&lt;ul>
&lt;li>葡萄糖进入红细胞&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通道蛋白（构象不变）
&lt;ul>
&lt;li>神经、肌肉细胞 $\ce{K+}$ 离子外流、$\ce{Na+}$ 离子内流&lt;/li>
&lt;li>水通道（主要）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="主动运输">主动运输&lt;/h2>
&lt;ul>
&lt;li>葡萄糖进入细胞（除红细胞）&lt;/li>
&lt;li>一般生物小分子进出细胞（如核苷酸）&lt;/li>
&lt;li>一般离子主动运输（如 $\ce{K+}$ 进入大肠杆菌）&lt;/li>
&lt;/ul>
&lt;h2 id="胞吞胞吐">胞吞胞吐&lt;/h2>
&lt;ul>
&lt;li>白细胞吞噬细菌&lt;/li>
&lt;li>变形虫吞食&lt;/li>
&lt;li>生物大分子&lt;/li>
&lt;li>分泌蛋白
&lt;ul>
&lt;li>部分激素
&lt;ul>
&lt;li>胰岛素&lt;/li>
&lt;li>生长激素&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>消化酶
&lt;ul>
&lt;li>唾液淀粉酶&lt;/li>
&lt;li>胃蛋白酶&lt;/li>
&lt;li>胰蛋白酶&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>核体&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>病毒分类</title><link>https://xuxihe.vercel.app/courses/biology/%E7%97%85%E6%AF%92%E5%88%86%E7%B1%BB/</link><pubDate>Mon, 04 Jul 2022 22:45:54 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/biology/%E7%97%85%E6%AF%92%E5%88%86%E7%B1%BB/</guid><description>&lt;h2 id="宿主">宿主&lt;/h2>
&lt;ol>
&lt;li>动物病毒&lt;/li>
&lt;li>植物病毒&lt;/li>
&lt;li>噬菌体&lt;/li>
&lt;/ol>
&lt;h2 id="遗传物质">遗传物质&lt;/h2>
&lt;ol>
&lt;li>DNA
&lt;ul>
&lt;li>乙肝病毒&lt;/li>
&lt;li>噬菌体&lt;/li>
&lt;li>肺炎链球菌&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>RNA
&lt;ul>
&lt;li>烟草花叶病毒&lt;/li>
&lt;li>HIV（艾滋病毒）&lt;/li>
&lt;li>各种流感病毒（COVID-19）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="生命">生命&lt;/h2>
&lt;ol>
&lt;li>病毒在未进入细胞时没有生命&lt;/li>
&lt;li>繁殖是病毒唯一的生命活动&lt;/li>
&lt;li>病毒不能独立代谢，因而不属于生命系统的结构层次&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>原核与真核</title><link>https://xuxihe.vercel.app/courses/biology/%E5%8E%9F%E6%A0%B8%E4%B8%8E%E7%9C%9F%E6%A0%B8/</link><pubDate>Sat, 02 Jul 2022 22:20:32 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/biology/%E5%8E%9F%E6%A0%B8%E4%B8%8E%E7%9C%9F%E6%A0%B8/</guid><description>&lt;h2 id="区别">区别&lt;/h2>
&lt;p>有无&lt;strong>成型&lt;/strong>的细胞核&lt;/p>
&lt;h2 id="原核">原核&lt;/h2>
&lt;p>细胞壁（除支原体）：肽聚糖&lt;/p>
&lt;ol>
&lt;li>蓝细菌：色球蓝细菌、颤蓝细菌、念珠蓝细菌、&lt;strong>发菜&lt;/strong>（蓝细菌群体的集合）&lt;/li>
&lt;li>大肠杆菌（球状、弧状、链状……）&lt;/li>
&lt;li>乳酸菌&lt;/li>
&lt;li>硝化细菌&lt;/li>
&lt;li>支原体（目前发现的最小细胞）&lt;/li>
&lt;li>衣原体&lt;/li>
&lt;/ol>
&lt;h2 id="真核">真核&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>动物&lt;/p>
&lt;/li>
&lt;li>
&lt;p>植物（果胶和纤维素）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>真菌（几丁质）&lt;/p>
&lt;ul>
&lt;li>食用菌&lt;/li>
&lt;li>霉菌：毛霉、曲霉、根霉……&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>酵母菌&lt;/p>
&lt;/li>
&lt;li>
&lt;p>原生动物（单细胞生物）：草履虫、眼虫、衣藻、变形虫&lt;/p>
&lt;/li>
&lt;li>
&lt;p>黑藻&lt;/p>
&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>试剂使用</title><link>https://xuxihe.vercel.app/courses/biology/%E8%AF%95%E5%89%82%E4%B8%8E%E5%AE%9E%E9%AA%8C/</link><pubDate>Sat, 02 Jul 2022 22:17:34 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/biology/%E8%AF%95%E5%89%82%E4%B8%8E%E5%AE%9E%E9%AA%8C/</guid><description>&lt;h2 id="斐林试剂">斐林试剂&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>用途：检测还原糖&lt;/p>
&lt;/li>
&lt;li>
&lt;p>成分&lt;/p>
&lt;ul>
&lt;li>甲液：$\pu{0.1 g/mL}\space\ce{NaOH(aq)}$&lt;/li>
&lt;li>乙夜：$\pu{0.05 g/mL}\space \ce{CuSO4(aq)}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>用法&lt;/p>
&lt;ol>
&lt;li>
&lt;p>甲乙液等量混合&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注入待测组织样液&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$\pu{50 \sim 60 ^\circ C}$ 水浴加热 $\pu{2 min}$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>现象：砖红色沉淀&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="苏丹iii">苏丹III&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>用途：检测脂肪&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用法&lt;/p>
&lt;ol>
&lt;li>取材&lt;/li>
&lt;li>制片
&lt;ol>
&lt;li>染色 $\pu{3 min}$&lt;/li>
&lt;li>用吸水纸吸去染液&lt;/li>
&lt;li>$50%$ 的酒精&lt;strong>洗去浮色&lt;/strong>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>现象：脂肪被染成&lt;font color=orange>橘黄色&lt;/font>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="双缩脲试剂">双缩脲试剂&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>用途：检测蛋白质&lt;/p>
&lt;/li>
&lt;li>
&lt;p>成分&lt;/p>
&lt;ul>
&lt;li>A液：$\pu{0.1 g/mL}\space\ce{NaOH(aq)}$&lt;/li>
&lt;li>B液：$\pu{0.01 g/mL}\space \ce{CuSO4(aq)}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>用法&lt;/p>
&lt;ol>
&lt;li>将A液与待测组织样液混合&lt;/li>
&lt;li>加入 $4$ 滴B液&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>现象：溶液颜色变为&lt;font color=purple>紫色&lt;/font>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>原理：在碱性条件下，$\ce{CuSO4}$ 与肽键反应形成络合物（变性、加热后均可）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="碘液">碘液&lt;/h2>
&lt;ol>
&lt;li>用途：检测淀粉（多糖）&lt;/li>
&lt;li>现象：变蓝&lt;/li>
&lt;/ol>
&lt;h2 id="碱性染料">碱性染料&lt;/h2>
&lt;ol>
&lt;li>用途：将细胞核中染色体染色&lt;/li>
&lt;li>包括
&lt;ul>
&lt;li>甲紫&lt;/li>
&lt;li>醋酸洋红&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="酶的活性">酶的活性&lt;/h2>
&lt;ol>
&lt;li>温度
&lt;ol>
&lt;li>材料
&lt;ul>
&lt;li>淀粉酶溶液 （$\ce{H2O2}$ 加热分解）&lt;/li>
&lt;li>缓冲液（维持PH $= 7$）&lt;/li>
&lt;li>可溶性淀粉溶液&lt;/li>
&lt;li>碘液 （斐林试剂需要水浴加热）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>步骤
&lt;ol>
&lt;li>将底物与酶&lt;strong>分别&lt;/strong>加热（冷却）至设定温度&lt;/li>
&lt;li>将底物与酶混合并维持设定温度&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>PH值
&lt;ul>
&lt;li>材料
&lt;ul>
&lt;li>$\ce{H2O2(aq)}$（淀粉在 PH $&amp;lt;7$ 时水解）&lt;/li>
&lt;li>新鲜的肝脏研磨液&lt;/li>
&lt;li>$\ce{HCl(aq)}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="溴麝香草酚蓝溶液">溴麝香草酚蓝溶液&lt;/h2>
&lt;ol>
&lt;li>与 $\ce{CO2}$ 反应，由&lt;font color=blue>蓝色&lt;/font>先变&lt;font color=green>绿色&lt;/font>再变&lt;font color=dayellow>黄色&lt;/font>&lt;/li>
&lt;li>根据变成黄色的时间，可判断 $\ce{CO2}$ 含量情况&lt;/li>
&lt;/ol>
&lt;h2 id="重铬酸钾溶液">重铬酸钾溶液&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;font color=orange>橙色&lt;/font>的重铬酸钾溶液在酸性条件下与乙醇反应，变成&lt;font color=#668800>灰绿色&lt;/font>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>与葡萄糖发生颜色反应（应延长培养时间，尽量耗尽葡萄糖）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="绿叶中的色素的提取和分离">绿叶中的色素的提取和分离&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>材料&lt;/p>
&lt;ul>
&lt;li>新鲜的绿叶&lt;/li>
&lt;li>无水乙醇（也可以用 $95%$ 的酒精加入适量无水碳酸钠）&lt;/li>
&lt;li>层析液（有毒）&lt;/li>
&lt;li>二氧化硅（有助于更充分的研磨）&lt;/li>
&lt;li>碳酸钙（防止色素被酸破坏）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>步骤&lt;/p>
&lt;ol>
&lt;li>
&lt;p>提取色素&lt;/p>
&lt;ol>
&lt;li>绿叶去主叶脉，剪碎&lt;/li>
&lt;li>加入少许二氧化硅和碳酸钙，再加无水乙醇，迅速充分研磨&lt;/li>
&lt;li>迅速导入底部为单层尼龙布的漏斗中过滤&lt;/li>
&lt;li>收集滤液到试管，棉花塞严（色素易挥发，易氧化）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>制备滤纸条&lt;/p>
&lt;ol>
&lt;li>将干燥定性试纸剪成宽度略小于试管直径、长度略小于试管的滤纸条&lt;/li>
&lt;li>在滤纸条端剪去两角&lt;/li>
&lt;li>在离底部 $\pu{1cm}$ 处铅笔画横线（细、直、齐）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>画滤液细线&lt;/p>
&lt;ol>
&lt;li>用毛细吸管（盖玻片）沿铅笔线均匀的画出一条细线。&lt;/li>
&lt;li>待滤液干后，再重画一到两次&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>分离&lt;/p>
&lt;ol>
&lt;li>将滤纸条有滤液细线的一端插入有层析液的试管中（滤液细线不触碰层析液）&lt;/li>
&lt;li>棉花塞紧试管管口&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>现象：见&lt;a href="%e5%85%89%e5%90%88%e8%89%b2%e7%b4%a0.md">光合色素&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="根尖分生区组织细胞有丝分裂">根尖分生区组织细胞有丝分裂&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>材料&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#%e7%a2%b1%e6%80%a7%e6%9f%93%e6%96%99">碱性染料&lt;/a>&lt;/li>
&lt;li>盐酸&lt;/li>
&lt;li>$95%$ 的酒精&lt;/li>
&lt;li>洋葱根尖分生区&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>步骤&lt;/p>
&lt;ol>
&lt;li>解离（细胞死亡）
&lt;ol>
&lt;li>材料：盐酸与酒精 $1:1$ 混合溶液&lt;/li>
&lt;li>目的：用药液使组织中的细胞相互分离开来&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>漂洗：放入&lt;strong>清水&lt;/strong>中，洗去药液，防止解离过度&lt;/li>
&lt;li>染色&lt;/li>
&lt;li>制片：按压盖玻片，使细胞分散开来，有利于观察&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="观察叶绿体和细胞质流动">观察叶绿体和细胞质流动&lt;/h2>
&lt;p>材料：藓类叶、菠菜叶、番薯叶、新鲜的黑藻&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>垂直</title><link>https://xuxihe.vercel.app/courses/gre/%E5%9E%82%E7%9B%B4/</link><pubDate>Sat, 02 Jul 2022 22:14:06 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/gre/%E5%9E%82%E7%9B%B4/</guid><description>&lt;p>&lt;a href="https://imgtu.com/i/j3Y4Rx" target="_blank" rel="noopener">&lt;img src="https://s1.ax1x.com/2022/07/02/j3Y4Rx.jpg" alt="j3Y4Rx.jpg" style="zoom:50%;" />&lt;/a>&lt;/p>
&lt;h2 id="1">$1$&lt;/h2>
&lt;ol>
&lt;li>定义：$\forall m \subset \alpha,l \perp m\Rightarrow l\perp \alpha$&lt;/li>
&lt;li>判定：$m\subset\alpha,n\subset\alpha,m\cap n\neq\varnothing,l\perp m,l\perp n\Rightarrow l\perp\alpha$&lt;/li>
&lt;/ol>
&lt;h2 id="2">$2$&lt;/h2>
&lt;p>$l\perp\alpha,m\subset\alpha\Rightarrow l\perp m$&lt;/p>
&lt;h2 id="3">$3$&lt;/h2>
&lt;p>$m\subset\alpha,n\subset\alpha,m\cap n\neq\varnothing,l\perp m,l\perp n,l\subset\beta\Rightarrow\alpha\perp\beta$&lt;/p>
&lt;h2 id="4">$4$&lt;/h2>
&lt;p>$\alpha\perp\beta,\alpha\cap\beta=l,m\subset\alpha,m\perp l,a\sub\beta\Rightarrow m\perp a$&lt;/p>
&lt;h2 id="5">$5$&lt;/h2>
&lt;p>$l\perp\beta,l\subset\alpha\Rightarrow\alpha\perp\beta$&lt;/p>
&lt;h2 id="6">$6$&lt;/h2>
&lt;p>$\alpha\perp\beta,\alpha\cap\beta=l,m\subset\alpha,m\perp l\Rightarrow m\perp\beta$&lt;/p>
&lt;h2 id="三垂线定理">三垂线定理&lt;/h2>
&lt;ol>
&lt;li>定理：$l$ 是平面 $\alpha$ 的一条斜线，$l$ 在平面 $\alpha$ 上的射影为 $m$ ，$a\subset \alpha $ ，$a\perp m\Rightarrow a\perp l$&lt;/li>
&lt;li>逆定理：$l$ 是平面 $\alpha$ 的一条斜线，$l$ 在平面 $\alpha$ 上的射影为 $m$ ，$a\subset \alpha $ ，$a\perp l\Rightarrow a\perp m$&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>生物</title><link>https://xuxihe.vercel.app/project/biology/</link><pubDate>Sat, 02 Jul 2022 21:24:10 +0800</pubDate><guid>https://xuxihe.vercel.app/project/biology/</guid><description/></item><item><title>平行</title><link>https://xuxihe.vercel.app/courses/gre/%E5%B9%B3%E8%A1%8C/</link><pubDate>Sat, 02 Jul 2022 21:21:16 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/gre/%E5%B9%B3%E8%A1%8C/</guid><description>&lt;p>&lt;a href="https://imgtu.com/i/j3Y4Rx" target="_blank" rel="noopener">&lt;img src="https://s1.ax1x.com/2022/07/02/j3Y4Rx.jpg" alt="j3Y4Rx.jpg" style="zoom: 50%;" />&lt;/a>&lt;/p>
&lt;h2 id="1">$1$&lt;/h2>
&lt;ol>
&lt;li>定义：$l \cap \alpha = \varnothing\Rightarrow l//\alpha$&lt;/li>
&lt;li>判定：$l \nsubseteq \alpha,m \subset \alpha,l // m\Rightarrow l//\alpha$&lt;/li>
&lt;/ol>
&lt;h2 id="2">$2$&lt;/h2>
&lt;p>$l//\alpha,l\subset\beta,\alpha\cap\beta=m\Rightarrow l//m$&lt;/p>
&lt;h2 id="3">$3$&lt;/h2>
&lt;p>$l\subset\alpha,m\subset\alpha,a\subset\beta,b\subset\beta,l\cap m\neq\varnothing,a\cap b\neq\varnothing, l//a,m//b \Rightarrow \alpha//\beta$&lt;/p>
&lt;h2 id="4">$4$&lt;/h2>
&lt;p>$\gamma\cap\alpha=l,\gamma\cap\beta=m,\alpha//\beta \Rightarrow l//m$&lt;/p>
&lt;p>$l\perp\alpha,m\perp\alpha\Rightarrow l//m$&lt;/p>
&lt;h2 id="5">$5$&lt;/h2>
&lt;p>$l\subset\alpha,m\subset\alpha,l\cap m\neq\varnothing,l//\beta,m//\beta\Rightarrow \alpha//\beta$&lt;/p>
&lt;h2 id="6">$6$&lt;/h2>
&lt;p>$\alpha//\beta,l\subset\alpha\Rightarrow l//\beta$&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>几何基本定理</title><link>https://xuxihe.vercel.app/project/gre/</link><pubDate>Sat, 02 Jul 2022 20:08:05 +0800</pubDate><guid>https://xuxihe.vercel.app/project/gre/</guid><description/></item><item><title>镇站之宝</title><link>https://xuxihe.vercel.app/post/happy/%E9%95%87%E7%AB%99%E4%B9%8B%E5%AE%9D/</link><pubDate>Mon, 29 Nov 2021 18:00:30 +0800</pubDate><guid>https://xuxihe.vercel.app/post/happy/%E9%95%87%E7%AB%99%E4%B9%8B%E5%AE%9D/</guid><description>&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>2021 11 25</title><link>https://xuxihe.vercel.app/post/daily-words/2021-11-25/</link><pubDate>Thu, 25 Nov 2021 22:05:43 +0800</pubDate><guid>https://xuxihe.vercel.app/post/daily-words/2021-11-25/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>生词&lt;/th>
&lt;th>释义&lt;/th>
&lt;th>备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="http://www.youdao.com/w/eng/foresee/" target="_blank" rel="noopener">foresee&lt;/a>&lt;/td>
&lt;td>&lt;strong>v.&lt;/strong> 预见，预知&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.youdao.com/w/eng/linguistic/" target="_blank" rel="noopener">linguistic&lt;/a>&lt;/td>
&lt;td>&lt;strong>adj.&lt;/strong> 语言的&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.youdao.com/w/eng/interstellar/" target="_blank" rel="noopener">interstellar&lt;/a>&lt;/td>
&lt;td>&lt;strong>adj.&lt;/strong> 星际的&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.youdao.com/w/eng/previous/" target="_blank" rel="noopener">previous&lt;/a>&lt;/td>
&lt;td>&lt;strong>adj.&lt;/strong> 之前的；早先的&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.youdao.com/w/eng/subsequent/" target="_blank" rel="noopener">subsequent&lt;/a>&lt;/td>
&lt;td>&lt;strong>adj.&lt;/strong> 随后的；后来的&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.youdao.com/w/eng/isolation/" target="_blank" rel="noopener">isolation&lt;/a>&lt;/td>
&lt;td>&lt;strong>n.&lt;/strong> 隔离，孤立&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.youdao.com/w/eng/regarding/" target="_blank" rel="noopener">regarding&lt;/a>&lt;/td>
&lt;td>&lt;strong>vt.&lt;/strong> 看待；&lt;strong>n.&lt;/strong> 尊重；敬意&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.youdao.com/w/eng/coauthor/" target="_blank" rel="noopener">coauthor&lt;/a>&lt;/td>
&lt;td>&lt;strong>n.&lt;/strong> 共同执笔者&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.youdao.com/w/eng/concept/" target="_blank" rel="noopener">concept&lt;/a>&lt;/td>
&lt;td>&lt;strong>n.&lt;/strong> 理念；观念&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.youdao.com/w/eng/current/" target="_blank" rel="noopener">current&lt;/a>&lt;/td>
&lt;td>&lt;strong>adj.&lt;/strong> 当前的&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>语文</title><link>https://xuxihe.vercel.app/project/chinese/</link><pubDate>Tue, 23 Nov 2021 08:59:12 +0800</pubDate><guid>https://xuxihe.vercel.app/project/chinese/</guid><description/></item><item><title>议论文素材</title><link>https://xuxihe.vercel.app/project/argumentation/</link><pubDate>Tue, 23 Nov 2021 08:39:14 +0800</pubDate><guid>https://xuxihe.vercel.app/project/argumentation/</guid><description/></item><item><title>红楼梦</title><link>https://xuxihe.vercel.app/project/red-dream/</link><pubDate>Tue, 23 Nov 2021 08:30:36 +0800</pubDate><guid>https://xuxihe.vercel.app/project/red-dream/</guid><description>&lt;p>因为，据说，高考要考名著阅读，其中有红楼梦！！！&lt;/p>
&lt;p>正好，边翻译边看了一遍。对于古文翻译和名著阅读都有好处。&lt;del>(夺聪明)&lt;/del>&lt;/p></description></item><item><title>2021 11 22</title><link>https://xuxihe.vercel.app/post/daily-words/2021-11-22/</link><pubDate>Mon, 22 Nov 2021 20:38:46 +0800</pubDate><guid>https://xuxihe.vercel.app/post/daily-words/2021-11-22/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">生词&lt;/th>
&lt;th style="text-align:left">释义&lt;/th>
&lt;th style="text-align:left">备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="http://www.youdao.com/w/eng/due/" target="_blank" rel="noopener">due&lt;/a>&lt;/td>
&lt;td style="text-align:left">&lt;strong>adj.&lt;/strong> 到期的，预期的；应有的，应得的&lt;/td>
&lt;td style="text-align:left">&lt;strong>due to&lt;/strong> 由于，因为&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="http://www.youdao.com/w/eng/popularity/" target="_blank" rel="noopener">popularity&lt;/a>&lt;/td>
&lt;td style="text-align:left">&lt;strong>n.&lt;/strong> 流行；普及&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="http://www.youdao.com/w/eng/alteration/" target="_blank" rel="noopener">alteration&lt;/a>&lt;/td>
&lt;td style="text-align:left">&lt;strong>n.&lt;/strong> 改变&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="http://www.youdao.com/w/eng/term/" target="_blank" rel="noopener">term&lt;/a>&lt;/td>
&lt;td style="text-align:left">&lt;strong>n.&lt;/strong> 时期；学期；期限&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="http://www.youdao.com/w/eng/ancestor/" target="_blank" rel="noopener">ancestor&lt;/a>&lt;/td>
&lt;td style="text-align:left">&lt;strong>n.&lt;/strong> 祖先&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="http://www.youdao.com/w/eng/annoyance/" target="_blank" rel="noopener">annoyance&lt;/a>&lt;/td>
&lt;td style="text-align:left">&lt;strong>n.&lt;/strong> 恼火；令人恼火的事&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="http://www.youdao.com/w/eng/mannered/" target="_blank" rel="noopener">mannered&lt;/a>&lt;/td>
&lt;td style="text-align:left">&lt;strong>n.&lt;/strong> 礼貌；方式方法&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="http://www.youdao.com/w/eng/contemporary/" target="_blank" rel="noopener">contemporary&lt;/a>&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>Ubuntu安装字体</title><link>https://xuxihe.vercel.app/post/tec/ubuntu%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93/</link><pubDate>Mon, 22 Nov 2021 15:19:39 +0800</pubDate><guid>https://xuxihe.vercel.app/post/tec/ubuntu%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93/</guid><description>&lt;h2 id="引言">引言&lt;/h2>
&lt;p>众所周知，&lt;code>Ubuntu&lt;/code> 是一个著名的Linux开源发行版。但是，开源……这就意味着，那些不开源的字体用不了！&lt;/p>
&lt;p>所以，本着&lt;del>开源&lt;/del>务实的精神，我们要安装字体。（除非你想每天都被你的老师叫过去解决PPT的各种奇奇怪怪的问题）&lt;/p>
&lt;p>而字体文件？当然是，Windows！&lt;del>虽然，有些blabla&lt;/del>&lt;/p>
&lt;h2 id="复制字体">复制字体&lt;/h2>
&lt;ol>
&lt;li>如果你的网络不好，可以选择从一台安装有Windows系统的计算机进行拷贝。将 &lt;code>C:\Windows\Fonts&lt;/code> 目录中的&lt;b>&lt;font color=red size="5">所有&lt;/font>&lt;/b>文件拷贝到移动介质中待用。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>至于为什么是所有，别问我，就问那帮人为啥动不动就老用一些奇奇怪怪的字体，为了防止多次安装的惨痛后果，除非你非常清楚你需要什么，建议全部安装。(反正就500来MB，也不大)&lt;/p>
&lt;/blockquote>
&lt;ol start="2">
&lt;li>如果你的网络尚可或者你身边并没有一台Windows电脑，则可以点击下面👇的链接进行下载后解压。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>地址1：腾讯coding &lt;a href="https://xu-xihe.coding.net/p/windows-fonts/d/fonts/git/archive/main/?download=true" target="_blank" rel="noopener">直接下载&lt;/a> &lt;a href="https://xu-xihe.coding.net/public/windows-fonts/fonts/git/files" target="_blank" rel="noopener">访问项目&lt;/a>&lt;/p>
&lt;p>地址2：Gitee &lt;del>众所周知，这玩意下载Zip必须登录&lt;/del> &lt;a href="https://gitee.com/xu-xihe/windos-fonts.git" target="_blank" rel="noopener">访问项目&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="安装字体">安装字体&lt;/h2>
&lt;ol>
&lt;li>移动所有字体文件致 &lt;code>/usr/share/fonts/&lt;/code> 或者其子文件夹中。**注意：**如果你想要进行分类的话，可以自行新建子文件夹。&lt;/li>
&lt;li>修改字体文件权限，使得所有用户都可以访问，请执行 &lt;code>sudo chmod -R /usr/share/fonts/{yourname} 755&lt;/code>。若不清楚是否执行成功，请跳过并继续。&lt;/li>
&lt;li>运行 &lt;code>mkfontscale&lt;/code> 。若提示 &lt;code>mkfontscale: command not found&lt;/code>，则先执行 &lt;code>sudo apt install ttf-mscorefonts-installer&lt;/code> 后重试。&lt;/li>
&lt;li>运行 &lt;code>mkfontdir&lt;/code> 和 &lt;code>fc-cache -fv&lt;/code>。&lt;/li>
&lt;li>打开字体管理器，确认安装。&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>Ubuntu关机90s</title><link>https://xuxihe.vercel.app/post/tec/ubuntu%E5%85%B3%E6%9C%BA90s/</link><pubDate>Mon, 22 Nov 2021 15:15:41 +0800</pubDate><guid>https://xuxihe.vercel.app/post/tec/ubuntu%E5%85%B3%E6%9C%BA90s/</guid><description>&lt;h2 id="现象">现象&lt;/h2>
&lt;p>通常情况下，他会显示一个啥啥啥 is running，然后后面有一个括号 &lt;code>(..s/1min30s)&lt;/code> 这种。&lt;/p>
&lt;h2 id="解决方法">解决方法&lt;/h2>
&lt;p>虽然我们并不知道为啥，但是我们确实有一种解决的方法。&lt;/p>
&lt;ol>
&lt;li>用root权限（其实就是加个 &lt;code>sudo&lt;/code>）编辑 &lt;code> /etc/systemd/system.conf&lt;/code>，找到里面有一个 &lt;code>DefaultTimeoutStopSec=90s&lt;/code>，把行首的 &lt;code>#&lt;/code> 去掉，并改成 &lt;code>DefaultTimeoutStopSec=1ms&lt;/code>，保存，退出。&lt;/li>
&lt;li>执行 &lt;code>sudo systemctl daemon-reload&lt;/code> 更新配置文件。&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>作文</title><link>https://xuxihe.vercel.app/courses/chinese/%E4%BD%9C%E6%96%87/</link><pubDate>Mon, 22 Nov 2021 15:04:17 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chinese/%E4%BD%9C%E6%96%87/</guid><description>&lt;h3 id="审题">审题&lt;/h3>
&lt;ol>
&lt;li>寓言故事&lt;/li>
&lt;li>新闻材料&lt;/li>
&lt;li>任务驱动（“改其一点，兼顾所有”）&lt;/li>
&lt;/ol>
&lt;h3 id="立意">立意&lt;/h3>
&lt;h3 id="拟题">拟题&lt;/h3>
&lt;p>要有文采&lt;/p>
&lt;h3 id="论据">论据&lt;/h3>
&lt;ol>
&lt;li>化用材料（必须写）（引子）&lt;/li>
&lt;li>例证 $3$ 个&lt;/li>
&lt;li>引证 $3$ 个&lt;/li>
&lt;/ol>
&lt;h3 id="布局谋篇">布局谋篇&lt;/h3>
&lt;h4 id="开篇">开篇&lt;/h4>
&lt;ol>
&lt;li>常式：抄材料、化用材料&lt;/li>
&lt;li>变式：创作（对比、排比）&lt;/li>
&lt;/ol>
&lt;h3 id="语言风格">语言风格&lt;/h3>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>语言文字运用</title><link>https://xuxihe.vercel.app/courses/chinese/%E8%AF%AD%E8%A8%80%E6%96%87%E5%AD%97%E8%BF%90%E7%94%A8/</link><pubDate>Mon, 22 Nov 2021 15:03:36 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chinese/%E8%AF%AD%E8%A8%80%E6%96%87%E5%AD%97%E8%BF%90%E7%94%A8/</guid><description>&lt;h2 id="题型">题型&lt;/h2>
&lt;h3 id="选择题">选择题&lt;/h3>
&lt;h4 id="选词">选词&lt;/h4>
&lt;ol>
&lt;li>找重要词语切入：从 $4$ 选 $1$ 减少为 $2$ 选 $1$&lt;/li>
&lt;li>检验代入&lt;/li>
&lt;/ol>
&lt;h4 id="补句">补句&lt;/h4>
&lt;p>瞻前顾后（联系上下文）&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>古诗文阅读</title><link>https://xuxihe.vercel.app/courses/chinese/%E5%8F%A4%E8%AF%97%E6%96%87%E9%98%85%E8%AF%BB/</link><pubDate>Mon, 22 Nov 2021 15:00:53 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chinese/%E5%8F%A4%E8%AF%97%E6%96%87%E9%98%85%E8%AF%BB/</guid><description>&lt;h2 id="古文">古文&lt;/h2>
&lt;h3 id="题型">题型&lt;/h3>
&lt;h4 id="选择题">选择题&lt;/h4>
&lt;p>共 $3$ 道，$3\times3=9$ 分&lt;/p>
&lt;p>文学常识、内容理解、字词&lt;/p>
&lt;p>读 $\rightarrow$ 找 $\rightarrow$ 比&lt;/p>
&lt;h4 id="翻译句子">翻译句子&lt;/h4>
&lt;p>共 $2$ 句，共 $2\times4$ 分&lt;/p>
&lt;h4 id="主观题">主观题&lt;/h4>
&lt;p>共 $1$ 道，共 $4$ 分&lt;/p>
&lt;h2 id="古诗文">古诗文&lt;/h2>
&lt;h4 id="选择题-1">选择题&lt;/h4>
&lt;p>共 $3$ 道，$3\times3=9$ 分&lt;/p>
&lt;p>文学常识、内容理解、字词&lt;/p>
&lt;p>读 $\rightarrow$ 找 $\rightarrow$ 比&lt;/p>
&lt;h4 id="主观题-1">主观题&lt;/h4>
&lt;p>共 $1$ 道，共 $6$ 分&lt;/p>
&lt;h2 id="默写句子">默写句子&lt;/h2>
&lt;p>共 $3$ 句，共 $2\times3=6$ 个分句，共 $6\times1$ 分&lt;/p>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>文学类文本阅读</title><link>https://xuxihe.vercel.app/courses/chinese/%E6%96%87%E5%AD%A6%E7%B1%BB%E6%96%87%E6%9C%AC%E9%98%85%E8%AF%BB/</link><pubDate>Mon, 22 Nov 2021 14:59:42 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chinese/%E6%96%87%E5%AD%A6%E7%B1%BB%E6%96%87%E6%9C%AC%E9%98%85%E8%AF%BB/</guid><description/></item><item><title>非连续性文本阅读</title><link>https://xuxihe.vercel.app/courses/chinese/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E6%80%A7%E6%96%87%E6%9C%AC%E9%98%85%E8%AF%BB/</link><pubDate>Mon, 22 Nov 2021 14:56:05 +0800</pubDate><guid>https://xuxihe.vercel.app/courses/chinese/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E6%80%A7%E6%96%87%E6%9C%AC%E9%98%85%E8%AF%BB/</guid><description>&lt;h2 id="材料">材料&lt;/h2>
&lt;p>$2\sim4$ 个选文，以文学类知识为主&lt;/p>
&lt;h2 id="题型">题型&lt;/h2>
&lt;h3 id="选择题">选择题&lt;/h3>
&lt;p>共 $3$ 道，共 $3\times3=9$ 分&lt;/p>
&lt;p>注意限定词和修饰词，注意所表述范围是否一致。&lt;/p>
&lt;p>读 $\rightarrow$ 找 $\rightarrow$ 比&lt;/p>
&lt;h3 id="主观题">主观题&lt;/h3>
&lt;p>共 $2$ 道，共 $4+6=10$ 分&lt;/p>
&lt;h4 id="下定义">下定义&lt;/h4>
&lt;p>种差加属&lt;/p>
&lt;blockquote>
&lt;p>议论文是一种以议论为主要表达方式的文章体裁。&lt;/p>
&lt;p>属性：文章体裁&lt;/p>
&lt;p>种差：以议论为主要表达方式&lt;/p>
&lt;/blockquote>
&lt;h4 id="行文脉络行文思路">行文脉络（行文思路）&lt;/h4>
&lt;ol>
&lt;li>答 $3$ 或 $4$ 点&lt;/li>
&lt;li>首先……然后……最后……&lt;/li>
&lt;/ol>
&lt;h4 id="如何论证论证特色">如何论证（论证特色）&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>结构：并列、递进、对照、总 — 分、总 — 分 — 总，分 — 总。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>论证方法：例证、引证、对比论证、比喻论证、假设论证、因果论证&lt;/p>
&lt;/li>
&lt;li>
&lt;p>语言风格：准确、严密，讲究逻辑。&lt;/p>
&lt;blockquote>
&lt;p>严谨性：&lt;/p>
&lt;ol>
&lt;li>用词严谨&lt;/li>
&lt;li>结构严谨（提出问题 — 分析问题 — 解决问题）&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (上一栏选填，开放匿名评论，邮箱仅用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>每日单词</title><link>https://xuxihe.vercel.app/project/dailyword/</link><pubDate>Thu, 18 Nov 2021 20:15:24 +0800</pubDate><guid>https://xuxihe.vercel.app/project/dailyword/</guid><description/></item><item><title>化学</title><link>https://xuxihe.vercel.app/project/chemistry/</link><pubDate>Thu, 18 Nov 2021 20:05:23 +0800</pubDate><guid>https://xuxihe.vercel.app/project/chemistry/</guid><description/></item><item><title>OI题解</title><link>https://xuxihe.vercel.app/project/oique/</link><pubDate>Thu, 18 Nov 2021 19:59:55 +0800</pubDate><guid>https://xuxihe.vercel.app/project/oique/</guid><description>&lt;p>这里是一些题解，虽然可能一个都没有。&lt;/p></description></item><item><title>OI知识</title><link>https://xuxihe.vercel.app/project/oiknowledge/</link><pubDate>Tue, 16 Nov 2021 17:32:38 +0800</pubDate><guid>https://xuxihe.vercel.app/project/oiknowledge/</guid><description/></item><item><title/><link>https://xuxihe.vercel.app/courses/biology/kk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/courses/biology/kk/</guid><description>&lt;h2 id="fajkdljfasdf">fajkdljfasdf&lt;/h2>
&lt;p>fasdfadf&lt;/p>
&lt;p>dsfad&lt;/p>
&lt;p>dfa&lt;/p>
&lt;p>dfad&lt;/p>
&lt;p>fasdf&lt;/p>
&lt;p>asdfa&lt;/p>
&lt;p>sdf&lt;/p>
&lt;p>asdf&lt;/p>
&lt;p>sda&lt;/p>
&lt;p>f&lt;/p>
&lt;p>asdf#&lt;/p>
&lt;h3 id="fadfadf">fadfadf&lt;/h3>
&lt;p>dfadsf&lt;/p>
&lt;p>adfadsf&lt;/p></description></item><item><title/><link>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</guid><description/></item><item><title/><link>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</guid><description/></item><item><title/><link>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</guid><description>&lt;h1 id="矩阵乘法">矩阵乘法&lt;/h1>
&lt;h2 id="基本概念">基本概念&lt;/h2>
&lt;p>$n$ 行 $m$ 列个元素有规律的排列在一起，构成一个矩阵，记作 $A=(a_{i,j})_{n\times m}\in R^{n\times m}$。&lt;/p>
&lt;p>若 $n=m$ ，则这个矩阵为 $n$ 阶矩阵。&lt;/p>
&lt;h2 id="基本运算规则">基本运算规则&lt;/h2>
&lt;h3 id="加减法">加减法&lt;/h3>
&lt;p>对于两个矩阵 $A=(a_{i,j})&lt;em>{a\times b}$ 和 $B=(b&lt;/em>{i,j})_{x\times y}$，当且仅当 $a=x$ 且 $b=y$ 时，$A-B$ 和 $A+B$ 有意义。&lt;/p>
&lt;p>$A-B=$&lt;/p>
&lt;h3 id="乘法">乘法&lt;/h3></description></item><item><title/><link>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</guid><description/></item><item><title/><link>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://xuxihe.vercel.app/notes/oiknowledge/math%E6%95%B0%E8%AE%BA/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</guid><description/></item></channel></rss>