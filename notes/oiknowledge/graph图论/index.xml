<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>图论 | Senie</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/</link><atom:link href="/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/index.xml" rel="self" type="application/rss+xml"/><description>图论</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><copyright>© 曦曦呵呵</copyright><lastBuildDate>Mon, 18 Oct 2021 00:00:00 +0000</lastBuildDate><image><url>/media/icon_huf638f59a6dd2257b0add8e0186347459_300061_512x512_fill_lanczos_center_3.png</url><title>图论</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/</link></image><item><title>搜索</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%90%9C%E7%B4%A2/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%90%9C%E7%B4%A2/</guid><description>&lt;h1 id="dfs">DFS&lt;/h1>
&lt;h2 id="深度优先搜索">深度优先搜索。&lt;/h2>
&lt;p>深度优先，即每一次均搜索一条完整的从起点到达终点的路径，然后继续搜索第二条。&lt;/p>
&lt;p>原始支持有权图搜索。&lt;/p>
&lt;p>一般情况下，通常使用递归的方式实现。&lt;/p>
&lt;p>具体流程为，对于当前节点，循环遍历下一个目标节点，对于可能的目标节点调用递归函数，直到终止条件。&lt;/p>
&lt;p>状态一般包括step，记录决策的数组等，可以放在全局变量中（注意回溯时需要回退全局变量）。&lt;/p>
&lt;h2 id="剪枝">剪枝&lt;/h2>
&lt;p>剪枝就是切掉一部分无用的搜索树，起到优化复杂度的作用&lt;/p>
&lt;ol>
&lt;li>
&lt;p>**记忆化：**dfs函数中传入相同的状态往往会得到一样的解，所以用数组记录下对应每个状态的答案，若之前已求得直接返回即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**求代价和最小：**若转移时代价非负，则若目前的代价和已经大于等于之前的最小答案，直接返回。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>更改转移的枚举顺序&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="启发式搜索">启发式搜索&lt;/h2>
&lt;p>当搜索到一个状态u时，计算估价函数 $f(u)$ 的值：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于转移需要代价的题目，$f(u)$ 代表转移到末状态的最小代价，如果走到u状态的代价 $g(u)+f(u)&amp;gt;ans$ 则剪枝&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于转移得到收益的题目，$f(u)$ 表示可能的最大收益，如果 $g(u)+f(u)≤ans$ 则剪枝&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="a">A*&lt;/h2>
&lt;p>估价函数同启发式搜索，但是我们用优先队列进行类广搜,每次取出 $f(x)+g(x)$ 最小的 $x$，然后更新相邻的状态。&lt;/p>
&lt;h2 id="ida">IDA*&lt;/h2>
&lt;p>迭代加深A*，仅仅是添加了限制层数。&lt;/p>
&lt;h2 id="dfs生成树">DFS生成树&lt;/h2>
&lt;p>在一个有向图中，以DFS的方式选取某一节点进行搜索而形成的树+边的结构。&lt;/p>
&lt;p>举个栗子：&lt;/p>
&lt;p>我们先看一个有向图：&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="graph%20%282%29.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>用DFS跑图，就可以得到一下这个：&lt;/p>
&lt;img src="dfs-tree.svg" style="zoom:120%;" />
&lt;p>我们可以以树形结构将图中的边分为四种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>树边：每个节点第一次被访问时经过的边，整体称为搜索树。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;font color="red">返祖边：从子树中的节点到其父亲节点的边。&lt;/font>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;font color="green">前向边：从父亲节点直接指向儿子(也可以是孙子等)节点的边。&lt;/font>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;font color="blue">横叉边：搜索的时候遇到了一个已经访问过的结点，但是这个结点&lt;strong>并不是&lt;/strong>当前结点的祖先时形成的。(看不懂？流氓定义：如果这条边不是上面三种，那就是横叉边)&lt;/font>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="dfs序">DFS序&lt;/h2>
&lt;p>字面意思，很好理解，就是用DFS&lt;strong>前序遍历&lt;/strong>一棵树上所有节点和边时访问的顺序。&lt;/p>
&lt;p>我们知道，树是一种非线性的数据结构，它的一些数据调用肯定是没有线性结构来得方便的。所以这个时候，dfs站了出来。&lt;/p>
&lt;p>如图，这是一棵树：&lt;/p>
&lt;img src="graph%20(2)-16321427081993.png" alt="afd" style="zoom:90%;" />
&lt;p>所以，整了一大顿，这DFS序到底有啥子用？这得从DFS的优势来探讨了。&lt;/p>
&lt;p>DFS是深度优先的，所以对于一个点，它会先遍历完它的所有子节点，再去遍历他的兄弟节点以及其他子树的节点。&lt;/p>
&lt;p>因此DFS序保证了一棵树(子树)的根节点和其子树中所有的节点会被存储在连续的区间之中。&lt;/p>
&lt;p>比如，以 $5$ 为根的子树中节点编号为 $5\sim8$。&lt;/p>
&lt;p>这样，我们把一个非线性的数据结构——树，成功转化为了一个线性的数据结构，然后……&lt;a href="../data%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">请自行选择&lt;/a>。&lt;/p>
&lt;p>&lt;strong>But!&lt;/strong> 我们现在还有一个问题：&lt;/p>
&lt;p>如何直到我的子树区间到哪？别搞出去就不好了。&lt;/p>
&lt;p>欲知详情，请接着看 -_-&lt;/p>
&lt;h3 id="时间戳">时间戳&lt;/h3>
&lt;p>这玩意好比一个标签，贴在每一个点上，记录dfs第一次开始访问这个点的时间以及最后结束访问的时间。&lt;/p>
&lt;p>我们发现，节点 $i$ 的DFS序其实是DFS第一次访问节点 $i$ 的时间，因此我们只需要记录最后结束访问的时间即可。&lt;/p>
&lt;p>实现很简单，循环完儿子之后(回溯之前)记录一下当前最大DFS序值即可。&lt;/p>
&lt;p>这样，我们成功的把一棵树变成了一段段的&lt;strong>区间&lt;/strong>：&lt;/p>
&lt;img src="graph%20(3).png" alt="fad" style="zoom:90%;" />
&lt;h1 id="bfs">BFS&lt;/h1>
&lt;h2 id="广度优先搜索">广度优先搜索。&lt;/h2>
&lt;p>广度优先，即每一次都搜索距离起点相同长度的点，然后继续搜索长度 $+1$ 的点，直到搜索到终点。&lt;/p>
&lt;p>原始不支持有权图，但可以使用算法优化。&lt;/p>
&lt;p>一般情况下，通常使用队列的方式实现。&lt;/p>
&lt;p>具体流程为，先将起始节点推入队列，每次循环弹出队首元素，将其加入以搜索的点集，并将与之连接的未加入以搜索的点集的点推入队列尾部，直到找到终点或者队列为空。&lt;/p>
&lt;h2 id="双向bfs">双向BFS&lt;/h2>
&lt;p>要求 $S$ 状态到 $T$ 状态的最小转移次数，从 $S$，$T$ 分别同时出发进行BFS，直到BFS到的点相遇为止。&lt;/p>
&lt;p>理论上将深度为 $n$ 的搜索树拆分成了两棵深度为 $\frac{n}{2}$ 的搜索树 。若决策个数为 $k$，搜索树大小由 $k^n$ 优化为 $2\times k^\frac{n}{2}$。&lt;/p>
&lt;p>如何判断一个局面（状态）是否被访问过？可以将全局状态变成一个整数，用&lt;code>map&lt;/code>或&lt;code>unordered_map&lt;/code>记录该整数是否出现过。&lt;/p>
&lt;h1 id="三个要素">三个要素&lt;/h1>
&lt;ul>
&lt;li>状态：怎么表示？要求包括全部信息、能够标记是否已访问。&lt;/li>
&lt;li>转移：转移后的状态计算，转移代价计算。&lt;/li>
&lt;li>优化：剪枝（剪掉无用的搜索子树），修改搜索顺序，估价函数。&lt;/li>
&lt;/ul></description></item><item><title>拓扑排序</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid><description>&lt;h1 id="拓扑排序">拓扑排序&lt;/h1>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_39970166/article/details/110870115" target="_blank" rel="noopener">一篇博文&lt;/a>&lt;/p>
&lt;h2 id="引子">引子&lt;/h2>
&lt;p>下面让我来看一看拓扑序是什么，又有啥子用。&lt;/p>
&lt;p>众所周知，万事都要讲究先来后到。比如，你对一个婴儿进行早教，你很自信、很闪耀，觉得此孩儿定是天降奇才，跳过了万水千山，连话都不会说，直接交他拓扑排序，为以后发扬光大OI事业而打下坚实的基础。然后，一段时间以后，你忽然发现，你教授完一万字的长篇大论然而并没有一点用处，甚至人家一眼都没看你。所以，你十分灰心，感受到了生活的无情，决定放下倔强，从头教起。你潜心研究，发现有一些知识需要在某些知识已经掌握的情况之下才可以学习；所以，你编写了一个程序，给出学习各种知识的先后顺序。&lt;/p>
&lt;h2 id="为啥是图论">为啥是图论&lt;/h2>
&lt;p>看上面的段子，脑海中浮现出各种问号……&lt;/p>
&lt;p>这东西为啥子是图论嘞？&lt;/p>
&lt;p>我们先搞一下啥是DAG(有向无环图)：&lt;/p>
&lt;p>&lt;strong>一个有向图,且不存在环。&lt;/strong> &lt;del>多么简洁明了&lt;/del>&lt;/p>
&lt;img src="104909e17df721889a8ef5386d33263d.png" alt="DAG" style="zoom: 55%;" />
&lt;p>这时候，考虑将边 $u\rightarrow{v}$​ 具体为”做 $v$ 之前要先做 $u$​​ ”，那么拓扑排序能求出每件事应该在什么时候做，也就是说满足每件事的前置事件都做完后它才能开始做的一种安排。&lt;/p>
&lt;p>&lt;strong>拓扑序不是唯一的,因为有些点之间不存在拓扑关系。&lt;/strong>&lt;/p>
&lt;p>比如，上图中A和E、B和D等就没有拓扑关系。&lt;/p>
&lt;p>建图到此结束。&lt;/p>
&lt;h2 id="bfs款">BFS款&lt;/h2>
&lt;p>入度：指向某个点的有向边条数。&lt;/p>
&lt;p>我们发现，对于任意一个DAG，总有入度为$0$的节点。完成这个节点无需依赖其他任何节点的完成情况。&lt;/p>
&lt;p>因此，我们维护一个队列(其实栈也不是不行)，队列中包含所有入度为$0$的节点。&lt;/p>
&lt;p>对于每一个队列中节点，删去其所有初度，并将删边后入度为$0$​的节点加入队列。&lt;/p>
&lt;p>如需按照字典序大小求拓扑序，改为使用优先队列即可(即优先访问字典序大/小的节点)。&lt;/p>
&lt;p>记录已经遍历的节点数，若队列为空并且已经遍历的节点数小于总节点数，则说明存在环。&lt;/p>
&lt;img src="6e6578e58c374ddeca7d1ff41d0e8aab.png" alt="huan" style="zoom:65%;" />
&lt;p>如上图，当出现环时，删除一定数量的节点和边后，出现所有节点入度均大于$0$​的情况，即队列为空。&lt;/p>
&lt;p>两种算法复杂度均为$O(n+m)$。&lt;/p>
&lt;p>&lt;a href="http://poj.org/problem?id=2367" target="_blank" rel="noopener">POJ2367&lt;/a> 外加一点补充&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;
using std::vector;
const int maxe = 109; //最大节点个数
int len, in[maxe], cnt; //len总节点数,in[i]第i号节点的入度,cnt已经遍历的节点个数
vector&amp;lt;int&amp;gt; next[maxe]; //邻接链表存图
std::priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, std::greater&amp;lt;int&amp;gt; &amp;gt; running; //如无需按字典序输出,请改用queue;注意两个'&amp;gt;'中间有一个空格,看好是小顶堆还是大顶堆
int main()
{
scanf(&amp;quot;%d&amp;quot;, &amp;amp;len);
for (int i = 1; i &amp;lt;= len; i++)
{
int a;
while (1)
{
scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);
if (!a)
break;
next[i].push_back(a);
in[a]++; //每有一条指向节点的边,入度+1
}
}
for (int i = 1; i &amp;lt;= len; i++)
{
if (in[i] == 0) //查找所有入度为0的节点
running.push(i);
}
while (!running.empty())
{
int top = running.top();
running.pop();
printf(&amp;quot;%d &amp;quot;, top);
cnt++; //已经遍历的节点数+1
int n = next[top].size();
for (int i = 0; i &amp;lt; n; i++) //遍历所有出度,进行删边操作
{
int now = next[top][i];
in[now]--;
if (!in[now]) //如果删边后入度为0,则加入队列
running.push(now);
}
}
if (cnt != len) //如果以遍历节点数小于总节点数,说明有环
printf(&amp;quot;error\n&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="dfs款">DFS款&lt;/h2>
&lt;p>选定一个节点，递归完成他的入度。&lt;/p>
&lt;p>对于每个节点循环。&lt;/p>
&lt;p>&lt;del>还是学上面那个吧&lt;/del>&lt;/p></description></item><item><title>最小生成树</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid><description>&lt;h1 id="最小生成树">最小生成树&lt;/h1>
&lt;h2 id="问题描述">问题描述&lt;/h2>
&lt;p>给出一个有$n$个节点，$m$条边的无向图，从中选取边权之和最小(大)的$n-1$条边，使得图上任意两个顶点有且只有唯一的一条路径可以互相到达。&lt;/p>
&lt;h2 id="例子">例子&lt;/h2>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.png" alt="最小生成树" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;img src="%E6%97%A0%E5%90%91%E5%9B%BE.svg" alt="无向图" style="zoom:80%;" />&lt;/p>
&lt;p>如上图，其最小生成树为： &lt;strong>红色部分&lt;/strong> 和 &lt;img src="%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.dot.svg" alt="最小生成树" style="zoom:80%;" />&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong> 最小生成树可能不唯一(边权相等)&lt;/p>
&lt;h2 id="暴力">暴力&lt;/h2>
&lt;p>枚举每一种可能的情况，计算最小值(因复杂度过高，不再赘述)。&lt;/p>
&lt;h2 id="prim算法">Prim算法&lt;/h2>
&lt;p>时间复杂度：$O(nm)\sim O(m\log{n})$​ &lt;em>数据结构优化&lt;/em>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_42657313/article/details/103326019?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162729943216780366585099%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=162729943216780366585099&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-6-103326019.first_rank_v2_pc_rank_v29&amp;amp;utm_term=prim%E7%AE%97%E6%B3%95&amp;amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">一篇比较详细的博文&lt;/a>&lt;/p>
&lt;p>以&lt;strong>点&lt;/strong>为核心，每次选择当前&lt;strong>已选中&lt;/strong>的点连接&lt;strong>未选中&lt;/strong>的点的边中&lt;strong>权值最小&lt;/strong>的一个，将这个点加入&lt;strong>已选中&lt;/strong>的点集，并用和这个点连接的边更新&lt;strong>未选中&lt;/strong>的点的距离。&lt;/p>
&lt;h3 id="例子-1">例子&lt;/h3>
&lt;img src="20191130162837932.png" alt="Prim1" style="zoom: 150%;" />
&lt;img src="20191130162907364.png" alt="Prim2" style="zoom: 200%;" />
&lt;p>&lt;del>盗图很开心&lt;/del>&lt;/p>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3366" target="_blank" rel="noopener">洛谷P3366&lt;/a> &lt;del>其实就是板子&lt;/del>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
const int maxe = 6000; //n的最大值
int n, m, head[maxe], cnt;
//n个点,m条边,head[i]表示已i为端点最后读入的一条边的编号,已经读入cnt条边
bool vis[maxe]; //vis[i]标记i节点是否在最小生成树点集中
struct node
{
int value, last, sign; //value表示边权,last表示同一起点的上一条读入的边的编号,sign表示当前节点编号
} edge[400009];
//m最大值*2
inline void add_edge(int start, int end, int value) //链式前向星
{
edge[++cnt].value = value;
edge[cnt].sign = end;
edge[cnt].last = head[start];
head[start] = cnt;
return;
}
inline int prim()
{
int dis[maxe], ans = -1e9;
//dis[i]表示连接未加入点集的i号节点和点集中任意点最短路径长,ans = -1e9抵消选择第一个点溢出
for (int i = 1; i &amp;lt;= n; i++)
{
dis[i] = 2e9; //初始化dis数组
}
int k = 1, min; //k记录所选择的点的编号,min记录最小值,k初始值为第一个加入点集的点的编号
vis[1] = 1; //将第一个点加入点集
for (int i = 0; i &amp;lt; n; i++) //循环n次,将所有点加入点集
{
min = 1e9; //别忘了qwq,注意小于dis初始者,判断是否无法建树
for (int j = 1; j &amp;lt;= n; j++) //暴力搜索最小点,可用堆/平衡树(优先队列、set等)优化
{
if (!vis[j] &amp;amp;&amp;amp; dis[j] &amp;lt; min)
{
min = dis[j];
k = j;
}
}
if (min == 1e9 &amp;amp;&amp;amp; k != 1) //除第一个点外,如果没有未加入点集的点有连接且点集中小于n个点,证明有点无法连同
{
return 0;
}
ans += min;
vis[k] = 1;
for (int i = head[k]; i; i = edge[i].last) //用新加入的点更新dis数组
{
if (!vis[edge[i].sign] &amp;amp;&amp;amp; dis[edge[i].sign] &amp;gt; edge[i].value)
{
dis[edge[i].sign] = edge[i].value;
}
}
}
return ans;
}
int main()
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, value;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;value);
add_edge(a, b, value); //无向边,任意端点可作为起止点
add_edge(b, a, value);
}
int ans = prim();
if (ans)
printf(&amp;quot;%d&amp;quot;, ans);
else
printf(&amp;quot;orz&amp;quot;);//无法连同所有点
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="kruskal算法">Kruskal算法&lt;/h2>
&lt;p>时间复杂度： $O(m\log{m})$&lt;/p>
&lt;p>想法比较简单、易懂。&lt;/p>
&lt;p>将所有边&lt;strong>按权值&lt;/strong>从小到大排序，优先选取&lt;strong>权值较小&lt;/strong>的边，判断两个端点是否在&lt;strong>同一个集合&lt;/strong>中。如果在同一集合中，则&lt;strong>跳过&lt;/strong>这条边，遍历下一条；如果不再同一集合中，则将ans加上边权并将&lt;strong>两个点所在的集合合并&lt;/strong>。&lt;/p>
&lt;p>涉及到判断两个点是否在同一集合中，需要引入&lt;a href="/oiblogs/data%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/%e5%b9%b6%e6%9f%a5%e9%9b%86/">并查集&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3366" target="_blank" rel="noopener">洛谷P3366&lt;/a> &lt;del>其实就是板子&lt;/del>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
int n, m, fa[6000], ans, cnt; //n个节点,m条边,已经选择cnt条边
struct edge
{
int a, b, value;
} edges[200009]; //有一条端点是a和b,权重为value的边
inline bool cmp(edge a, edge b) //比较函数
{
return a.value &amp;lt; b.value;
}
inline int find(int x) //并查集
{
return fa[x] == x ? x : fa[x] = find(fa[x]);
}
inline void together(int x, int y)
{
x = find(x);
y = find(y);
fa[x] = y;
}
int main()
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
for (int i = 1; i &amp;lt;= n; i++)
{
fa[i] = i;
}
for (int i = 0; i &amp;lt; m; i++)
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;edges[i].a, &amp;amp;edges[i].b, &amp;amp;edges[i].value);
}
std::sort(edges, edges + m, cmp); //按边权排序
for (int i = 0; i &amp;lt; m; i++)
{
if (find(edges[i].a) != find(edges[i].b)) //如果两个端点不再同一集合
{
ans += edges[i].value; //选中这条边
cnt++;
together(edges[i].a, edges[i].b); //合并两个集合
}
if (cnt == n) //最小生成树边数等于总节点数-1
break;
}
if (cnt == n - 1) //最小生成树边数等于总节点数-1
printf(&amp;quot;%d&amp;quot;, ans);
else
printf(&amp;quot;orz&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>两种算法均用到&lt;a href="/oiblogs/basic%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3/%e8%b4%aa%e5%bf%83/">贪心&lt;/a>的思想。&lt;/p>
&lt;p>Prim侧重于点，适合稠密图；Kruskal侧重于边，适合稀疏图；但二者优化后差距并不大，推荐Kruskal，易理解不费手还不容易出奇奇怪怪的问题。&lt;del>(复杂度中可以看出)&lt;/del>&lt;/p></description></item><item><title>最短路径</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid><description>&lt;h1 id="最短路径">最短路径&lt;/h1>
&lt;h2 id="是个啥">是个啥&lt;/h2>
&lt;p>这种问题恰如其名，问如何走才能用最小的代价达到目的。&lt;del>(人生哲学)&lt;/del>&lt;/p>
&lt;p>给你一张有边权的图(无权图可看做所有边边权均为1；无向图可将所有边拆分成两条有向边)，求$i$节点到$j$​节点的最短路径。&lt;/p>
&lt;p>直接上算法。&lt;/p>
&lt;h2 id="dfs">DFS&lt;/h2>
&lt;p>&lt;em>BFS就涉及到其他算法了。&lt;/em>&lt;/p>
&lt;p>只能求解单源单尽~~(自创)~~最短路(固定起点和终点)并且通常情况下过于暴力。&lt;/p>
&lt;p>想法很简单，遍历两点之间的所有路径，选择最短的那条。&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
const int maxe = 1e4 + 9;
struct node
{
int next, val;
};
std::vector&amp;lt;node&amp;gt; edge[maxe];
int len, m, ans = 2e9, sta, end;
bool ji[maxe];
inline void dfs(int now, int val)
{
if (val &amp;gt;= ans || now == end) //结束条件和一点点剪枝
{
ans = ans &amp;gt; val ? val : ans;
return;
}
int n = edge[now].size();
ji[now] = 1; //记录访问过的节点,防止环
for (int i = 0; i &amp;lt; n; i++)
{
if (ji[edge[now][i].next]) //如果出现环,终止
continue;
dfs(edge[now][i].next, edge[now][i].val + val); //继续递归
}
ji[now] = 0; //访问归零
}
int main()
{
scanf(&amp;quot;%d%d%d%d&amp;quot;, &amp;amp;len, &amp;amp;m, &amp;amp;sta, &amp;amp;end);
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, v;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;v);
edge[a].push_back(node{b, v});
}
dfs(sta, 0);
printf(&amp;quot;%d&amp;quot;, ans);
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="floyd弗洛伊德算法">Floyd(弗洛伊德)算法&lt;/h2>
&lt;p>多源最短路(任意起止点)算法，时间复杂度 $O(n^3)$​，空间复杂度 $O(n^2)$​​。&lt;/p>
&lt;p>适用于具有正或负边缘权重，但**没有负周期(负环)**的加权图中。在稠密图中效率较高。&lt;/p>
&lt;p>运用dp思想，最开始只允许经过1号顶点进行中转，接下来只允许经过1号和2号顶点进行中转&amp;hellip;&amp;hellip;允许经过$1\sim n$​号所有顶点进行中转，来不断动态更新任意两点之间的最短路程。&lt;/p>
&lt;p>dp[i][j]表示从 $i$ 号节点到 $j$ 号节点的最短路径长度。&lt;/p>
&lt;ol>
&lt;li>首先构建邻接矩阵(存图)，假如现在只允许经过1号结点，求任意两点间的最短路程，很显然&lt;/li>
&lt;/ol>
&lt;p>$$
dp[i][j]=\min{dp[i][j],dp[i][1]+dp[1][j]}
$$&lt;/p>
&lt;ol start="2">
&lt;li>接下来继续求在只允许经过1和2号两个顶点的情况下任意两点之间的最短距离，在已经实现了从 $i$ 号顶点到 $j$ 号顶点只经过$1$号节点的最短路程的前提下，现在再插入第$2$号结点，来更新更短路径，故只需在步骤1求得的基础上求
$$
dp[i][j]=\min{dp[i][j],dp[i][2]+dp[2][j]}
$$&lt;/li>
&lt;li>$n$次更新后，表示依次插入了1号，2号&amp;hellip;&amp;hellip;n号结点，最后求得的dp[i][j]是从 $i$ 号顶点到 $j$​ 号顶点只经过前 $n$ 号点的最短路程。&lt;/li>
&lt;/ol>
&lt;p>如需要记录详细路径，可使用另外一个二维数组存贮中转节点。&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using std::min;
const int maxe = 3000, INF = 1000000009;
int n, m, dp[maxe][maxe], pot[maxe][maxe]; //如不需记录详细路径，不用pot
inline void pr_dis(int dp[maxe][maxe]) //最短路径输出
{
for (int i = 1; i &amp;lt;= n; i++)
{
for (int j = 1; j &amp;lt;= n; j++)
{
if (dp[i][j] == INF)
printf(&amp;quot;INF &amp;quot;);
else
printf(&amp;quot;%d &amp;quot;, dp[i][j]);
}
printf(&amp;quot;\n&amp;quot;);
}
}
inline void pr_way(int sta, int end) //递归重建路径
{
if (pot[sta][end] == 0) //若有边连接,则终止递归
return;
pr_way(sta, pot[sta][end]); //递归输出左侧
printf(&amp;quot;%d &amp;quot;, pot[sta][end]); //输出本位
pr_way(pot[sta][end], end); //递归输出右侧
}
int main()
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
int sta;
scanf(&amp;quot;%d&amp;quot;, &amp;amp;sta);
for (int i = 1; i &amp;lt;= n; i++) //初始化
{
for (int j = 1; j &amp;lt;= n; j++)
{
dp[i][j] = i == j ? 0 : INF;
}
}
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, v;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;v);
dp[a][b] = min(dp[a][b], v); //判断重边
}
for (int k = 1; k &amp;lt;= n; k++)
{
for (int i = 1; i &amp;lt;= n; i++)
{
for (int j = 1; j &amp;lt;= n; j++)
{
if (dp[i][j] &amp;gt; dp[i][k] + dp[k][j])
{
dp[i][j] = dp[i][k] + dp[k][j];
pot[i][j] = k; //更新节点记录
}
}
}
}
for (int i = 0; i &amp;lt; n; i++) //输出
{
for (int j = 0; j &amp;lt; n; j++)
{
printf(&amp;quot;\n%d %d : &amp;quot;, i + 1, j + 1);
pr_way(i + 1, j + 1);
}
}
printf(&amp;quot;\n\n&amp;quot;);
pr_dis(dp); //输出
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="dijkstra算法">Dijkstra算法&lt;/h2>
&lt;p>用于求解非负权图的单源最短路径。&lt;/p>
&lt;p>运用&lt;a href="/oiblogs/basic%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3/%e8%b4%aa%e5%bf%83/">贪心&lt;/a>思想，时间复杂度 $O(n^2)$ 或优化后 $O(n\log{n})$，空间复杂度 运行空间 $O(n)$ 和存图 $O(m)$。&lt;/p>
&lt;p>用 $dis[i]$ 存贮从起始节点到第 $i$ 号节点的相对最短路径长度，并标记已经确定最短路径的顶点。&lt;/p>
&lt;ol>
&lt;li>初始化：设起始节点编号为 $k$，则 $dis[k]=0$，$i$ 与 $k$ 相连则 $dis[i]=边权$，其余的 $dis[j]=\infty$。&lt;/li>
&lt;li>松弛：在 $dis$ 数组中寻找未确定最短路径中 $dis[i]$ 最小，将 $i$ 加入已确定的顶点集合，并用其连接的边尝试使周围节点的 $dis$ 更小。(若存在负权，则有可能存在走负权边将以确定节点的最短路径变更小的可能，因此算法失效)&lt;/li>
&lt;/ol>
&lt;p>例子：&lt;/p>
&lt;img src="Dijkstra.jpg" alt="dijkstra" style="zoom: 70%;" />
&lt;p>&lt;strong>最暴力的code:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
const int maxe = 1e5 + 9, INF = 2147483647;
struct node //邻接链表存图
{
int next, val;
};
std::vector&amp;lt;node&amp;gt; edges[maxe];
int n, m, sta, dis[maxe];
bool ji[maxe]; //记录是否已经确定答案
inline int lowest() //查找未加入点集中最小的dis
{
int ans, lowt = INF;
for (int i = 1; i &amp;lt;= n; i++)
{
if (!ji[i] &amp;amp;&amp;amp; dis[i] &amp;lt; lowt)
{
lowt = dis[i];
ans = i;
}
}
return ans;
}
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;sta);
for (int i = 1; i &amp;lt;= n; i++) //初始化
{
dis[i] = INF;
}
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, v;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;v);
edges[a].push_back(node{b, v});
}
dis[sta] = 0; //自己倒自己为0
int now = sta; //当前要被加入点集的节点编号
for (int i = 1; i &amp;lt; n; i++)
{
ji[now] = 1; //表示已加入
int len = edges[now].size();
for (int j = 0; j &amp;lt; len; j++) //尝试松弛相连节点
{
if (dis[now] + edges[now][j].val &amp;lt; dis[edges[now][j].next])
dis[edges[now][j].next] = dis[now] + edges[now][j].val;
}
now = lowest(); //找到下一个加入点集的节点
}
for (int i = 1; i &amp;lt;= n; i++)
{
printf(&amp;quot;%d &amp;quot;, dis[i]);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>优化后code：&lt;/strong>&lt;/p>
&lt;p>用堆(优先队列)来找到dis最小的结点的复杂度为 $O(\log{n})$。&lt;/p>
&lt;p>当一个节点的dis从 $\infty$ 被更新到一个值时会被加入优先队列，若没有更改，则所有可能到达的点的最小dis都被加入优先队列。&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
const int maxe = 1e5 + 9, INF = 2147483647;
struct node //邻接链表存图
{
int next, val;
bool friend operator&amp;lt;(node a, node b)
{
return a.val &amp;gt; b.val;
}
};
std::vector&amp;lt;node&amp;gt; edges[maxe];
std::priority_queue&amp;lt;node&amp;gt; run;
int n, m, sta, dis[maxe];
bool ji[maxe]; //记录是否已经确定答案
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;sta);
for (int i = 1; i &amp;lt;= n; i++) //初始化
{
dis[i] = INF;
}
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, v;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;v);
edges[a].push_back(node{b, v});
}
dis[sta] = 0; //自己到自己为0
int now = sta; //当前要被加入点集的节点编号
for (int i = 1; i &amp;lt; n; i++)
{
ji[now] = 1; //表示已加入
int len = edges[now].size();
for (int j = 0; j &amp;lt; len; j++) //尝试松弛相连节点
{
if (dis[now] + edges[now][j].val &amp;lt; dis[edges[now][j].next])
{
dis[edges[now][j].next] = dis[now] + edges[now][j].val;
run.push(node{edges[now][j].next, dis[edges[now][j].next]}); //更新优先队列中的dis
}
}
while (!run.empty() &amp;amp;&amp;amp; ji[run.top().next]) //清空已加入点集的点
run.pop();
if(run.empty()) //防止不能连通出现死循环
break;
now = run.top().next;
}
for (int i = 1; i &amp;lt;= n; i++)
{
printf(&amp;quot;%d &amp;quot;, dis[i]);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h2 id="spfa算法">SPFA算法&lt;/h2>
&lt;p>Bellman-Ford算法的队列优化算法的别称。&lt;/p>
&lt;p>空间复杂度为 $O(n)$ 级别(不算图的存储)。&lt;/p>
&lt;p>在正常情况下(数据随机构造或出题人很善良)，期望的时间复杂度为 $O(km)\space,\space k&amp;lt;2$，但是如果你碰上一个很厉(e)害(xin)的出题人，存在针对性数据，能把你卡成 $O(nm)$​，直接 &lt;strong>T&lt;/strong> 飞！&lt;/p>
&lt;p>因此如果边权不为负的话，还是老老实实用Dijkstra叭。&lt;/p>
&lt;p>SPFA算法的实现有两种方式：&lt;/p>
&lt;ul>
&lt;li>DFS：在判定负环上优势明显，但求最短路即使各种优化，仍不及BFS。&lt;/li>
&lt;li>BFS：整体速度高于DFS，但应在仅需判断负环的题中弃用。&lt;/li>
&lt;/ul>
&lt;p>因此，应按照题目要求，选择对应的算法和方式。&lt;/p>
&lt;h3 id="bfs方式">BFS方式&lt;/h3>
&lt;p>最常见也是综合最优。&lt;/p>
&lt;ol>
&lt;li>初始化：将dis数组除起点外赋值为 $\infty$ ，起点dis为$0$​，将起点加入run队列。&lt;/li>
&lt;li>松弛：将队头弹出，并使用与其相连的边更新其他相连节点的dis值，若 $i$ 号节点的dis值被更新并且 $i$ 号节点不再run队列中，则将 $i$ 加入run的队尾。&lt;/li>
&lt;li>重复执行松弛操作，直到队列为空。&lt;/li>
&lt;/ol>
&lt;p>优化原理：因为并不是dis一更新就继续迭代，而是很可能dis被更新多次之后才再次迭代，因此比DFS更优。&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;
const int maxe = 1e5 + 9, INF = 2147483647;
int n, m, sta, dis[maxe];
//1
struct node //邻接链表存图
{
int next, val;
};
std::vector&amp;lt;node&amp;gt; edges[maxe];
std::queue&amp;lt;int&amp;gt; run;
bool in[maxe];
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;sta);
for (int i = 1; i &amp;lt;= n; i++) //初始化
{
dis[i] = INF;
}
for (int i = 0; i &amp;lt; m; i++)
{
int a, b, v;
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;v);
edges[a].push_back(node{b, v});
}
run.push(sta); //将起点加入队列
dis[sta] = 0;
while (!run.empty())
{
int now = run.front();
run.pop();
in[now] = 0; //使队列中没有now
int len = edges[now].size();
for (int i = 0; i &amp;lt; len; i++)
{
if (dis[edges[now][i].next] &amp;gt; dis[now] + edges[now][i].val) //松弛操作
{
dis[edges[now][i].next] = dis[now] + edges[now][i].val;
//2
if (!in[edges[now][i].next]) //如果队列中没有
{
run.push(edges[now][i].next); //加入队列并标记
in[edges[now][i].next] = 1;
}
}
}
}
for (int i = 1; i &amp;lt;= n; i++)
{
printf(&amp;quot;%d &amp;quot;, dis[i]);
}
return 0;
}
&lt;/code>&lt;/pre>
&lt;h4 id="对于负环的判断">对于负环的判断&lt;/h4>
&lt;p>记录当前路径的最短路经过的边的数量，若边数大于总节点数，则说明一定有一条边被走了两次，证明有负环的存在。&lt;/p>
&lt;p>代码实现也很简单：&lt;/p>
&lt;pre>&lt;code class="language-c++">//在上面标号1的地方加入
int pass[maxe];
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-c++">//在上面标号2的地方加入
pass[edges[now][i].next] = pass[now] + 1;
if (pass[edges[now][i].next] &amp;gt; n)
{
printf(&amp;quot;orz&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>还有一种比较玄学的判负环方式，就是如果扩展了MAXN次还没出结果，就判定有负环。（MAXN为根据题目规模自拟的常量）&lt;/p>
&lt;p>原理简单易懂：跑了这么久还没出结果，当然是有负环咯~~NB的是经实测正确率还相当高！当然相当高还是牺牲了算法的正确性的，因此不到万不得已之时不建议使用(玄学你懂的)。&lt;/p>
&lt;h4 id="一些优化的方法">一些优化的方法&lt;/h4>
&lt;p>总体思想就是在你被出题人构造数据的情况下，如何能另辟蹊径，做出一些让出题人意想不到、另人捧腹大笑的sao操作，从而达到骗分的效果。&lt;/p>
&lt;ol>
&lt;li>简单的优化(只能让你的spfa跑的快一点，适用于常数大的同学。至于卡了spfa的题，仍旧没有什么用处。)
&lt;ol>
&lt;li>&lt;strong>SLF(Small Label First)优化：&lt;/strong> 在使用queue作为spfa的辅助数据结构时，将队列替换为双端队列，每当插入元素 $now$ 时，与队首进行比较，若 $dis[q.front()] &amp;gt; dis[now]$，将 $now$ 从队首插入，否则从队尾插入，使得更可能更新出节点最优解的节点最先进行更新，减少无用迭代次数。&lt;/li>
&lt;li>&lt;strong>LLL(Large Label Last）优化：&lt;/strong> 使用双端队列，维护目前队列中元素到起点的距离的平均值（即 $\sum^{tail}_{i=head}dis[edges[i]/n]$），设该数为 $k$，若 $dis[now] &amp;gt; k$，则从队尾插入，否则从队首插入，用处不大。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>升级的优化 (能过数据不刁钻的卡spfa的题，至于某些丧心病狂的出题人，拜拜了您嘞)
&lt;ol>
&lt;li>&lt;strong>容错后的SLF：&lt;/strong> 定义容错值 $val$，当满足 $dis[now] &amp;gt; dis[q.front()] + val$ 时从队尾插入，否则从队首插入，可以让程序不陷入局部最优解。&lt;/li>
&lt;li>&lt;strong>mcfx优化：&lt;/strong> 定义区间 $[l,r]$，当入队节点的入队次数属于这个区间的时候，从队首插入，否则从队尾插入，如过某个节点出发的大多数边都只能更新一个次解，那么它在队列中的优先级就会降低，防止链式结构卡死你。&lt;/li>
&lt;li>&lt;strong>Swap-SLF：&lt;/strong> 若队列改变且 $dis[q.front()] &amp;gt; dis[q.back()]$​​，交换队首队尾，比较玄学。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>玄学的优化(都是sao操作，能过多少看人品)
&lt;ol>
&lt;li>&lt;strong>边序随机：&lt;/strong> 将读入给你的边随机打乱后进行spfa&lt;/li>
&lt;li>&lt;strong>队列随机：&lt;/strong> 每个节点入队时，以 $\frac{1}{2}$ 的概率从队首入队，$\frac{1}{2}$​ 的概率从队尾入队。&lt;/li>
&lt;li>&lt;strong>队列随机优化版：&lt;/strong> 累计 $m$ 次入队后，将队列元素随机打乱。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="dfs方式">DFS方式&lt;/h3>
&lt;p>经过极其强大的优化后速度可能和BFS同级，但是在仅判断负环的问题中十分快。&lt;/p>
&lt;ol>
&lt;li>初始化：将dis数组除起点外赋值为 $\infty$ ，起点dis为$0$，将起点加入run队列。&lt;/li>
&lt;li>递归松弛：使用与当期节点相连的边更新其他相连节点的dis值，若 $i$ 号节点的dis值被更新，则对 $i$​ 号节点递归操作。&lt;/li>
&lt;li>重复递归，直到无法更新。&lt;/li>
&lt;/ol>
&lt;p>由于这种东西的实用性过低，不给出标程(实际上是懒得)。&lt;/p>
&lt;h4 id="关于优化">关于优化&lt;/h4>
&lt;p>&lt;a href="http://www.doc88.com/p-49816668344446.html" target="_blank" rel="noopener">姜碧野的《spfa算法的优化及应用》&lt;/a>十分详细且难以理解。&lt;/p>
&lt;h4 id="对于负环的判断-1">对于负环的判断&lt;/h4>
&lt;p>十分新奇，其实只需要记住结论即可。证明：&lt;a href="./SPFA-DFS%e8%b4%9f%e7%8e%af%e8%af%81%e6%98%8e.md">文档&lt;/a>&lt;/p>
&lt;p>结论即为：若存在负环，则&lt;strong>一定&lt;/strong>存在特定的至少一对终止点之间的不重叠顶点最短路径的边权从起点&lt;strong>依次&lt;/strong>相加&lt;strong>始终&lt;/strong>为负。&lt;/p>
&lt;p>所以，我们可以将dis数组初始值设为 $0$​，然后以每个节点为起点DFS，如果路径dis为正数就结束递归，这样相比于BFS方式可以忽略掉众多无用的边。&lt;/p>
&lt;p>但是，这种方法不能求最短路。&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;h2 id="最短路图">最短路图&lt;/h2>
&lt;p>对于只能在最短路径上操作且可能同时存在多条最短路的问题时，可以采用建最短路图的方法。&lt;/p>
&lt;p>将在 $i$ 和 $j$ 的最短路径上的边放入一个新的图当中，使得问题可以在一个DAG（有向无环图）上操作，因为最短路保证不出现环。&lt;/p>
&lt;p>最短路图的建立(有一点点dp的感jio)：&lt;/p>
&lt;p>首先，分别以 $i$ 和 $j$​ 跑一遍单源最短路(会用到)。&lt;/p>
&lt;p>首先，思考一个事情，如何判断一条边是否在最短路图中？&lt;/p>
&lt;p>当且仅当其满足 $dis_i[start]+val+dis_j[end]=dis_i[j]$ 时。&lt;/p>
&lt;p>翻译一下，就是从 $i$ 到边起点的最短路径长度加上路径的权值再加 $j$ 到路径终点的最短路径长度等于 $i$ 到 $j$​ 的最短路径长度，因为只有这样，才能保证最短路径长度不变，即一种可能的情况。&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;h2 id="分层图最短路">分层图最短路&lt;/h2>
&lt;p>用于求解一些有复杂决策的问题。&lt;/p>
&lt;p>在一个正常的图上可以进行 k 次决策，对于每次决策，不影响图的结构，只影响目前的状态或代价。一般将决策前的状态和决策后的状态之间连接一条权值为决策代价的边，表示付出该代价后就可以转换状态了。&lt;/p>
&lt;p>就是将每个点根据状态的不同拆成若干个点，用拆出来的所有点建立新图并跑最短路。&lt;/p>
&lt;p>一般有两种方案：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>建图时直接建成k+1层。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多开一维记录其余(决策)信息，但是对于多种决策用处不大。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>然后，在新建立的图中跑最短路。&lt;/p></description></item><item><title>SPFA-DFS负环证明</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/spfa-dfs%E8%B4%9F%E7%8E%AF%E8%AF%81%E6%98%8E/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/spfa-dfs%E8%B4%9F%E7%8E%AF%E8%AF%81%E6%98%8E/</guid><description>&lt;h1 id="spfa-dfs负环证明">SPFA-DFS负环证明&lt;/h1>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>让我们先来看结论：&lt;/p>
&lt;img src="graph.png" alt="spfa" style="zoom:60%;" />
&lt;p>如上图，明显可以看出 4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 8 -&amp;gt; 9 -&amp;gt; 10 -&amp;gt; 11 -&amp;gt; 12 -&amp;gt; 4 构成了一个负环。&lt;/p>
&lt;p>以任意节点为起点，用SPFA-DFS查找负环，则有：&lt;/p>
&lt;p>​ 若存在负环，则&lt;strong>一定&lt;/strong>存在特定的至少一对终止点之间的不重叠顶点最短路径的边权从起点&lt;strong>依次&lt;/strong>相加&lt;strong>始终&lt;/strong>为负。&lt;/p>
&lt;h2 id="正解">正解&lt;/h2>
&lt;p>我们只考虑在负环上的节点(因为我们只需证明这样的点对存在，非负权边节点情况过于复杂且并不影响答案的正确性，故忽略)。&lt;/p>
&lt;img src="%E8%B4%9F%E7%8E%AF.png" alt="fuhuan" style="zoom:67%;" />
&lt;p>我们对这个图重复进行如下操作：&lt;/p>
&lt;ol>
&lt;li>对于连续的正(负)权边进行合并，并删去权值为0的边，得到一个正负权边交替相连的图。
&lt;img src="1.png" alt="dsf" style="zoom:67%;" />&lt;/li>
&lt;li>对于一个正负权边交替相连的图，将一条负边 $i$​，$i$​ 的起止两个节点和 $i$​ 指向的正权边分为一组，求两个边权和并作为新边边权合并。新的边表示已 $i$​ 的起点为遍历起点，经过两条边之后的边权和。和为负，则说明可以走过这两条边；和为正，则说明不可以以其作为起点。
&lt;img src="2.png" style="zoom:67%;" />&lt;/li>
&lt;/ol>
&lt;p>第3步&lt;img src="3.png" alt="dfadf" style="zoom:67%;" />&lt;/p>
&lt;p>第4步&lt;img src="4.png" alt="adf" style="zoom:67%;" />&lt;/p>
&lt;p>直到图中仅剩下两个节点和两条边，这时，一定有两边之和小于0。(因为两边之和即为环上边权之和)&lt;/p>
&lt;p>因此，从这时负边的起点开始遍历原来的负环，保证边权依次相加为负。&lt;/p>
&lt;p>对于任意一条负边，表示从起始节点到终止节点所包含的边依次相加为负，边权为从起点走到终点后的边权和。我们每次选择的均为负边起点。&lt;/p></description></item><item><title>强连通分量与缩点</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E4%B8%8E%E7%BC%A9%E7%82%B9/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E4%B8%8E%E7%BC%A9%E7%82%B9/</guid><description>&lt;h1 id="强连通分量与缩点">强连通分量与缩点&lt;/h1>
&lt;h2 id="又是啥玩意">又是啥玩意&lt;/h2>
&lt;h3 id="强连通">强连通&lt;/h3>
&lt;p>&lt;del>在&lt;strong>有向图&lt;/strong> $G$ 中，两个顶点 $u$，$v$ 间有一条从 $u$ 到 $v$ 的有向路径，同时还有一条从 $v$ 到 $u$ 的有向路径，则节点 $u$ 和 节点 $v$ 强连通。&lt;/del>&lt;/p>
&lt;p>啥玩意嘛。&lt;/p>
&lt;p>简单一点，&lt;strong>有向图&lt;/strong>中，两个节点之间可以&lt;strong>互相&lt;/strong>到达，则这两个节点强连通。&lt;/p>
&lt;h3 id="强连通图">强连通图&lt;/h3>
&lt;p>若有向图 $G$ 的每两个顶点都强连通，则 $G$ 是一个强连通图。&lt;/p>
&lt;h3 id="强连通分量">强连通分量&lt;/h3>
&lt;p>&lt;del>有向非强连通图的极大强连通子图，称为强连通分量。&lt;/del>&lt;/p>
&lt;p>又是嘛?&lt;/p>
&lt;p>一个图 $G$，如果是有向图，但是不是强连通图，则图 $G$ 的所有是强连通图的子图中最大的(节点数最多的)称为强连通分量。&lt;/p>
&lt;h2 id="咋求向你缓缓打出一个">咋求？&lt;del>(向你缓缓打出一个？)&lt;/del>&lt;/h2>
&lt;h3 id="tarjan算法">Tarjan算法&lt;/h3>
&lt;p>经典算法？&lt;/p>
&lt;p>首先，需要知道关于&lt;a href="/oiblogs/graph%e5%9b%be%e8%ae%ba/%e6%90%9c%e7%b4%a2/%e6%90%9c%e7%b4%a2/">DFS生成树&lt;/a>的一些东西。&lt;/p>
&lt;p>观察发现，任何一个强连通分量中必须有至少一个返祖边，因此如果结点 $u$ 是某个强连通分量在搜索树中遇到的第一个结点，那么这个强连通分量的其余结点肯定是在搜索树中以 $u$ 为根的子树中。$u$ 被称为这个强连通分量的根。Tarjan便以此为基础，进行求解。&lt;/p>
&lt;h4 id="维护变量">维护变量&lt;/h4>
&lt;ul>
&lt;li>$dfn[i]$：维护节点 $i$ 的&lt;a href="/oiblogs/graph%e5%9b%be%e8%ae%ba/%e6%90%9c%e7%b4%a2/%e6%90%9c%e7%b4%a2/">dfs搜索序&lt;/a>。&lt;/li>
&lt;li>$low[i]$：维护节点 $i$ 的子树中和子树中通过一条不在搜索树上的边能到达的所有结点的最小dfn值。&lt;/li>
&lt;li>$stack:run$：维护一个队列，保证上面的节点在以底下第一个 $low[i]=dfn[i]$ 的节点为根的强连通分量中。&lt;/li>
&lt;/ul>
&lt;p>从而我们得到两个推论：&lt;/p>
&lt;ol>
&lt;li>上节点的 $dfn$ 都大于该结点的 $dfn$ 。&lt;/li>
&lt;li>从根开始的一条路径上的 $dfn$ 严格递增，$low$ 严格非降。&lt;/li>
&lt;/ol>
&lt;h4 id="三种情况">三种情况&lt;/h4>
&lt;p>对于当前节点 $u$，有一条 $u\rightarrow{v}$ 的边：&lt;/p>
&lt;ol>
&lt;li>节点 $v$ 未被访问过：继续对 $v$ 进行深度搜索。在回溯过程中，更新 $low[u]=min(low[u],low[v])$。&lt;/li>
&lt;li>节点 $v$ 被访问过，并且在栈中：说明找到一个返祖边，直接更新 $low[u]=min(low[u],low[v])$ 即可。&lt;/li>
&lt;li>节点 $v$ 被访问过，并且不在栈中：节点 $v$ 的强连通分量的根节点已经被找到，其强连通分量已经确定，不用操作。&lt;/li>
&lt;/ol>
&lt;h4 id="注意">注意&lt;/h4>
&lt;img src="graph%20(1).png" style="zoom: 75%;" />
&lt;p>当我们回溯到节点 $i$，发现其 $low[i]=dfn[i]$ 时，说明我们找到一个强连通分量的根节点，栈中在节点 $i$ 上面的都在以节点 $i$ 为根的强连通分量中，因此，对于 $\forall{}\space node\space x\in{upper\space i},\space low[x]=dfn[i]$ 。&lt;/p>
&lt;p>否则，看上图…………经过细致的观察，我们发现，节点 $1、7、5、8、3、4$ 为强连通分量。如果你不在出栈的时候再更新一次，你就惊喜的发现，$low[4]=4$ ？？？因为搜索到 $4\rightarrow8$ 这条边的时候，因为节点 $8$ 刚刚搜搜索到一条至 $low=4$ 的节点，所以$low[8]=4$，就导致 $low[4]=4$，而后没有边再访问到节点 $4$，因此其 $low$ 值无法得到更新，始终为 $4$ ！！！然而，这显然是错的…………&lt;/p>
&lt;p>然后，注意一定要在子树都搜索完成后，在进行弹栈操作。这样，保证横叉边也可以积攒在栈中。&lt;/p>
&lt;h4 id="缩点">缩点&lt;/h4>
&lt;p>&lt;del>看起来好高深的ya子&lt;/del>&lt;/p>
&lt;p>这玩意菜的一批。&lt;/p>
&lt;p>就是对于原来图中的边 $u\rightarrow v$ ，若 $low[u]\neq low[v]$ ，则在新图中连接一条 $low[u]\rightarrow low[v]$ 的边；若 $low[u]=low[v]$ ，则不执行任何操作。&lt;/p>
&lt;p>这时候，我们会发现有可能连重了…………不影响的，好吧，不要强迫症。&lt;/p>
&lt;h4 id="板子">板子&lt;/h4>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3387" target="_blank" rel="noopener">洛谷P3387 【模板】缩点&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using std::max;
using std::min;
const int maxn = 1e4 + 9;
std::vector&amp;lt;int&amp;gt; next[maxn];
std::vector&amp;lt;int&amp;gt; nnet[maxn];
std::vector&amp;lt;int&amp;gt; root;
std::stack&amp;lt;int&amp;gt; run;
int n, m, val[maxn], dfn[maxn], low[maxn], cnt, nval[maxn], ans;
std::bitset&amp;lt;maxn&amp;gt; ins;
void tarjan(int now) //我们直接使用dfn[i]==0?来判断节点 i 是否被访问过
{
ins[now] = 1; //对于任何一个没有被访问过的节点,有可能是根,加入栈
run.push(now);
dfn[now] = low[now] = ++cnt; //我们不清楚其子树
for (int i : next[now]) //遍历所有出度
{
if (!dfn[i]) //如果没有访问过,递归查找并update
{
tarjan(i);
low[now] = min(low[now], low[i]);
}
else if (ins[i]) //如果访问过,直接更新
{
low[now] = min(low[now], low[i]);
}
}
if (dfn[now] == low[now]) //我们搜索完了整个子树,若成立,即可判断当前节点是强连通分量的根
{
while (!run.empty() &amp;amp;&amp;amp; dfn[run.top()] != low[run.top()]) //将压在当前节点上的都弹出
{
nval[low[now]] += val[run.top()]; //统计强连通分量中节点权值和
low[run.top()] = min(low[run.top()], low[now]); //标记所有强连通分量的节！！！
ins[run.top()] = 0; //不在栈中了
run.pop();
}
run.pop(); //同上
ins[now] = 0;
nval[low[now]] += val[now];
}
}
void find(int now) //直接DFS暴搜找到最大路径
{
cnt += nval[now];
int len = nnet[now].size();
if (!len)
{
ans = max(ans, cnt);
}
for (int i = 0; i &amp;lt; len; i++)
{
find(nnet[now][i]);
}
cnt -= nval[now];
}
int main()
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
for (int i = 1; i &amp;lt;= n; i++)
{
scanf(&amp;quot;%d&amp;quot;, &amp;amp;val[i]);
}
int u, v;
for (int i = 0; i &amp;lt; m; i++)
{
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;u, &amp;amp;v);
next[u].push_back(v);
}
for (int i = 1; i &amp;lt;= n; i++) //防止出现非连通图,对于所有没被遍历到的点做Tarjan
{
if (!dfn[i])
{
ins.reset(); //多次不清空,暴零两行泪
while (!run.empty())
run.pop();
tarjan(i);
}
}
ins.reset(); //废物利用qwq
for (int j = 1; j &amp;lt;= n; j++)
{
for (int i : next[j])
{
if (low[j] != low[i]) //这就是传说中的缩点
{
nnet[low[j]].push_back(low[i]);
ins[low[i]] = 1; //记录入度
}
}
}
for (int i = 1; i &amp;lt;= n; i++)
{
if (!ins[i]) //找到图中所有入度为0的点为根(非连通图可能有多个根)
{
root.push_back(i);
}
}
for (int now : root) //对于每个根,跑DFS
{
cnt = 0; //又是废物利用qwq
find(now);
}
printf(&amp;quot;%d&amp;quot;, ans);
return 0;
}
&lt;/code>&lt;/pre></description></item><item><title>树链刨分</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</guid><description>&lt;h1 id="树链刨分">树链刨分&lt;/h1>
&lt;p>一种极致优化的树上算法，据说07年被某个集训队队员搞出来的。&lt;/p>
&lt;p>关于DFN序，参见&lt;a href="/oiblogs/graph%e5%9b%be%e8%ae%ba/%e6%90%9c%e7%b4%a2/%e6%90%9c%e7%b4%a2/">搜索&lt;/a>。&lt;/p>
&lt;h2 id="一波约定">一波约定&lt;/h2>
&lt;p>为方便起见,我们约定一棵树的某些数据如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>$siz[i]$ 表示 $i$ 结点的子树大小&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$dep[i]$ 表示 $i$ 结点的所在深度(定义根的所在深度为$1$)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$fa[i]$ 表示 $i$ 结点的父结点编号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$bson[i]$ 表示 $i$ 节点的重儿子的编号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$top[i]$ 表示 $i$ 节点所在链的顶端节点&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="儿子还分轻重">儿子还分轻重?&lt;/h2>
&lt;p>对于任意一个&lt;strong>非叶子&lt;/strong>结点，它的子结点中 $siz$ 最大的定义为它的重儿子，其余的子结点定义为它的轻儿子。注意：重儿子有且仅有一个，若有多个最大子树，任意选择一个为重儿子，其余为轻儿子即可。叶子节点没有重儿子。&lt;/p>
&lt;blockquote>
&lt;p>很好理解，从字面上来看，重儿子就是子树中节点数最多的那一个，比较“重”；而剩下的儿子的子树节点数比较少，所以就“轻”。&lt;/p>
&lt;/blockquote>
&lt;p>这样，我们可以将树上的边也分为两类：父结点与重儿子之间连接的边为&lt;strong>重边&lt;/strong>，与轻儿子连接的边为&lt;strong>轻边&lt;/strong>。&lt;/p>
&lt;p>进而推广到，由多条重边连接而成的路径为&lt;strong>重链&lt;/strong>。&lt;/p>
&lt;p>看一个例子：&lt;/p>
&lt;img src="%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86.png" alt="adf" style="zoom:80%;" />
&lt;p>其中，&lt;font color="ffbf00">黄色节点&lt;/font>为其父亲节点的&lt;font color="ffbf00">重儿子&lt;/font>，白色为轻儿子；&lt;font color="red">红色边&lt;/font>为&lt;font color="red">重边&lt;/font>，黑色为轻边；&lt;font color="green">绿色底&lt;/font>为&lt;font color="green">重链&lt;/font>。&lt;/p>
&lt;p>如此划分，则：&lt;/p>
&lt;ol>
&lt;li>轻边 $(u,v)$ 中, $size(u)≤ size(\frac{v}{2})$&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>至少存在一个重儿子大于等于自己的 $size$。&lt;/p>
&lt;/blockquote>
&lt;ol start="2">
&lt;li>
&lt;p>从根到某一点的路径上,不超过 $\log{n}$ 条轻链和不超过 $\log{n}$ 条重链。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>树中任意两个节点之间的路径，都可以将其拆分为不超过 $4\log{n}$ 条重链 + 轻边&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="它来了">它来了&lt;/h2>
&lt;p>&lt;del>本质上是一种优化暴力&lt;/del>&lt;/p>
&lt;p>首先，完成树链剖分，有如下操作：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>求出每个节点的子树大小(找到重儿子)，每个节点的深度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在第 $1$ 步的基础上，找出每条轻链和重链&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>简化一下，就是先DFS一次，求DFS序，把烂七八糟的填上；然后再来一次，把轻链和重链搞出来，完事。&lt;/p>
&lt;p>第一次：&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void dfs1(int now, int deep)
{
dep[now] = deep;
int big = 0; //别忘了初始化
for (auto i : next[now])
{
if (!fa[i]) //无向图判断是否是父节点，防止死循环
{
fa[i] = now; //子节点的父亲是自己
dfs1(i, deep + 1); //递归遍历
if (size[i] &amp;gt; big) //有更重的儿子
{
big = size[i];
son[now] = i; //标记重儿子
}
size[now] += size[i]; //加上这个儿子的size
}
}
size[now]++; //加上自己的1个
return;
}
&lt;/code>&lt;/pre>
&lt;p>第二次：&lt;/p>
&lt;pre>&lt;code class="language-c++">inline void dfs2(int now, int t, bool big)
{
//这里如果要维护区间的话，要记录dfn序，注意先遍历重儿子
top[now] = t; //维护链顶端顶点
if (!son[now]) //叶子节点
return;
dfs2(son[now], t, 1); //先递归查找重链
for (int i : next[now])
{
if (i != fa[now] &amp;amp;&amp;amp; i != son[now])
{
dfs2(i, i, 0); //递归轻边
}
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="一些细节">一些细节&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>轻链：&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>很多博文中，我们又看到了一个新的东西——轻链。&lt;/p>
&lt;p>其实，你是&lt;strong>不能&lt;/strong>把轻边连成一条链的，看下图：&lt;/p>
&lt;img src="graph%20(3)-16332643443841.png" style="zoom:70%;" />
&lt;p>我们观察发现，如果我们将 $9$ 挂到 $3$ 上面的话，就和 $3\rightarrow8\rightarrow10$ 这条重链重了，造成求解的失败。&lt;/p>
&lt;ol start="2">
&lt;li>&lt;strong>top：&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>在树链刨分中，我们要把一条重链上的点看做一个点，即这条重链的顶点，比较是均以顶点去比较。&lt;/p>
&lt;ol start="3">
&lt;li>&lt;strong>跳转fa：&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>注意，每次跳转的时候，都要跳转到顶点的fa，否则就死循环卡那了。&lt;/p>
&lt;h2 id="实战求解lca">实战：求解LCA&lt;/h2>
&lt;p>LCA，最近公共祖先。&lt;/p>
&lt;p>结点 $u$ 和 $v$ 向上跳，每次将&lt;strong>深度较大&lt;/strong>的结点跳到自己所在的链的顶端结点，重复执行直至两个结点位于同一条重链上。&lt;/p>
&lt;p>一个一个的跳，防止跳过了。&lt;/p>
&lt;p>选择深度较大的点，保证了在跳到的链上从顶点到原先的深度可以反复横跳，这样，如果另一个深度较小的点也跳到了同一个链上，则上链深度一定在深度较大的点的横跳范围之内，所以就是LCA。&lt;/p>
&lt;p>这里注意，每次将&lt;strong>链顶深度&lt;/strong>大的点向上跳，当在同一条链上时，取&lt;strong>深度较小&lt;/strong>的点为LCA。&lt;/p>
&lt;p>时间复杂度为 $O(\log{n})$&lt;/p>
&lt;p>[洛谷 P3379 【模板】最近公共祖先（LCA）][https://www.luogu.com.cn/problem/P3379]&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
const int maxn = 5e5 + 9;
int n, m, root, size[maxn], son[maxn], top[maxn], dep[maxn], fa[maxn];
std::vector&amp;lt;int&amp;gt; next[maxn];
inline void dfs1(int now, int deep)
{
dep[now] = deep;
int big = 0, ji = 0;
for (auto i : next[now])
{
if (!fa[i])
{
fa[i] = now;
dfs1(i, deep + 1);
if (size[i] &amp;gt; big)
{
big = size[i];
son[now] = i;
}
size[now] += size[i];
}
}
size[now]++;
return;
}
inline void dfs2(int now, int t, bool big)
{
top[now] = t;
if (!son[now])
return;
dfs2(son[now], t, 1);
for (int i : next[now])
{
if (i != fa[now] &amp;amp;&amp;amp; i != son[now])
{
dfs2(i, i, 0);
}
}
}
inline int lca(int a, int b)
{
while (top[a] != top[b])
{
if (dep[top[a]] &amp;lt; dep[top[b]])
std::swap(a, b);
a = fa[top[a]];
}
return dep[a] &amp;gt; dep[b] ? b : a;
}
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;root);
for (int i = 1; i &amp;lt; n; i++)
{
int a, b;
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
next[a].push_back(b);
next[b].push_back(a);
}
fa[root] = root;
dfs1(root, 1);
dfs2(root, root, 0);
while (m--)
{
int a, b;
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
printf(&amp;quot;%d\n&amp;quot;, lca(a, b));
}
return 0;
}
&lt;/code>&lt;/pre></description></item><item><title>欧拉回路</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</guid><description>&lt;h1 id="欧拉回路">欧拉回路&lt;/h1>
&lt;h2 id="前置知识">前置知识&lt;/h2>
&lt;p>图 $G$ 中恰好经过所有边一次(不可重复经过)的通路称作欧拉通路，恰好经过所有边一次的回路称作欧拉回路。&lt;/p>
&lt;p>具有欧拉回路的图称为欧拉图，具有欧拉通路但不具有欧拉回路的图称为半欧拉图。&lt;/p>
&lt;p>&lt;strong>存在欧拉通路的充要条件：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>无向图：&lt;/strong> 各点连通，没有或仅有两个奇度结点。(偶度保证一入一出，两个奇度可以作为起止节点)&lt;/li>
&lt;li>&lt;strong>有向图：&lt;/strong> 各点连通，有一个点出度 = 入度 +1，有一个点入度 = 出度 +1，其余点入度 = 出度。(入度出度相同保证一入一出，其余两点为起止节点)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>存在欧拉回路的充要条件：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>**无向图：**各点连通，所有点为偶度。(存在奇度节点即存在起止点，当起止点相同时，$奇数+奇数=偶数$，因此所有节点均为偶度)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**有向图：**各点连通，所有点入度 = 出度。(当其起止点为同一个是，那个点 入度 +1 = 出度 +1，因此所有点入度 = 出度)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="dfs求解">DFS求解&lt;/h2>
&lt;p>利用欧拉定理判断出一个图存在欧拉回路或欧拉通路后，选择一个正确的起始顶点，用DFS算法遍历所有的边(每一条边只遍历一次)，遇到走不通就回退。在搜索前进方向上将遍历过的边按顺序记录下来，这组边的排列就组成了一条欧拉通路或回路。&lt;/p>
&lt;h2 id="fleury佛罗莱算法">Fleury(佛罗莱)算法&lt;/h2>
&lt;p>&lt;del>以后有时间再说&lt;/del>&lt;/p></description></item><item><title>二分图匹配</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</guid><description>&lt;h1 id="二分图匹配">二分图匹配&lt;/h1>
&lt;h2 id="前置知识二分图">前置知识——二分图&lt;/h2>
&lt;p>首先，要明白什么是二分图(又称作二部图)。&lt;/p>
&lt;p>形象的描述一下，现在你是某市的市长，而一条大河从你的城市中心穿流而过。所以，你为了使你的城市交通遍历，促进城市发展，你决定在这条河上建桥，以连接河两岸的路口。&lt;/p>
&lt;img src="%E8%8D%89%E7%BA%B8-10.jpg" alt="pi" style="zoom: 33%;" />
&lt;p>如上图，所有河上的桥和路口就组成了一个二分图。&lt;/p>
&lt;p>二分图的定义：如果顶点 $V $ 可分割为两个互不相交的子集 $(A,B)$，并且图中的每条边 $(i，j)$ 所关联的两个顶点 $i$ 和 $j$ 分别属于这两个不同的顶点集 $(i \in A,j \in B)$，则称图G为一个二分图。简而言之，就是顶点集 $V$ 可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。&lt;/p>
&lt;p>意思就说，你把一个图的顶点分到河的两岸，图上所有的边只能是桥，不能是陆地上的公路，即不能在河的一侧修建边。&lt;/p>
&lt;img src="graph.png" alt="sdafa" style="zoom:67%;" />
&lt;p>区别二分图，关键是看点集是否能分成两个独立的点集。无向图G为二分图的&lt;strong>充要条件&lt;/strong>是，$G$ 至少有两个顶点，且其所有环的长度均为偶数，&lt;strong>不存在奇环&lt;/strong>。&lt;strong>可以存在偶环&lt;/strong>，如上图 $2\rightarrow7\rightarrow3\rightarrow8\rightarrow2$ 就是一个偶环，但上图满足二分图。任何无回路的的图均是二分图。&lt;/p>
&lt;p>**总结：**DFS/BFS，如发现奇环则不是二分图，否则是。&lt;/p>
&lt;p>&lt;a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE" target="_blank" rel="noopener">充要条件的证明(百度百科)&lt;/a>&lt;/p>
&lt;p>更简单的：因为每一条边都是从一个集合走到另一个集合，只有走偶数次才可能回到同一个集合。&lt;/p>
&lt;h2 id="最大匹配">最大匹配&lt;/h2>
&lt;p>**匹配：**从二分图中选择 $n$ 条边，保证没有任何一个顶点是两条或以上边的终点。&lt;/p>
&lt;p>一个形象的事情：&lt;/p>
&lt;p>现在你变身成为了月老，发现今天有 $n$ 个男生和 $m$ 个女生在你的庙(月老庙)前许愿求姻缘。你今天很高兴，决定帮帮他们。他们每个人祈祷的时候都说了他们心仪的对象，你将他们整理了一下，将可能(符合双方的要求 -__- )的两个人之间连一条线(假设没有gay)，建立了一个二分图。&lt;/p>
&lt;p>这时候，作为善良的你，需要履行帮助人类繁衍生息的职责，因此要促成尽可能多的情侣狗，问最多能搞成几对？&lt;/p>
&lt;p>数学表示：若 $E'\in E$，且 $E'$ 中任意两条边不共用同一个顶点，则称 $E'$ 是二分图 $G$ 的一个匹配。&lt;/p>
&lt;p>**最大匹配：**边数最多的匹配(促成的情侣狗最多)。即 $E'$ 中边数最大。&lt;/p>
&lt;p>**完美匹配：**所有向你求愿单身狗都变成了情侣狗。即 $E'=E$。&lt;/p>
&lt;h2 id="匈牙利算法寻找最大匹配">匈牙利算法——寻找最大匹配&lt;/h2>
&lt;h3 id="交替路与增广路">交替路与增广路&lt;/h3>
&lt;p>**交替路：**从一个未匹配点出发，依次经过非匹配边、匹配边，并且第一条和最后一条边均为非匹配边，形成的路径叫交替路。&lt;/p>
&lt;p>**增广路：**从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>红色的边为当前的匹配
&lt;img src="%E5%A2%9E%E5%B9%BF%E8%B7%AF1.png" alt="1" style="zoom:13%;" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>紫色的边为当前匹配的增广路
&lt;img src="%E5%A2%9E%E5%B9%BF%E8%B7%AF2.png" alt="2" style="zoom:13%;" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将增广路中匹配的边和非匹配变交换，匹配边数 $+1$
&lt;img src="%E5%A2%9E%E5%B9%BF%E8%B7%AF3.png" alt="3" style="zoom:13%;" />&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="匈牙利算法的真面目">匈牙利算法的真面目&lt;/h3>
&lt;p>匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。&lt;del>(看完的都是好宝宝)&lt;/del>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/qq_41730082/article/details/81162561?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162919822716780274126376%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=162919822716780274126376&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81162561.pc_search_result_control_group&amp;amp;utm_term=%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D&amp;amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">有意思的博文一篇&lt;/a>&lt;/p>
&lt;p>简单一点，就是一个不断逼近答案的过程。&lt;/p>
&lt;p>对于每个节点，执行如下步骤：&lt;/p>
&lt;ol>
&lt;li>如果连接这个节点的任何一条边可以被选中，则将这条边加入匹配，返回TRUE。&lt;/li>
&lt;li>如果莫得可以加入的边了，那么可以推导出连接它的所有边均为非匹配边。然后开始逐个寻找增广路，直到全部遍历完成(返回FALSE)或者把其中的某一条边加入匹配(即找到了一条增广路，返回TRUE)。&lt;/li>
&lt;/ol>
&lt;p>&lt;del>这个东西的烦人之处在于这玩意的代码………………难以理解，需得手推&lt;/del>&lt;/p>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P3386" target="_blank" rel="noopener">洛谷P3386&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-c++">#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;vector&amp;gt;
const int maxe = 600;
int n, m, e, ans, pot[maxe]; //一共有n个男生,m个女生,共e条边,pot[i]表示第i个女生属于的男生编号
std::bitset&amp;lt;maxe&amp;gt; vis; //标记是否访问过(名花有主)
std::vector&amp;lt;int&amp;gt; con[maxe]; //以男生的角度记录这张图(因为要遍历男生找女生)
inline bool dfs(int now)
{
for (auto i : con[now]) //遍历他有好感的所有女生
{
if (!vis[i]) //如果这个女生现在莫得npy
{
vis[i] = 1; //表示你就是我的了
if (!pot[i] || dfs(pot[i])) //如果你原先没有npy或者前男友鱼塘里还有
{
pot[i] = now; //你现在彻底是我的了
return true; //表示我找到npy了(-_-)
}
}
}
return false; //我没有找到(T_T)
}
int main()
{
scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;e);
for (int i = 0; i &amp;lt; e; i++)
{
int a, b;
scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
con[a].push_back(b);
}
for (int i = 1; i &amp;lt;= n; i++)
{
vis.reset(); //每次都重新分配
if (dfs(i)) //如果现在的这个男生找到了npy,就又多了一对情侣
ans++;
}
printf(&amp;quot;%d&amp;quot;, ans);
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>时间复杂度 $O(nm)$ 。&lt;/p>
&lt;h2 id="最大匹配的引申">最大匹配的引申&lt;/h2>
&lt;h3 id="最小边覆盖-n---最大匹配">最小边覆盖= n - 最大匹配&lt;/h3>
&lt;p>一个边集里的边能覆盖所有的点，最小边覆盖是满足这个要求的所有边集中边数最少的一个。&lt;/p>
&lt;p>&lt;strong>证明：&lt;/strong>&lt;/p>
&lt;p>因为边数越小越好，则每条边能覆盖的点一定是越多越好(尽量每条边都覆盖2个点)，而最大匹配找出了最多覆盖2个点的边。而剩下的就只能一条边覆盖一个点了。&lt;/p>
&lt;p>所以，设总顶点数为 $n$，最大匹配边为 $m$，则可以得到
$$
最小边覆盖=m+(n-2m)=n-m
$$&lt;/p>
&lt;h3 id="最小点覆盖--最大匹配">最小点覆盖 = 最大匹配&lt;/h3>
&lt;p>**最小点覆盖：**假如选了一个点就相当于覆盖了以它为端点的所有边。最小点覆盖就是选择最少的点来覆盖所有的边。&lt;/p>
&lt;p>**证明：**由最大匹配可知，不存在一条边的两个端点均没有被在最大匹配集合中的边所连接的情况(否则这条边就可以加入匹配)。因此，我们可以将边分为两类：匹配边和非匹配边；也可以将点分为两类：是匹配边的端点和不是匹配边的端点。&lt;/p>
&lt;img src="%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96.png" alt="df" style="zoom:13%;" />
&lt;p>如上图，&lt;font color="red">匹配边&lt;/font>，非匹配边，&lt;font color="purple">匹配边的端点&lt;/font>，&lt;font color="green">不是匹配边的端点&lt;/font>。&lt;/p>
&lt;p>在&lt;font color="purple">匹配边的端点&lt;/font>中选择有相邻&lt;font color="green">不是匹配边的端点&lt;/font>的点即可。&lt;/p>
&lt;p>这样的点保证之多有最大匹配个。&lt;/p>
&lt;p>首先，我们只要没傻到在同一条&lt;font color="red">匹配边&lt;/font>上选择两个点就行，这样，所有的&lt;font color="red">匹配边&lt;/font>均可被覆盖。&lt;/p>
&lt;p>同一条&lt;font color="red">匹配边&lt;/font>上的端点不可能同时与&lt;font color="green">不是匹配边的端点&lt;/font>相邻，否则构成一条增广路(如上图，若有11号节点与9号节点连接，则 $11\rightarrow9\rightarrow5\rightarrow10$ 构成增广路)。&lt;/p>
&lt;p>因此，最小点覆盖 = 最大匹配。&lt;/p>
&lt;h3 id="最大独立集--n---最小点覆盖">最大独立集 = n - 最小点覆盖&lt;/h3>
&lt;p>选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。找出一个包含顶点数最多的独立集称为最大独立集。&lt;/p>
&lt;p>**证明：**去掉最小点覆盖的顶点后，所有点之间不连通(因为删去最小点覆盖保证所有边均删除，因此不会出现连通)。&lt;/p>
&lt;h3 id="最小不可重链覆盖">最小不可重链覆盖&lt;/h3>
&lt;h3 id="有权最大匹配等">有权最大匹配等&lt;/h3>
&lt;p>参见&lt;a href="">网络流&lt;/a>和&lt;a href="">费用流&lt;/a>。&lt;/p></description></item><item><title>差分约束</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</guid><description>&lt;p>&lt;a href="https://blog.csdn.net/consciousman/article/details/53812818?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162925274616780265475802%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=162925274616780265475802&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53812818.pc_search_result_control_group&amp;amp;utm_term=%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F&amp;amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener">难懂但是比较全的博文&lt;/a>&lt;/p>
&lt;h2 id="这是啥子">这是啥子?&lt;/h2>
&lt;p>简单来说，差分约束就是把不等式转变成图的一种思想。因为题目可能会给你很多不等式，使用数学方法很有可能无解，而且难以找到这些不等式之间的联系。但是当我们把它们转化成图之后，就可以使用图论的思想来解题。&lt;/p>
&lt;p>通常，差分约束是用来解决求一组形如 $a-b\leq{c}$ 的不等式的可能最大/最小解。&lt;/p>
&lt;p>对于每一个 $i-j\le z$，建立一条从 $j$ 到 $i$ 权值为 $z$ 的有向边，将求解 $a-b\le{c}$ 的最大/最小值转化为求从 $b$ 到 $a$ 的最短/最长路径长度。&lt;/p>
&lt;h2 id="三角不等式">三角不等式&lt;/h2>
&lt;p>若有一个不等式组：&lt;/p>
&lt;p>$$
\begin{cases}\begin{aligned}\begin{array}{rcl}
&amp;amp;C-B\le{a}\newline&amp;amp;C-A\le{b}\newline&amp;amp;B-A\le{c}
\end{array}\end{aligned}\end{cases}
$$&lt;/p>
&lt;p>则根据上述条件，可以建图如下：&lt;/p>
&lt;img src="graph.png" alt="adf" style="zoom:95%;" />
&lt;p>由不等式相加组合，可得到 $max(C-A)=min(b,a+c)$，这也正好对应图中 $A$ 到 $C$ 的最短路。&lt;/p>
&lt;p>对于最大值：
$$
\begin{aligned}
\begin{cases}\begin{array}{rcl}
&amp;amp;C-B\ge{a}\newline&amp;amp;C-A\ge{b}\newline&amp;amp;B-A\ge{c}
\end{array}
\end{cases}
\end{aligned}
$$
由不等式相加组合，可得到 $min(C-A)=max(b,a+c)$，这也正好对应图中 $A$ 到 $C$ 的最长路。&lt;/p>
&lt;p>因此，对三角不等式加以推广，变量 $n$ 个，不等式 $m$ 个，要求 $C-A$ 的最大/最小值，便就是求取建图后 $A-C$ 的最短/最长路。&lt;/p>
&lt;p>另：&lt;/p>
&lt;ol>
&lt;li>若出现 $C-A=b$ 的情况，可以拆分为 $C-A\ge{b}$ 和 $C-A\le{b}=A-C\ge{-b}$ 或 $C-A\ge{b}=A-C\le{-b}$ 和 $C-A\le{b}$ 两条边。&lt;/li>
&lt;li>若出现 $C-A&amp;gt;b$的情况，因为题目中大多是整形数据，因此变为 $C-A\ge{b+1}$ 即可。&lt;/li>
&lt;li>值得注意的一点是：若建立的图不联通，则需要加入一个超级源点 $S$，在 $S$ 和其他的每个点之间建立一条权值为 $0$ 的&lt;strong>无向边&lt;/strong>，然后从 $S$ 点开始求解即可。&lt;/li>
&lt;/ol>
&lt;h2 id="无名算法">无名算法&lt;/h2>
&lt;p>流程：&lt;/p>
&lt;ol>
&lt;li>构建基于不等式的关系图。&lt;/li>
&lt;li>跑&lt;a href="./%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84.md">最短路&lt;/a>(注意，最长路可以通过spfa求出来，只需要改下松弛的方向即可，即&lt;code>if(dis[v] &amp;lt; dis[u] + val(u,v)) dis[v] = dis[u] + val(u,v)&lt;/code>。当然我们可以把图中所有的边权取负，求取最短路，两者是等价的。)&lt;/li>
&lt;li>建图后不一定存在最短路/最长路，因为可能存在负环/正环，判断差分约束系统是否存在解一般判环即可。&lt;/li>
&lt;/ol>
&lt;p>一些注意事项：&lt;/p>
&lt;ol>
&lt;li>根据条件把题意通过变量组表达出来得到不等式组，注意要发掘出隐含的不等式，比如说前后两个变量之间隐含的不等式关系。&lt;/li>
&lt;li>建好图之后直接spfa求解，一般不能用dijstra算法，因为通常存在负边。&lt;/li>
&lt;li>注意初始化的问题。&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://www.luogu.com.cn/problem/P5960" target="_blank" rel="noopener">洛谷P5960&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-c++">
&lt;/code>&lt;/pre>
&lt;script src='//unpkg.com/valine/dist/Valine.min.js'>&lt;/script>
&lt;div id="vcomments">&lt;/div>
&lt;script>
new Valine({
el: '#vcomments',
appId: 'mUFdj80doBeHANJjnbmU89gH-gzGzoHsz',
appKey: 'p4p7vzJrQnIYoajXvUjpuiRy',
placeholder: '说点什么叭~ (邮箱和网址不强制，邮箱用于Gravatar头像显示)',
visitor: true,
recordIP: true,
serverURLs: false,
enableQQ: true
})
&lt;/script></description></item><item><title>01分数规划</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/</guid><description>&lt;h1 id="01分数规划">01分数规划&lt;/h1>
&lt;h2 id="问题">问题&lt;/h2>
&lt;p>使两个线性函数的比值最大或最小的问题，称作分数规划问题或双曲线问题。&lt;/p>
&lt;p>而01分数规划和01背包问题差不多：&lt;/p>
&lt;p>我们现在有 $n$ 个物品，每一个物品均有一个 $val$ 和 $cost$，$x_i\in[0,1]$ 表示第 $i$ 物品是(1)否(0)选择。&lt;/p>
&lt;p>从 $n$ 个物品必须选择 $k$ 个，求下式的最大/最小值。
$$
\frac{\sum_{i=1}^nval_i\times{x_i}}{\sum_{i=1}^ncost_i\times{x_i}}
$$&lt;/p>
&lt;h2 id="二分解法">二分解法&lt;/h2>
&lt;p>&lt;a href="/oiblogs/basic%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3/%e5%88%86%e6%b2%bb/">二分在这边&lt;/a>&lt;/p>
&lt;p>假设答案为 $ans$
$$
ans=min(\frac{\sum_{i=1}^nval_i\times{x_i}}{\sum_{i=1}^ncost_i\times{x_i}})
$$
则一定有
$$
ans\times{\sum_{i=1}^ncost_i\times{x_i}}=\sum_{i=1}^nval_i\times{x_i}
$$
即
$$
\sum_{i=1}^nval_i\times{x_i}-ans\times{\sum_{i=1}^ncost_i\times{x_i}}=0
$$
所以，将每个物品的权值置为 $v-r\times{c}$，排序后，判断前k个物品的权值和与 $0$ 比较，进而缩小二分界限，得出 $ans$ 值。&lt;/p>
&lt;h1 id="最大比率环">最大比率环&lt;/h1>
&lt;p>和01分数规划思路基本相同，建立好模型后二分答案。&lt;/p>
&lt;p>通过判断图内是否存在负环来调整二分界限&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://img-blog.csdnimg.cn/20210213120449912.png" alt="fa" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p></description></item><item><title>坐标距离</title><link>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%9D%90%E6%A0%87%E8%A1%A8%E7%A4%BA%E6%B3%95/</link><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate><guid>/notes/oiknowledge/graph%E5%9B%BE%E8%AE%BA/%E5%9D%90%E6%A0%87%E8%A1%A8%E7%A4%BA%E6%B3%95/</guid><description>&lt;h1 id="坐标之间的常用距离">坐标之间的常用距离&lt;/h1>
&lt;p>通常，OI中使用到的两点之间坐标(针对于维度大于一的坐标系)通常用如下三种。&lt;/p>
&lt;h2 id="欧几里得距离">欧几里得距离&lt;/h2>
&lt;p>定义为&lt;strong>以两点为端点的线段的长度&lt;/strong>。&lt;/p>
&lt;p>如下图，欧几里得距离为&lt;font color="red">线段d&lt;/font>的长度。&lt;/p>
&lt;img src="geogebra-export.png" alt="adf" style="zoom:16%;" />
&lt;p>$S=\sqrt{\abs{1-3}^2+\abs{5-2}^2}\approx3.61$&lt;/p>
&lt;h2 id="曼哈顿距离">曼哈顿距离&lt;/h2>
&lt;p>两点 $x,y,z\space\cdots\cdots$ 坐标差的绝对值之和。&lt;/p>
&lt;p>如下图，曼哈顿距离为&lt;font color="red">线段d和线段g&lt;/font>的长度之和。&lt;/p>
&lt;img src="geogebra-export-16292841405421.png" alt="adsf" style="zoom:16%;" />
&lt;p>$S=\abs{5-2}+\abs{1-3}=3+2=5$&lt;/p>
&lt;h2 id="切比雪夫距离">切比雪夫距离&lt;/h2>
&lt;p>两点 $x,y,z\space\cdots\cdots$ 坐标差的绝对值的最大值。&lt;/p>
&lt;p>如下图，切比雪夫距离为&lt;font color="red">线段d和线段g&lt;/font>中长度较大的那一个，即&lt;font color="red">线段d&lt;/font>。&lt;/p>
&lt;img src="geogebra-export-16292841405421.png" alt="fa" style="zoom:16%;" />
&lt;p>$S=max(\abs{5-2},\abs{1-3})=max(3,2)=3$&lt;/p>
&lt;h2 id="坐标转化">坐标转化&lt;/h2>
&lt;p>一般提示距离的字眼：&lt;/p>
&lt;ul>
&lt;li>**欧几里得距离：**平面最短距离。&lt;/li>
&lt;li>**曼哈顿距离：**从一个点出发，可以上下左右移动到另一点，移动的最小步数。&lt;/li>
&lt;li>**切比雪夫距离：**从一个点出发，可以向八个方向（包括斜向）移动，移动点最小步数。(因为斜着移动同时改变两个坐标)&lt;/li>
&lt;/ul>
&lt;p>曼哈顿距离和切比雪夫距离之间可以通过坐标的变换进行相互转化：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>将每一个点 $(x,y)$ 转化为 $(x+y,x−y)$ ，新坐标系下的切比雪夫距离即为原坐标系下的曼哈顿距离。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将每一个点 $(x,y)$ 转化为 $(\frac{x+y}{2},\frac{x−y}{2})$，新坐标系下的曼哈顿距离即为原坐标系下的切比雪夫距离。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;del>这一段背住得了，&lt;a href="https://zhuanlan.zhihu.com/p/32878257" target="_blank" rel="noopener">证明&lt;/a>不看也罢。&lt;/del>&lt;/p></description></item></channel></rss>